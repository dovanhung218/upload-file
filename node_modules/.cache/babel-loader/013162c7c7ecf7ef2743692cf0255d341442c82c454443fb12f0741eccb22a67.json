{"ast":null,"code":"/** @license React v16.1.0-beta\n * react-reconciler.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  var $$$reconciler;\n  module.exports = function (config) {\n    'use strict';\n\n    var invariant = require('fbjs/lib/invariant');\n    var warning = require('fbjs/lib/warning');\n    var React = require('react');\n    var emptyObject = require('fbjs/lib/emptyObject');\n    var _assign = require('object-assign');\n    var checkPropTypes = require('prop-types/checkPropTypes');\n    var shallowEqual = require('fbjs/lib/shallowEqual');\n    var ReactFeatureFlags = {\n      enableAsyncSubtreeAPI: true,\n      enableAsyncSchedulingByDefaultInReactDOM: false,\n      // Mutating mode (React DOM, React ART, React Native):\n      enableMutatingReconciler: true,\n      // Experimental noop mode (currently unused):\n      enableNoopReconciler: false,\n      // Experimental persistent mode (CS):\n      enablePersistentReconciler: false,\n      // Exports React.Fragment\n      enableReactFragment: false,\n      // Exports ReactDOM.createRoot\n      enableCreateRoot: false\n    }; /**\n        * Copyright (c) 2013-present, Facebook, Inc.\n        *\n        * This source code is licensed under the MIT license found in the\n        * LICENSE file in the root directory of this source tree.\n        *\n        * \n        */\n\n    {\n      if (Object.freeze) {\n        Object.freeze(ReactFeatureFlags);\n      }\n    }\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    /**\n     * WARNING: DO NOT manually require this module.\n     * This is a replacement for `invariant(...)` used by the error code system\n     * and will _only_ be required by the corresponding babel pass.\n     * It always throws.\n     */\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     */\n\n    /**\n     * `ReactInstanceMap` maintains a mapping from a public facing stateful\n     * instance (key) and the internal representation (value). This allows public\n     * methods to accept the user facing instance as an argument and map them back\n     * to internal methods.\n     *\n     * Note that this module is currently shared and assumed to be stateless.\n     * If this becomes an actual Map, that will break.\n     */\n\n    /**\n       * This API should be called `delete` but we'd have to make sure to always\n       * transform these to strings for IE support. When this transform is fully\n       * supported we can rename it.\n       */\n\n    function get(key) {\n      return key._reactInternalFiber;\n    }\n    function set(key, value) {\n      key._reactInternalFiber = value;\n    }\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     */\n\n    var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n    function getComponentName(fiber) {\n      var type = fiber.type;\n      if (typeof type === 'string') {\n        return type;\n      }\n      if (typeof type === 'function') {\n        return type.displayName || type.name;\n      }\n      return null;\n    } /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       *\n       * \n       */\n\n    var IndeterminateComponent = 0; // Before we know whether it is functional or class\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var FunctionalComponent = 1;\n    var ClassComponent = 2;\n    var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n    var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n    var HostComponent = 5;\n    var HostText = 6;\n    var CallComponent = 7;\n    var CallHandlerPhase = 8;\n    var ReturnComponent = 9;\n    var Fragment = 10;\n\n    // Don't change these two values:\n    var NoEffect = 0; //           0b00000000\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var PerformedWork = 1; //      0b00000001\n\n    // You can change the rest (and add more).\n    var Placement = 2; //          0b00000010\n    var Update = 4; //             0b00000100\n    var PlacementAndUpdate = 6; // 0b00000110\n    var Deletion = 8; //           0b00001000\n    var ContentReset = 16; //      0b00010000\n    var Callback = 32; //          0b00100000\n    var Err = 64; //               0b01000000\n    var Ref = 128; //              0b10000000\n\n    var MOUNTING = 1;\n    var MOUNTED = 2;\n    var UNMOUNTED = 3;\n    function isFiberMountedImpl(fiber) {\n      var node = fiber;\n      if (!fiber.alternate) {\n        // If there is no alternate, this might be a new tree that isn't inserted\n        // yet. If it is, then it will have a pending insertion effect on it.\n        if ((node.effectTag & Placement) !== NoEffect) {\n          return MOUNTING;\n        }\n        while (node['return']) {\n          node = node['return'];\n          if ((node.effectTag & Placement) !== NoEffect) {\n            return MOUNTING;\n          }\n        }\n      } else {\n        while (node['return']) {\n          node = node['return'];\n        }\n      }\n      if (node.tag === HostRoot) {\n        // TODO: Check if this was a nested HostRoot when used with\n        // renderContainerIntoSubtree.\n        return MOUNTED;\n      }\n      // If we didn't hit the root, that means that we're in an disconnected tree\n      // that has been unmounted.\n      return UNMOUNTED;\n    }\n    function isFiberMounted(fiber) {\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    }\n    function isMounted(component) {\n      {\n        var owner = ReactCurrentOwner.current;\n        if (owner !== null && owner.tag === ClassComponent) {\n          var ownerFiber = owner;\n          var instance = ownerFiber.stateNode;\n          warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');\n          instance._warnedAboutRefsInRender = true;\n        }\n      }\n      var fiber = get(component);\n      if (!fiber) {\n        return false;\n      }\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    }\n    function assertIsMounted(fiber) {\n      !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    }\n    function findCurrentFiberUsingSlowPath(fiber) {\n      var alternate = fiber.alternate;\n      if (!alternate) {\n        // If there is no alternate, then we only need to check if it is mounted.\n        var state = isFiberMountedImpl(fiber);\n        !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n        if (state === MOUNTING) {\n          return null;\n        }\n        return fiber;\n      }\n      // If we have two possible branches, we'll walk backwards up to the root\n      // to see what path the root points to. On the way we may hit one of the\n      // special cases and we'll deal with them.\n      var a = fiber;\n      var b = alternate;\n      while (true) {\n        var parentA = a['return'];\n        var parentB = parentA ? parentA.alternate : null;\n        if (!parentA || !parentB) {\n          // We're at the root.\n          break;\n        }\n\n        // If both copies of the parent fiber point to the same child, we can\n        // assume that the child is current. This happens when we bailout on low\n        // priority: the bailed out fiber's child reuses the current child.\n        if (parentA.child === parentB.child) {\n          var child = parentA.child;\n          while (child) {\n            if (child === a) {\n              // We've determined that A is the current branch.\n              assertIsMounted(parentA);\n              return fiber;\n            }\n            if (child === b) {\n              // We've determined that B is the current branch.\n              assertIsMounted(parentA);\n              return alternate;\n            }\n            child = child.sibling;\n          }\n          // We should never have an alternate for any mounting node. So the only\n          // way this could possibly happen is if this was unmounted, if at all.\n          invariant(false, 'Unable to find node on an unmounted component.');\n        }\n        if (a['return'] !== b['return']) {\n          // The return pointer of A and the return pointer of B point to different\n          // fibers. We assume that return pointers never criss-cross, so A must\n          // belong to the child set of A.return, and B must belong to the child\n          // set of B.return.\n          a = parentA;\n          b = parentB;\n        } else {\n          // The return pointers point to the same fiber. We'll have to use the\n          // default, slow path: scan the child sets of each parent alternate to see\n          // which child belongs to which set.\n          //\n          // Search parent A's child set\n          var didFindChild = false;\n          var _child = parentA.child;\n          while (_child) {\n            if (_child === a) {\n              didFindChild = true;\n              a = parentA;\n              b = parentB;\n              break;\n            }\n            if (_child === b) {\n              didFindChild = true;\n              b = parentA;\n              a = parentB;\n              break;\n            }\n            _child = _child.sibling;\n          }\n          if (!didFindChild) {\n            // Search parent B's child set\n            _child = parentB.child;\n            while (_child) {\n              if (_child === a) {\n                didFindChild = true;\n                a = parentB;\n                b = parentA;\n                break;\n              }\n              if (_child === b) {\n                didFindChild = true;\n                b = parentB;\n                a = parentA;\n                break;\n              }\n              _child = _child.sibling;\n            }\n            !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n          }\n        }\n        !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n      // If the root is not a host container, we're in a disconnected tree. I.e.\n      // unmounted.\n      !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n      if (a.stateNode.current === a) {\n        // We've determined that A is the current branch.\n        return fiber;\n      }\n      // Otherwise B has to be current branch.\n      return alternate;\n    }\n    function findCurrentHostFiber(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n      if (!currentParent) {\n        return null;\n      }\n\n      // Next we'll drill down this component to find the first HostComponent/Text.\n      var node = currentParent;\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        } else if (node.child) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n        if (node === currentParent) {\n          return null;\n        }\n        while (!node.sibling) {\n          if (!node['return'] || node['return'] === currentParent) {\n            return null;\n          }\n          node = node['return'];\n        }\n        node.sibling['return'] = node['return'];\n        node = node.sibling;\n      }\n      // Flow needs the return null here, but ESLint complains about it.\n      // eslint-disable-next-line no-unreachable\n      return null;\n    }\n    function findCurrentHostFiberWithNoPortals(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n      if (!currentParent) {\n        return null;\n      }\n\n      // Next we'll drill down this component to find the first HostComponent/Text.\n      var node = currentParent;\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        } else if (node.child && node.tag !== HostPortal) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n        if (node === currentParent) {\n          return null;\n        }\n        while (!node.sibling) {\n          if (!node['return'] || node['return'] === currentParent) {\n            return null;\n          }\n          node = node['return'];\n        }\n        node.sibling['return'] = node['return'];\n        node = node.sibling;\n      }\n      // Flow needs the return null here, but ESLint complains about it.\n      // eslint-disable-next-line no-unreachable\n      return null;\n    }\n    var valueStack = [];\n    {\n      var fiberStack = [];\n    }\n    var index = -1;\n    function createCursor(defaultValue) {\n      return {\n        current: defaultValue\n      };\n    }\n    function pop(cursor, fiber) {\n      if (index < 0) {\n        {\n          warning(false, 'Unexpected pop.');\n        }\n        return;\n      }\n      {\n        if (fiber !== fiberStack[index]) {\n          warning(false, 'Unexpected Fiber popped.');\n        }\n      }\n      cursor.current = valueStack[index];\n      valueStack[index] = null;\n      {\n        fiberStack[index] = null;\n      }\n      index--;\n    }\n    function push(cursor, value, fiber) {\n      index++;\n      valueStack[index] = cursor.current;\n      {\n        fiberStack[index] = fiber;\n      }\n      cursor.current = value;\n    }\n    function reset() {\n      while (index > -1) {\n        valueStack[index] = null;\n        {\n          fiberStack[index] = null;\n        }\n        index--;\n      }\n    }\n\n    /**\n     * Copyright (c) 2016-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var describeComponentFrame = function (name, source, ownerName) {\n      return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n    };\n    function describeFiber(fiber) {\n      switch (fiber.tag) {\n        case IndeterminateComponent:\n        case FunctionalComponent:\n        case ClassComponent:\n        case HostComponent:\n          var owner = fiber._debugOwner;\n          var source = fiber._debugSource;\n          var name = getComponentName(fiber);\n          var ownerName = null;\n          if (owner) {\n            ownerName = getComponentName(owner);\n          }\n          return describeComponentFrame(name, source, ownerName);\n        default:\n          return '';\n      }\n    }\n\n    // This function can only be called with a work-in-progress fiber and\n    // only during begin or complete phase. Do not call it under any other\n    // circumstances.\n    function getStackAddendumByWorkInProgressFiber(workInProgress) {\n      var info = '';\n      var node = workInProgress;\n      do {\n        info += describeFiber(node);\n        // Otherwise this return pointer might point to the wrong tree:\n        node = node['return'];\n      } while (node);\n      return info;\n    }\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    function getCurrentFiberOwnerName() {\n      {\n        var fiber = ReactDebugCurrentFiber.current;\n        if (fiber === null) {\n          return null;\n        }\n        var owner = fiber._debugOwner;\n        if (owner !== null && typeof owner !== 'undefined') {\n          return getComponentName(owner);\n        }\n      }\n      return null;\n    }\n    function getCurrentFiberStackAddendum() {\n      {\n        var fiber = ReactDebugCurrentFiber.current;\n        if (fiber === null) {\n          return null;\n        }\n        // Safe because if current fiber exists, we are reconciling,\n        // and it is guaranteed to be the work-in-progress version.\n        return getStackAddendumByWorkInProgressFiber(fiber);\n      }\n      return null;\n    }\n    function resetCurrentFiber() {\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFiber.current = null;\n      ReactDebugCurrentFiber.phase = null;\n    }\n    function setCurrentFiber(fiber) {\n      ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n      ReactDebugCurrentFiber.current = fiber;\n      ReactDebugCurrentFiber.phase = null;\n    }\n    function setCurrentPhase(phase) {\n      ReactDebugCurrentFiber.phase = phase;\n    }\n    var ReactDebugCurrentFiber = {\n      current: null,\n      phase: null,\n      resetCurrentFiber: resetCurrentFiber,\n      setCurrentFiber: setCurrentFiber,\n      setCurrentPhase: setCurrentPhase,\n      getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n      getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n    };\n\n    // Trust the developer to only use this with a true check\n    var ReactDebugFiberPerf = {};\n    {\n      // Prefix measurements so that it's possible to filter them.\n      // Longer prefixes are hard to read in DevTools.\n      var reactEmoji = '\\u269B';\n      var warningEmoji = '\\u26D4';\n      var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n      // Keep track of current fiber so that we know the path to unwind on pause.\n      // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\n      var currentFiber = null;\n      // If we're in the middle of user code, which fiber and method is it?\n      // Reusing `currentFiber` would be confusing for this because user code fiber\n      // can change during commit phase too, but we don't need to unwind it (since\n      // lifecycles in the commit phase don't resemble a tree).\n      var currentPhase = null;\n      var currentPhaseFiber = null;\n      // Did lifecycle hook schedule an update? This is often a performance problem,\n      // so we will keep track of it, and include it in the report.\n      // Track commits caused by cascading updates.\n      var isCommitting = false;\n      var hasScheduledUpdateInCurrentCommit = false;\n      var hasScheduledUpdateInCurrentPhase = false;\n      var commitCountInCurrentWorkLoop = 0;\n      var effectCountInCurrentCommit = 0;\n      // During commits, we only show a measurement once per method name\n      // to avoid stretch the commit phase with measurement overhead.\n      var labelsInCurrentCommit = new Set();\n      var formatMarkName = function (markName) {\n        return reactEmoji + ' ' + markName;\n      };\n      var formatLabel = function (label, warning$$1) {\n        var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n        var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n        return '' + prefix + label + suffix;\n      };\n      var beginMark = function (markName) {\n        performance.mark(formatMarkName(markName));\n      };\n      var clearMark = function (markName) {\n        performance.clearMarks(formatMarkName(markName));\n      };\n      var endMark = function (label, markName, warning$$1) {\n        var formattedMarkName = formatMarkName(markName);\n        var formattedLabel = formatLabel(label, warning$$1);\n        try {\n          performance.measure(formattedLabel, formattedMarkName);\n        } catch (err) {}\n        // If previous mark was missing for some reason, this will throw.\n        // This could only happen if React crashed in an unexpected place earlier.\n        // Don't pile on with more errors.\n\n        // Clear marks immediately to avoid growing buffer.\n        performance.clearMarks(formattedMarkName);\n        performance.clearMeasures(formattedLabel);\n      };\n      var getFiberMarkName = function (label, debugID) {\n        return label + ' (#' + debugID + ')';\n      };\n      var getFiberLabel = function (componentName, isMounted, phase) {\n        if (phase === null) {\n          // These are composite component total time measurements.\n          return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n        } else {\n          // Composite component methods.\n          return componentName + '.' + phase;\n        }\n      };\n      var beginFiberMark = function (fiber, phase) {\n        var componentName = getComponentName(fiber) || 'Unknown';\n        var debugID = fiber._debugID;\n        var isMounted = fiber.alternate !== null;\n        var label = getFiberLabel(componentName, isMounted, phase);\n        if (isCommitting && labelsInCurrentCommit.has(label)) {\n          // During the commit phase, we don't show duplicate labels because\n          // there is a fixed overhead for every measurement, and we don't\n          // want to stretch the commit phase beyond necessary.\n          return false;\n        }\n        labelsInCurrentCommit.add(label);\n        var markName = getFiberMarkName(label, debugID);\n        beginMark(markName);\n        return true;\n      };\n      var clearFiberMark = function (fiber, phase) {\n        var componentName = getComponentName(fiber) || 'Unknown';\n        var debugID = fiber._debugID;\n        var isMounted = fiber.alternate !== null;\n        var label = getFiberLabel(componentName, isMounted, phase);\n        var markName = getFiberMarkName(label, debugID);\n        clearMark(markName);\n      };\n      var endFiberMark = function (fiber, phase, warning$$1) {\n        var componentName = getComponentName(fiber) || 'Unknown';\n        var debugID = fiber._debugID;\n        var isMounted = fiber.alternate !== null;\n        var label = getFiberLabel(componentName, isMounted, phase);\n        var markName = getFiberMarkName(label, debugID);\n        endMark(label, markName, warning$$1);\n      };\n      var shouldIgnoreFiber = function (fiber) {\n        // Host components should be skipped in the timeline.\n        // We could check typeof fiber.type, but does this work with RN?\n        switch (fiber.tag) {\n          case HostRoot:\n          case HostComponent:\n          case HostText:\n          case HostPortal:\n          case ReturnComponent:\n          case Fragment:\n            return true;\n          default:\n            return false;\n        }\n      };\n      var clearPendingPhaseMeasurement = function () {\n        if (currentPhase !== null && currentPhaseFiber !== null) {\n          clearFiberMark(currentPhaseFiber, currentPhase);\n        }\n        currentPhaseFiber = null;\n        currentPhase = null;\n        hasScheduledUpdateInCurrentPhase = false;\n      };\n      var pauseTimers = function () {\n        // Stops all currently active measurements so that they can be resumed\n        // if we continue in a later deferred loop from the same unit of work.\n        var fiber = currentFiber;\n        while (fiber) {\n          if (fiber._debugIsCurrentlyTiming) {\n            endFiberMark(fiber, null, null);\n          }\n          fiber = fiber['return'];\n        }\n      };\n      var resumeTimersRecursively = function (fiber) {\n        if (fiber['return'] !== null) {\n          resumeTimersRecursively(fiber['return']);\n        }\n        if (fiber._debugIsCurrentlyTiming) {\n          beginFiberMark(fiber, null);\n        }\n      };\n      var resumeTimers = function () {\n        // Resumes all measurements that were active during the last deferred loop.\n        if (currentFiber !== null) {\n          resumeTimersRecursively(currentFiber);\n        }\n      };\n      ReactDebugFiberPerf = {\n        recordEffect: function () {\n          effectCountInCurrentCommit++;\n        },\n        recordScheduleUpdate: function () {\n          if (isCommitting) {\n            hasScheduledUpdateInCurrentCommit = true;\n          }\n          if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n            hasScheduledUpdateInCurrentPhase = true;\n          }\n        },\n        startWorkTimer: function (fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          }\n          // If we pause, this is the fiber to unwind from.\n          currentFiber = fiber;\n          if (!beginFiberMark(fiber, null)) {\n            return;\n          }\n          fiber._debugIsCurrentlyTiming = true;\n        },\n        cancelWorkTimer: function (fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          }\n          // Remember we shouldn't complete measurement for this fiber.\n          // Otherwise flamechart will be deep even for small updates.\n          fiber._debugIsCurrentlyTiming = false;\n          clearFiberMark(fiber, null);\n        },\n        stopWorkTimer: function (fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          }\n          // If we pause, its parent is the fiber to unwind from.\n          currentFiber = fiber['return'];\n          if (!fiber._debugIsCurrentlyTiming) {\n            return;\n          }\n          fiber._debugIsCurrentlyTiming = false;\n          endFiberMark(fiber, null, null);\n        },\n        stopFailedWorkTimer: function (fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          }\n          // If we pause, its parent is the fiber to unwind from.\n          currentFiber = fiber['return'];\n          if (!fiber._debugIsCurrentlyTiming) {\n            return;\n          }\n          fiber._debugIsCurrentlyTiming = false;\n          var warning$$1 = 'An error was thrown inside this error boundary';\n          endFiberMark(fiber, null, warning$$1);\n        },\n        startPhaseTimer: function (fiber, phase) {\n          if (!supportsUserTiming) {\n            return;\n          }\n          clearPendingPhaseMeasurement();\n          if (!beginFiberMark(fiber, phase)) {\n            return;\n          }\n          currentPhaseFiber = fiber;\n          currentPhase = phase;\n        },\n        stopPhaseTimer: function () {\n          if (!supportsUserTiming) {\n            return;\n          }\n          if (currentPhase !== null && currentPhaseFiber !== null) {\n            var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n            endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n          }\n          currentPhase = null;\n          currentPhaseFiber = null;\n        },\n        startWorkLoopTimer: function () {\n          if (!supportsUserTiming) {\n            return;\n          }\n          commitCountInCurrentWorkLoop = 0;\n          // This is top level call.\n          // Any other measurements are performed within.\n          beginMark('(React Tree Reconciliation)');\n          // Resume any measurements that were in progress during the last loop.\n          resumeTimers();\n        },\n        stopWorkLoopTimer: function () {\n          if (!supportsUserTiming) {\n            return;\n          }\n          var warning$$1 = commitCountInCurrentWorkLoop > 1 ? 'There were cascading updates' : null;\n          commitCountInCurrentWorkLoop = 0;\n          // Pause any measurements until the next loop.\n          pauseTimers();\n          endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);\n        },\n        startCommitTimer: function () {\n          if (!supportsUserTiming) {\n            return;\n          }\n          isCommitting = true;\n          hasScheduledUpdateInCurrentCommit = false;\n          labelsInCurrentCommit.clear();\n          beginMark('(Committing Changes)');\n        },\n        stopCommitTimer: function () {\n          if (!supportsUserTiming) {\n            return;\n          }\n          var warning$$1 = null;\n          if (hasScheduledUpdateInCurrentCommit) {\n            warning$$1 = 'Lifecycle hook scheduled a cascading update';\n          } else if (commitCountInCurrentWorkLoop > 0) {\n            warning$$1 = 'Caused by a cascading update in earlier commit';\n          }\n          hasScheduledUpdateInCurrentCommit = false;\n          commitCountInCurrentWorkLoop++;\n          isCommitting = false;\n          labelsInCurrentCommit.clear();\n          endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n        },\n        startCommitHostEffectsTimer: function () {\n          if (!supportsUserTiming) {\n            return;\n          }\n          effectCountInCurrentCommit = 0;\n          beginMark('(Committing Host Effects)');\n        },\n        stopCommitHostEffectsTimer: function () {\n          if (!supportsUserTiming) {\n            return;\n          }\n          var count = effectCountInCurrentCommit;\n          effectCountInCurrentCommit = 0;\n          endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n        },\n        startCommitLifeCyclesTimer: function () {\n          if (!supportsUserTiming) {\n            return;\n          }\n          effectCountInCurrentCommit = 0;\n          beginMark('(Calling Lifecycle Methods)');\n        },\n        stopCommitLifeCyclesTimer: function () {\n          if (!supportsUserTiming) {\n            return;\n          }\n          var count = effectCountInCurrentCommit;\n          effectCountInCurrentCommit = 0;\n          endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n        }\n      };\n    }\n\n    // TODO: convert to named exports\n    // if this doesn't inflate the bundle.\n    var ReactDebugFiberPerf$1 = ReactDebugFiberPerf;\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var startPhaseTimer = ReactDebugFiberPerf$1.startPhaseTimer;\n    var stopPhaseTimer = ReactDebugFiberPerf$1.stopPhaseTimer;\n    {\n      var warnedAboutMissingGetChildContext = {};\n    }\n\n    // A cursor to the current merged context object on the stack.\n    var contextStackCursor = createCursor(emptyObject);\n    // A cursor to a boolean indicating whether the context has changed.\n    var didPerformWorkStackCursor = createCursor(false);\n    // Keep track of the previous context object that was on the stack.\n    // We use this to get access to the parent context after we have already\n    // pushed the next context provider, and now need to merge their contexts.\n    var previousContext = emptyObject;\n    function getUnmaskedContext(workInProgress) {\n      var hasOwnContext = isContextProvider(workInProgress);\n      if (hasOwnContext) {\n        // If the fiber is a context provider itself, when we read its context\n        // we have already pushed its own child context on the stack. A context\n        // provider should not \"see\" its own child context. Therefore we read the\n        // previous (parent) context instead for a context provider.\n        return previousContext;\n      }\n      return contextStackCursor.current;\n    }\n    function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n      var instance = workInProgress.stateNode;\n      instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n      instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n    }\n    function getMaskedContext(workInProgress, unmaskedContext) {\n      var type = workInProgress.type;\n      var contextTypes = type.contextTypes;\n      if (!contextTypes) {\n        return emptyObject;\n      }\n\n      // Avoid recreating masked context unless unmasked context has changed.\n      // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n      // This may trigger infinite loops if componentWillReceiveProps calls setState.\n      var instance = workInProgress.stateNode;\n      if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n        return instance.__reactInternalMemoizedMaskedChildContext;\n      }\n      var context = {};\n      for (var key in contextTypes) {\n        context[key] = unmaskedContext[key];\n      }\n      {\n        var name = getComponentName(workInProgress) || 'Unknown';\n        checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n      }\n\n      // Cache unmasked context so we can avoid recreating masked context unless necessary.\n      // Context is created before the class component is instantiated so check for instance.\n      if (instance) {\n        cacheContext(workInProgress, unmaskedContext, context);\n      }\n      return context;\n    }\n    function hasContextChanged() {\n      return didPerformWorkStackCursor.current;\n    }\n    function isContextConsumer(fiber) {\n      return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n    }\n    function isContextProvider(fiber) {\n      return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n    }\n    function popContextProvider(fiber) {\n      if (!isContextProvider(fiber)) {\n        return;\n      }\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n    function popTopLevelContextObject(fiber) {\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n    function pushTopLevelContextObject(fiber, context, didChange) {\n      !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      push(contextStackCursor, context, fiber);\n      push(didPerformWorkStackCursor, didChange, fiber);\n    }\n    function processChildContext(fiber, parentContext) {\n      var instance = fiber.stateNode;\n      var childContextTypes = fiber.type.childContextTypes;\n\n      // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n      // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n      if (typeof instance.getChildContext !== 'function') {\n        {\n          var componentName = getComponentName(fiber) || 'Unknown';\n          if (!warnedAboutMissingGetChildContext[componentName]) {\n            warnedAboutMissingGetChildContext[componentName] = true;\n            warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n          }\n        }\n        return parentContext;\n      }\n      var childContext = void 0;\n      {\n        ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n        startPhaseTimer(fiber, 'getChildContext');\n        childContext = instance.getChildContext();\n        stopPhaseTimer();\n        ReactDebugCurrentFiber.setCurrentPhase(null);\n      }\n      for (var contextKey in childContext) {\n        !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n      }\n      {\n        var name = getComponentName(fiber) || 'Unknown';\n        checkPropTypes(childContextTypes, childContext, 'child context', name,\n        // In practice, there is one case in which we won't get a stack. It's when\n        // somebody calls unstable_renderSubtreeIntoContainer() and we process\n        // context from the parent component instance. The stack will be missing\n        // because it's outside of the reconciliation, and so the pointer has not\n        // been set. This is rare and doesn't matter. We'll also remove that API.\n        ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n      }\n      return _assign({}, parentContext, childContext);\n    }\n    function pushContextProvider(workInProgress) {\n      if (!isContextProvider(workInProgress)) {\n        return false;\n      }\n      var instance = workInProgress.stateNode;\n      // We push the context as early as possible to ensure stack integrity.\n      // If the instance does not exist yet, we will push null at first,\n      // and replace it on the stack later when invalidating the context.\n      var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;\n\n      // Remember the parent context so we can merge with it later.\n      // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n      previousContext = contextStackCursor.current;\n      push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n      push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n      return true;\n    }\n    function invalidateContextProvider(workInProgress, didChange) {\n      var instance = workInProgress.stateNode;\n      !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      if (didChange) {\n        // Merge parent and own context.\n        // Skip this if we're not updating due to sCU.\n        // This avoids unnecessarily recomputing memoized values.\n        var mergedContext = processChildContext(workInProgress, previousContext);\n        instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n        // Replace the old (or empty) context with the new one.\n        // It is important to unwind the context in the reverse order.\n        pop(didPerformWorkStackCursor, workInProgress);\n        pop(contextStackCursor, workInProgress);\n        // Now push the new context and mark that it has changed.\n        push(contextStackCursor, mergedContext, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      } else {\n        pop(didPerformWorkStackCursor, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      }\n    }\n    function resetContext() {\n      previousContext = emptyObject;\n      contextStackCursor.current = emptyObject;\n      didPerformWorkStackCursor.current = false;\n    }\n    function findCurrentUnmaskedContext(fiber) {\n      // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n      // makes sense elsewhere\n      !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      var node = fiber;\n      while (node.tag !== HostRoot) {\n        if (isContextProvider(node)) {\n          return node.stateNode.__reactInternalMemoizedMergedChildContext;\n        }\n        var parent = node['return'];\n        !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        node = parent;\n      }\n      return node.stateNode.context;\n    }\n    var NoWork = 0; /**\n                            * Copyright (c) 2013-present, Facebook, Inc.\n                            *\n                            * This source code is licensed under the MIT license found in the\n                            * LICENSE file in the root directory of this source tree.\n                            *\n                            * \n                            */\n\n    // TODO: Use an opaque type once ESLint et al support the syntax\n\n    var Sync = 1;\n    var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1\n\n    var UNIT_SIZE = 10;\n    var MAGIC_NUMBER_OFFSET = 2;\n\n    // 1 unit of expiration time represents 10ms.\n    function msToExpirationTime(ms) {\n      // Always add an offset so that we don't clash with the magic number for NoWork.\n      return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n    }\n    function ceiling(num, precision) {\n      return ((num / precision | 0) + 1) * precision;\n    }\n    function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n      return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n    }\n    var NoContext = 0; /**\n                               * Copyright (c) 2013-present, Facebook, Inc.\n                               *\n                               * This source code is licensed under the MIT license found in the\n                               * LICENSE file in the root directory of this source tree.\n                               *\n                               * \n                               */\n\n    var AsyncUpdates = 1;\n    {\n      var hasBadMapPolyfill = false;\n      try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        /* eslint-disable no-new */\n        new Map([[nonExtensibleObject, null]]);\n        new Set([nonExtensibleObject]);\n        /* eslint-enable no-new */\n      } catch (e) {\n        // TODO: Consider warning about bad polyfills\n        hasBadMapPolyfill = true;\n      }\n    }\n\n    // A Fiber is work on a Component that needs to be done or was done. There can\n    // be more than one per component.\n\n    {\n      var debugCounter = 1;\n    }\n    function FiberNode(tag, key, internalContextTag) {\n      // Instance\n      this.tag = tag;\n      this.key = key;\n      this.type = null;\n      this.stateNode = null;\n\n      // Fiber\n      this['return'] = null;\n      this.child = null;\n      this.sibling = null;\n      this.index = 0;\n      this.ref = null;\n      this.pendingProps = null;\n      this.memoizedProps = null;\n      this.updateQueue = null;\n      this.memoizedState = null;\n      this.internalContextTag = internalContextTag;\n\n      // Effects\n      this.effectTag = NoEffect;\n      this.nextEffect = null;\n      this.firstEffect = null;\n      this.lastEffect = null;\n      this.expirationTime = NoWork;\n      this.alternate = null;\n      {\n        this._debugID = debugCounter++;\n        this._debugSource = null;\n        this._debugOwner = null;\n        this._debugIsCurrentlyTiming = false;\n        if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n          Object.preventExtensions(this);\n        }\n      }\n    }\n\n    // This is a constructor function, rather than a POJO constructor, still\n    // please ensure we do the following:\n    // 1) Nobody should add any instance methods on this. Instance methods can be\n    //    more difficult to predict when they get optimized and they are almost\n    //    never inlined properly in static compilers.\n    // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n    //    always know when it is a fiber.\n    // 3) We might want to experiment with using numeric keys since they are easier\n    //    to optimize in a non-JIT environment.\n    // 4) We can easily go from a constructor to a createFiber object literal if that\n    //    is faster.\n    // 5) It should be easy to port this to a C struct and keep a C implementation\n    //    compatible.\n    var createFiber = function (tag, key, internalContextTag) {\n      // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n      return new FiberNode(tag, key, internalContextTag);\n    };\n    function shouldConstruct(Component) {\n      return !!(Component.prototype && Component.prototype.isReactComponent);\n    }\n\n    // This is used to create an alternate fiber to do work on.\n    function createWorkInProgress(current, pendingProps, expirationTime) {\n      var workInProgress = current.alternate;\n      if (workInProgress === null) {\n        // We use a double buffering pooling technique because we know that we'll\n        // only ever need at most two versions of a tree. We pool the \"other\" unused\n        // node that we're free to reuse. This is lazily created to avoid allocating\n        // extra objects for things that are never updated. It also allow us to\n        // reclaim the extra memory if needed.\n        workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n        workInProgress.type = current.type;\n        workInProgress.stateNode = current.stateNode;\n        {\n          // DEV-only fields\n          workInProgress._debugID = current._debugID;\n          workInProgress._debugSource = current._debugSource;\n          workInProgress._debugOwner = current._debugOwner;\n        }\n        workInProgress.alternate = current;\n        current.alternate = workInProgress;\n      } else {\n        // We already have an alternate.\n        // Reset the effect tag.\n        workInProgress.effectTag = NoEffect;\n\n        // The effect list is no longer valid.\n        workInProgress.nextEffect = null;\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null;\n      }\n      workInProgress.expirationTime = expirationTime;\n      workInProgress.pendingProps = pendingProps;\n      workInProgress.child = current.child;\n      workInProgress.memoizedProps = current.memoizedProps;\n      workInProgress.memoizedState = current.memoizedState;\n      workInProgress.updateQueue = current.updateQueue;\n\n      // These will be overridden during the parent's reconciliation\n      workInProgress.sibling = current.sibling;\n      workInProgress.index = current.index;\n      workInProgress.ref = current.ref;\n      return workInProgress;\n    }\n    function createHostRootFiber() {\n      var fiber = createFiber(HostRoot, null, NoContext);\n      return fiber;\n    }\n    function createFiberFromElement(element, internalContextTag, expirationTime) {\n      var owner = null;\n      {\n        owner = element._owner;\n      }\n      var fiber = void 0;\n      var type = element.type,\n        key = element.key;\n      if (typeof type === 'function') {\n        fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);\n        fiber.type = type;\n        fiber.pendingProps = element.props;\n      } else if (typeof type === 'string') {\n        fiber = createFiber(HostComponent, key, internalContextTag);\n        fiber.type = type;\n        fiber.pendingProps = element.props;\n      } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n        // Currently assumed to be a continuation and therefore is a fiber already.\n        // TODO: The yield system is currently broken for updates in some cases.\n        // The reified yield stores a fiber, but we don't know which fiber that is;\n        // the current or a workInProgress? When the continuation gets rendered here\n        // we don't know if we can reuse that fiber or if we need to clone it.\n        // There is probably a clever way to restructure this.\n        fiber = type;\n        fiber.pendingProps = element.props;\n      } else {\n        var info = '';\n        {\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in.\";\n          }\n          var ownerName = owner ? getComponentName(owner) : null;\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n        }\n        invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n      }\n      {\n        fiber._debugSource = element._source;\n        fiber._debugOwner = element._owner;\n      }\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n    function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {\n      var fiber = createFiber(Fragment, key, internalContextTag);\n      fiber.pendingProps = elements;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n    function createFiberFromText(content, internalContextTag, expirationTime) {\n      var fiber = createFiber(HostText, null, internalContextTag);\n      fiber.pendingProps = content;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n    function createFiberFromHostInstanceForDeletion() {\n      var fiber = createFiber(HostComponent, null, NoContext);\n      fiber.type = 'DELETED';\n      return fiber;\n    }\n    function createFiberFromCall(call, internalContextTag, expirationTime) {\n      var fiber = createFiber(CallComponent, call.key, internalContextTag);\n      fiber.type = call.handler;\n      fiber.pendingProps = call;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n    function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {\n      var fiber = createFiber(ReturnComponent, null, internalContextTag);\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n    function createFiberFromPortal(portal, internalContextTag, expirationTime) {\n      var fiber = createFiber(HostPortal, portal.key, internalContextTag);\n      fiber.pendingProps = portal.children || [];\n      fiber.expirationTime = expirationTime;\n      fiber.stateNode = {\n        containerInfo: portal.containerInfo,\n        pendingChildren: null,\n        // Used by persistent updates\n        implementation: portal.implementation\n      };\n      return fiber;\n    }\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    function createFiberRoot(containerInfo, hydrate) {\n      // Cyclic construction. This cheats the type system right now because\n      // stateNode is any.\n      var uninitializedFiber = createHostRootFiber();\n      var root = {\n        current: uninitializedFiber,\n        containerInfo: containerInfo,\n        pendingChildren: null,\n        remainingExpirationTime: NoWork,\n        isReadyForCommit: false,\n        finishedWork: null,\n        context: null,\n        pendingContext: null,\n        hydrate: hydrate,\n        nextScheduledRoot: null\n      };\n      uninitializedFiber.stateNode = root;\n      return root;\n    }\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var ReactErrorUtils = {\n      // Used by Fiber to simulate a try-catch.\n      _caughtError: null,\n      _hasCaughtError: false,\n      // Used by event system to capture/rethrow the first error.\n      _rethrowError: null,\n      _hasRethrowError: false,\n      injection: {\n        injectErrorUtils: function (injectedErrorUtils) {\n          !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n          invokeGuardedCallback$1 = injectedErrorUtils.invokeGuardedCallback;\n        }\n      },\n      /**\n       * Call a function while guarding against errors that happens within it.\n       * Returns an error if it throws, otherwise null.\n       *\n       * In production, this is implemented using a try-catch. The reason we don't\n       * use a try-catch directly is so that we can swap out a different\n       * implementation in DEV mode.\n       *\n       * @param {String} name of the guard to use for logging or debugging\n       * @param {Function} func The function to invoke\n       * @param {*} context The context to use when calling the function\n       * @param {...*} args Arguments for function\n       */\n      invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n        invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n      },\n      /**\n       * Same as invokeGuardedCallback, but instead of returning an error, it stores\n       * it in a global so it can be rethrown by `rethrowCaughtError` later.\n       * TODO: See if _caughtError and _rethrowError can be unified.\n       *\n       * @param {String} name of the guard to use for logging or debugging\n       * @param {Function} func The function to invoke\n       * @param {*} context The context to use when calling the function\n       * @param {...*} args Arguments for function\n       */\n      invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n        ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n        if (ReactErrorUtils.hasCaughtError()) {\n          var error = ReactErrorUtils.clearCaughtError();\n          if (!ReactErrorUtils._hasRethrowError) {\n            ReactErrorUtils._hasRethrowError = true;\n            ReactErrorUtils._rethrowError = error;\n          }\n        }\n      },\n      /**\n       * During execution of guarded functions we will capture the first error which\n       * we will rethrow to be handled by the top level error handler.\n       */\n      rethrowCaughtError: function () {\n        return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n      },\n      hasCaughtError: function () {\n        return ReactErrorUtils._hasCaughtError;\n      },\n      clearCaughtError: function () {\n        if (ReactErrorUtils._hasCaughtError) {\n          var error = ReactErrorUtils._caughtError;\n          ReactErrorUtils._caughtError = null;\n          ReactErrorUtils._hasCaughtError = false;\n          return error;\n        } else {\n          invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n    };\n    var invokeGuardedCallback$1 = function (name, func, context, a, b, c, d, e, f) {\n      ReactErrorUtils._hasCaughtError = false;\n      ReactErrorUtils._caughtError = null;\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      try {\n        func.apply(context, funcArgs);\n      } catch (error) {\n        ReactErrorUtils._caughtError = error;\n        ReactErrorUtils._hasCaughtError = true;\n      }\n    };\n    {\n      // In DEV mode, we swap out invokeGuardedCallback for a special version\n      // that plays more nicely with the browser's DevTools. The idea is to preserve\n      // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n      // functions in invokeGuardedCallback, and the production version of\n      // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n      // like caught exceptions, and the DevTools won't pause unless the developer\n      // takes the extra step of enabling pause on caught exceptions. This is\n      // untintuitive, though, because even though React has caught the error, from\n      // the developer's perspective, the error is uncaught.\n      //\n      // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n      // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n      // DOM node, and call the user-provided callback from inside an event handler\n      // for that fake event. If the callback throws, the error is \"captured\" using\n      // a global event handler. But because the error happens in a different\n      // event loop context, it does not interrupt the normal program flow.\n      // Effectively, this gives us try-catch behavior without actually using\n      // try-catch. Neat!\n\n      // Check that the browser supports the APIs we need to implement our special\n      // DEV version of invokeGuardedCallback\n      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n        var fakeNode = document.createElement('react');\n        var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n          // Keeps track of whether the user-provided callback threw an error. We\n          // set this to true at the beginning, then set it to false right after\n          // calling the function. If the function errors, `didError` will never be\n          // set to false. This strategy works even if the browser is flaky and\n          // fails to call our global error handler, because it doesn't rely on\n          // the error event at all.\n          var didError = true;\n\n          // Create an event handler for our fake event. We will synchronously\n          // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n          // call the user-provided callback.\n          var funcArgs = Array.prototype.slice.call(arguments, 3);\n          function callCallback() {\n            // We immediately remove the callback from event listeners so that\n            // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n            // nested call would trigger the fake event handlers of any call higher\n            // in the stack.\n            fakeNode.removeEventListener(evtType, callCallback, false);\n            func.apply(context, funcArgs);\n            didError = false;\n          }\n\n          // Create a global error event handler. We use this to capture the value\n          // that was thrown. It's possible that this error handler will fire more\n          // than once; for example, if non-React code also calls `dispatchEvent`\n          // and a handler for that event throws. We should be resilient to most of\n          // those cases. Even if our error event handler fires more than once, the\n          // last error event is always used. If the callback actually does error,\n          // we know that the last error event is the correct one, because it's not\n          // possible for anything else to have happened in between our callback\n          // erroring and the code that follows the `dispatchEvent` call below. If\n          // the callback doesn't error, but the error event was fired, we know to\n          // ignore it because `didError` will be false, as described above.\n          var error = void 0;\n          // Use this to track whether the error event is ever called.\n          var didSetError = false;\n          var isCrossOriginError = false;\n          function onError(event) {\n            error = event.error;\n            didSetError = true;\n            if (error === null && event.colno === 0 && event.lineno === 0) {\n              isCrossOriginError = true;\n            }\n          }\n\n          // Create a fake event type.\n          var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n          // Attach our event handlers\n          window.addEventListener('error', onError);\n          fakeNode.addEventListener(evtType, callCallback, false);\n\n          // Synchronously dispatch our fake event. If the user-provided function\n          // errors, it will trigger our global error handler.\n          var evt = document.createEvent('Event');\n          evt.initEvent(evtType, false, false);\n          fakeNode.dispatchEvent(evt);\n          if (didError) {\n            if (!didSetError) {\n              // The callback errored, but the error event never fired.\n              error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n            } else if (isCrossOriginError) {\n              error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n            }\n            ReactErrorUtils._hasCaughtError = true;\n            ReactErrorUtils._caughtError = error;\n          } else {\n            ReactErrorUtils._hasCaughtError = false;\n            ReactErrorUtils._caughtError = null;\n          }\n\n          // Remove our event listeners\n          window.removeEventListener('error', onError);\n        };\n        invokeGuardedCallback$1 = invokeGuardedCallbackDev;\n      }\n    }\n    var rethrowCaughtError = function () {\n      if (ReactErrorUtils._hasRethrowError) {\n        var error = ReactErrorUtils._rethrowError;\n        ReactErrorUtils._rethrowError = null;\n        ReactErrorUtils._hasRethrowError = false;\n        throw error;\n      }\n    };\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    {\n      var didWarnUpdateInsideUpdate = false;\n    }\n\n    // Callbacks are not validated until invocation\n\n    // Singly linked-list of updates. When an update is scheduled, it is added to\n    // the queue of the current fiber and the work-in-progress fiber. The two queues\n    // are separate but they share a persistent structure.\n    //\n    // During reconciliation, updates are removed from the work-in-progress fiber,\n    // but they remain on the current fiber. That ensures that if a work-in-progress\n    // is aborted, the aborted updates are recovered by cloning from current.\n    //\n    // The work-in-progress queue is always a subset of the current queue.\n    //\n    // When the tree is committed, the work-in-progress becomes the current.\n\n    function createUpdateQueue(baseState) {\n      var queue = {\n        baseState: baseState,\n        expirationTime: NoWork,\n        first: null,\n        last: null,\n        callbackList: null,\n        hasForceUpdate: false,\n        isInitialized: false\n      };\n      {\n        queue.isProcessing = false;\n      }\n      return queue;\n    }\n    function insertUpdateIntoQueue(queue, update) {\n      // Append the update to the end of the list.\n      if (queue.last === null) {\n        // Queue is empty\n        queue.first = queue.last = update;\n      } else {\n        queue.last.next = update;\n        queue.last = update;\n      }\n      if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n        queue.expirationTime = update.expirationTime;\n      }\n    }\n    function insertUpdateIntoFiber(fiber, update) {\n      // We'll have at least one and at most two distinct update queues.\n      var alternateFiber = fiber.alternate;\n      var queue1 = fiber.updateQueue;\n      if (queue1 === null) {\n        // TODO: We don't know what the base state will be until we begin work.\n        // It depends on which fiber is the next current. Initialize with an empty\n        // base state, then set to the memoizedState when rendering. Not super\n        // happy with this approach.\n        queue1 = fiber.updateQueue = createUpdateQueue(null);\n      }\n      var queue2 = void 0;\n      if (alternateFiber !== null) {\n        queue2 = alternateFiber.updateQueue;\n        if (queue2 === null) {\n          queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n        }\n      } else {\n        queue2 = null;\n      }\n      queue2 = queue2 !== queue1 ? queue2 : null;\n\n      // Warn if an update is scheduled from inside an updater function.\n      {\n        if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n          warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n          didWarnUpdateInsideUpdate = true;\n        }\n      }\n\n      // If there's only one queue, add the update to that queue and exit.\n      if (queue2 === null) {\n        insertUpdateIntoQueue(queue1, update);\n        return;\n      }\n\n      // If either queue is empty, we need to add to both queues.\n      if (queue1.last === null || queue2.last === null) {\n        insertUpdateIntoQueue(queue1, update);\n        insertUpdateIntoQueue(queue2, update);\n        return;\n      }\n\n      // If both lists are not empty, the last update is the same for both lists\n      // because of structural sharing. So, we should only append to one of\n      // the lists.\n      insertUpdateIntoQueue(queue1, update);\n      // But we still need to update the `last` pointer of queue2.\n      queue2.last = update;\n    }\n    function getUpdateExpirationTime(fiber) {\n      if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {\n        return NoWork;\n      }\n      var updateQueue = fiber.updateQueue;\n      if (updateQueue === null) {\n        return NoWork;\n      }\n      return updateQueue.expirationTime;\n    }\n    function getStateFromUpdate(update, instance, prevState, props) {\n      var partialState = update.partialState;\n      if (typeof partialState === 'function') {\n        var updateFn = partialState;\n        return updateFn.call(instance, prevState, props);\n      } else {\n        return partialState;\n      }\n    }\n    function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n      if (current !== null && current.updateQueue === queue) {\n        // We need to create a work-in-progress queue, by cloning the current queue.\n        var currentQueue = queue;\n        queue = workInProgress.updateQueue = {\n          baseState: currentQueue.baseState,\n          expirationTime: currentQueue.expirationTime,\n          first: currentQueue.first,\n          last: currentQueue.last,\n          isInitialized: currentQueue.isInitialized,\n          // These fields are no longer valid because they were already committed.\n          // Reset them.\n          callbackList: null,\n          hasForceUpdate: false\n        };\n      }\n      {\n        // Set this flag so we can warn if setState is called inside the update\n        // function of another setState.\n        queue.isProcessing = true;\n      }\n\n      // Reset the remaining expiration time. If we skip over any updates, we'll\n      // increase this accordingly.\n      queue.expirationTime = NoWork;\n\n      // TODO: We don't know what the base state will be until we begin work.\n      // It depends on which fiber is the next current. Initialize with an empty\n      // base state, then set to the memoizedState when rendering. Not super\n      // happy with this approach.\n      var state = void 0;\n      if (queue.isInitialized) {\n        state = queue.baseState;\n      } else {\n        state = queue.baseState = workInProgress.memoizedState;\n        queue.isInitialized = true;\n      }\n      var dontMutatePrevState = true;\n      var update = queue.first;\n      var didSkip = false;\n      while (update !== null) {\n        var updateExpirationTime = update.expirationTime;\n        if (updateExpirationTime > renderExpirationTime) {\n          // This update does not have sufficient priority. Skip it.\n          var remainingExpirationTime = queue.expirationTime;\n          if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n            // Update the remaining expiration time.\n            queue.expirationTime = updateExpirationTime;\n          }\n          if (!didSkip) {\n            didSkip = true;\n            queue.baseState = state;\n          }\n          // Continue to the next update.\n          update = update.next;\n          continue;\n        }\n\n        // This update does have sufficient priority.\n\n        // If no previous updates were skipped, drop this update from the queue by\n        // advancing the head of the list.\n        if (!didSkip) {\n          queue.first = update.next;\n          if (queue.first === null) {\n            queue.last = null;\n          }\n        }\n\n        // Process the update\n        var _partialState = void 0;\n        if (update.isReplace) {\n          state = getStateFromUpdate(update, instance, state, props);\n          dontMutatePrevState = true;\n        } else {\n          _partialState = getStateFromUpdate(update, instance, state, props);\n          if (_partialState) {\n            if (dontMutatePrevState) {\n              // $FlowFixMe: Idk how to type this properly.\n              state = _assign({}, state, _partialState);\n            } else {\n              state = _assign(state, _partialState);\n            }\n            dontMutatePrevState = false;\n          }\n        }\n        if (update.isForced) {\n          queue.hasForceUpdate = true;\n        }\n        if (update.callback !== null) {\n          // Append to list of callbacks.\n          var _callbackList = queue.callbackList;\n          if (_callbackList === null) {\n            _callbackList = queue.callbackList = [];\n          }\n          _callbackList.push(update);\n        }\n        update = update.next;\n      }\n      if (queue.callbackList !== null) {\n        workInProgress.effectTag |= Callback;\n      } else if (queue.first === null && !queue.hasForceUpdate) {\n        // The queue is empty. We can reset it.\n        workInProgress.updateQueue = null;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      {\n        // No longer processing.\n        queue.isProcessing = false;\n      }\n      return state;\n    }\n    function commitCallbacks(queue, context) {\n      var callbackList = queue.callbackList;\n      if (callbackList === null) {\n        return;\n      }\n      // Set the list to null to make sure they don't get called more than once.\n      queue.callbackList = null;\n      for (var i = 0; i < callbackList.length; i++) {\n        var update = callbackList[i];\n        var _callback = update.callback;\n        // This update might be processed again. Clear the callback so it's only\n        // called once.\n        update.callback = null;\n        !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n        _callback.call(context);\n      }\n    }\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var startPhaseTimer$1 = ReactDebugFiberPerf$1.startPhaseTimer;\n    var stopPhaseTimer$1 = ReactDebugFiberPerf$1.stopPhaseTimer;\n    var fakeInternalInstance = {};\n    var isArray = Array.isArray;\n    {\n      var didWarnAboutStateAssignmentForComponent = {};\n      var warnOnInvalidCallback = function (callback, callerName) {\n        warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n      };\n\n      // This is so gross but it's at least non-critical and can be removed if\n      // it causes problems. This is meant to give a nicer error message for\n      // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n      // ...)) which otherwise throws a \"_processChildContext is not a function\"\n      // exception.\n      Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n        enumerable: false,\n        value: function () {\n          invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n        }\n      });\n      Object.freeze(fakeInternalInstance);\n    }\n    var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n      // Class component state updater\n      var updater = {\n        isMounted: isMounted,\n        enqueueSetState: function (instance, partialState, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'setState');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: partialState,\n            callback: callback,\n            isReplace: false,\n            isForced: false,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        },\n        enqueueReplaceState: function (instance, state, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'replaceState');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: state,\n            callback: callback,\n            isReplace: true,\n            isForced: false,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        },\n        enqueueForceUpdate: function (instance, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'forceUpdate');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: null,\n            callback: callback,\n            isReplace: false,\n            isForced: true,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        }\n      };\n      function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n        if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n          // If the workInProgress already has an Update effect, return true\n          return true;\n        }\n        var instance = workInProgress.stateNode;\n        var type = workInProgress.type;\n        if (typeof instance.shouldComponentUpdate === 'function') {\n          {\n            startPhaseTimer$1(workInProgress, 'shouldComponentUpdate');\n          }\n          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n          {\n            stopPhaseTimer$1();\n          }\n          {\n            warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');\n          }\n          return shouldUpdate;\n        }\n        if (type.prototype && type.prototype.isPureReactComponent) {\n          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n        }\n        return true;\n      }\n      function checkClassInstance(workInProgress) {\n        var instance = workInProgress.stateNode;\n        var type = workInProgress.type;\n        {\n          var name = getComponentName(workInProgress);\n          var renderPresent = instance.render;\n          if (!renderPresent) {\n            if (type.prototype && typeof type.prototype.render === 'function') {\n              warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n            } else {\n              warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n            }\n          }\n          var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n          warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n          var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n          warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n          var noInstancePropTypes = !instance.propTypes;\n          warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n          var noInstanceContextTypes = !instance.contextTypes;\n          warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n          var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n          warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n          if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n            warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n          }\n          var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n          warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n          var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n          warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n          var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n          warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n          var noInstanceDefaultProps = !instance.defaultProps;\n          warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n        }\n        var state = instance.state;\n        if (state && (typeof state !== 'object' || isArray(state))) {\n          invariant(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));\n        }\n        if (typeof instance.getChildContext === 'function') {\n          !(typeof workInProgress.type.childContextTypes === 'object') ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', getComponentName(workInProgress)) : void 0;\n        }\n      }\n      function resetInputPointers(workInProgress, instance) {\n        instance.props = workInProgress.memoizedProps;\n        instance.state = workInProgress.memoizedState;\n      }\n      function adoptClassInstance(workInProgress, instance) {\n        instance.updater = updater;\n        workInProgress.stateNode = instance;\n        // The instance needs access to the fiber so that it can schedule updates\n        set(instance, workInProgress);\n        {\n          instance._reactInternalInstance = fakeInternalInstance;\n        }\n      }\n      function constructClassInstance(workInProgress, props) {\n        var ctor = workInProgress.type;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var needsContext = isContextConsumer(workInProgress);\n        var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n        var instance = new ctor(props, context);\n        adoptClassInstance(workInProgress, instance);\n\n        // Cache unmasked context so we can avoid recreating masked context unless necessary.\n        // ReactFiberContext usually updates this cache but can't for newly-created instances.\n        if (needsContext) {\n          cacheContext(workInProgress, unmaskedContext, context);\n        }\n        return instance;\n      }\n      function callComponentWillMount(workInProgress, instance) {\n        {\n          startPhaseTimer$1(workInProgress, 'componentWillMount');\n        }\n        var oldState = instance.state;\n        instance.componentWillMount();\n        {\n          stopPhaseTimer$1();\n        }\n        if (oldState !== instance.state) {\n          {\n            warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress));\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      }\n      function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n        {\n          startPhaseTimer$1(workInProgress, 'componentWillReceiveProps');\n        }\n        var oldState = instance.state;\n        instance.componentWillReceiveProps(newProps, newContext);\n        {\n          stopPhaseTimer$1();\n        }\n        if (instance.state !== oldState) {\n          {\n            var componentName = getComponentName(workInProgress) || 'Component';\n            if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n              warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n              didWarnAboutStateAssignmentForComponent[componentName] = true;\n            }\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      }\n\n      // Invokes the mount life-cycles on a previously never rendered instance.\n      function mountClassInstance(workInProgress, renderExpirationTime) {\n        var current = workInProgress.alternate;\n        {\n          checkClassInstance(workInProgress);\n        }\n        var instance = workInProgress.stateNode;\n        var state = instance.state || null;\n        var props = workInProgress.pendingProps;\n        !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        instance.props = props;\n        instance.state = workInProgress.memoizedState = state;\n        instance.refs = emptyObject;\n        instance.context = getMaskedContext(workInProgress, unmaskedContext);\n        if (ReactFeatureFlags.enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n          workInProgress.internalContextTag |= AsyncUpdates;\n        }\n        if (typeof instance.componentWillMount === 'function') {\n          callComponentWillMount(workInProgress, instance);\n          // If we had additional state updates during this life-cycle, let's\n          // process them now.\n          var updateQueue = workInProgress.updateQueue;\n          if (updateQueue !== null) {\n            instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n          }\n        }\n        if (typeof instance.componentDidMount === 'function') {\n          workInProgress.effectTag |= Update;\n        }\n      }\n\n      // Called on a preexisting class instance. Returns false if a resumed render\n      // could be reused.\n      // function resumeMountClassInstance(\n      //   workInProgress: Fiber,\n      //   priorityLevel: PriorityLevel,\n      // ): boolean {\n      //   const instance = workInProgress.stateNode;\n      //   resetInputPointers(workInProgress, instance);\n\n      //   let newState = workInProgress.memoizedState;\n      //   let newProps = workInProgress.pendingProps;\n      //   if (!newProps) {\n      //     // If there isn't any new props, then we'll reuse the memoized props.\n      //     // This could be from already completed work.\n      //     newProps = workInProgress.memoizedProps;\n      //     invariant(\n      //       newProps != null,\n      //       'There should always be pending or memoized props. This error is ' +\n      //         'likely caused by a bug in React. Please file an issue.',\n      //     );\n      //   }\n      //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n      //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n      //   const oldContext = instance.context;\n      //   const oldProps = workInProgress.memoizedProps;\n\n      //   if (\n      //     typeof instance.componentWillReceiveProps === 'function' &&\n      //     (oldProps !== newProps || oldContext !== newContext)\n      //   ) {\n      //     callComponentWillReceiveProps(\n      //       workInProgress,\n      //       instance,\n      //       newProps,\n      //       newContext,\n      //     );\n      //   }\n\n      //   // Process the update queue before calling shouldComponentUpdate\n      //   const updateQueue = workInProgress.updateQueue;\n      //   if (updateQueue !== null) {\n      //     newState = processUpdateQueue(\n      //       workInProgress,\n      //       updateQueue,\n      //       instance,\n      //       newState,\n      //       newProps,\n      //       priorityLevel,\n      //     );\n      //   }\n\n      //   // TODO: Should we deal with a setState that happened after the last\n      //   // componentWillMount and before this componentWillMount? Probably\n      //   // unsupported anyway.\n\n      //   if (\n      //     !checkShouldComponentUpdate(\n      //       workInProgress,\n      //       workInProgress.memoizedProps,\n      //       newProps,\n      //       workInProgress.memoizedState,\n      //       newState,\n      //       newContext,\n      //     )\n      //   ) {\n      //     // Update the existing instance's state, props, and context pointers even\n      //     // though we're bailing out.\n      //     instance.props = newProps;\n      //     instance.state = newState;\n      //     instance.context = newContext;\n      //     return false;\n      //   }\n\n      //   // Update the input pointers now so that they are correct when we call\n      //   // componentWillMount\n      //   instance.props = newProps;\n      //   instance.state = newState;\n      //   instance.context = newContext;\n\n      //   if (typeof instance.componentWillMount === 'function') {\n      //     callComponentWillMount(workInProgress, instance);\n      //     // componentWillMount may have called setState. Process the update queue.\n      //     const newUpdateQueue = workInProgress.updateQueue;\n      //     if (newUpdateQueue !== null) {\n      //       newState = processUpdateQueue(\n      //         workInProgress,\n      //         newUpdateQueue,\n      //         instance,\n      //         newState,\n      //         newProps,\n      //         priorityLevel,\n      //       );\n      //     }\n      //   }\n\n      //   if (typeof instance.componentDidMount === 'function') {\n      //     workInProgress.effectTag |= Update;\n      //   }\n\n      //   instance.state = newState;\n\n      //   return true;\n      // }\n\n      // Invokes the update life-cycles and returns false if it shouldn't rerender.\n      function updateClassInstance(current, workInProgress, renderExpirationTime) {\n        var instance = workInProgress.stateNode;\n        resetInputPointers(workInProgress, instance);\n        var oldProps = workInProgress.memoizedProps;\n        var newProps = workInProgress.pendingProps;\n        if (!newProps) {\n          // If there aren't any new props, then we'll reuse the memoized props.\n          // This could be from already completed work.\n          newProps = oldProps;\n          !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        }\n        var oldContext = instance.context;\n        var newUnmaskedContext = getUnmaskedContext(workInProgress);\n        var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n        // Note: During these life-cycles, instance.props/instance.state are what\n        // ever the previously attempted to render - not the \"current\". However,\n        // during componentDidUpdate we pass the \"current\" props.\n\n        if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n          callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n        }\n\n        // Compute the next state using the memoized state and the update queue.\n        var oldState = workInProgress.memoizedState;\n        // TODO: Previous state can be null.\n        var newState = void 0;\n        if (workInProgress.updateQueue !== null) {\n          newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n        } else {\n          newState = oldState;\n        }\n        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n          // If an update was already in progress, we should schedule an Update\n          // effect even though we're bailing out, so that cWU/cDU are called.\n          if (typeof instance.componentDidUpdate === 'function') {\n            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n              workInProgress.effectTag |= Update;\n            }\n          }\n          return false;\n        }\n        var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n        if (shouldUpdate) {\n          if (typeof instance.componentWillUpdate === 'function') {\n            {\n              startPhaseTimer$1(workInProgress, 'componentWillUpdate');\n            }\n            instance.componentWillUpdate(newProps, newState, newContext);\n            {\n              stopPhaseTimer$1();\n            }\n          }\n          if (typeof instance.componentDidUpdate === 'function') {\n            workInProgress.effectTag |= Update;\n          }\n        } else {\n          // If an update was already in progress, we should schedule an Update\n          // effect even though we're bailing out, so that cWU/cDU are called.\n          if (typeof instance.componentDidUpdate === 'function') {\n            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n              workInProgress.effectTag |= Update;\n            }\n          }\n\n          // If shouldComponentUpdate returned false, we should still update the\n          // memoized props/state to indicate that this work can be reused.\n          memoizeProps(workInProgress, newProps);\n          memoizeState(workInProgress, newState);\n        }\n\n        // Update the existing instance's state, props, and context pointers even\n        // if shouldComponentUpdate returns false.\n        instance.props = newProps;\n        instance.state = newState;\n        instance.context = newContext;\n        return shouldUpdate;\n      }\n      return {\n        adoptClassInstance: adoptClassInstance,\n        constructClassInstance: constructClassInstance,\n        mountClassInstance: mountClassInstance,\n        // resumeMountClassInstance,\n        updateClassInstance: updateClassInstance\n      };\n    };\n\n    // The Symbol used to tag the special React types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n    var REACT_PORTAL_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca; /**\n                                                                                                                              * Copyright (c) 2014-present, Facebook, Inc.\n                                                                                                                              *\n                                                                                                                              * This source code is licensed under the MIT license found in the\n                                                                                                                              * LICENSE file in the root directory of this source tree.\n                                                                                                                              *\n                                                                                                                              * \n                                                                                                                              */\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n    {\n      var didWarnAboutMaps = false;\n      /**\n       * Warn if there's no key explicitly set on dynamic arrays of children or\n       * object keys are not valid. This allows us to keep track of children between\n       * updates.\n       */\n      var ownerHasKeyUseWarning = {};\n      var ownerHasFunctionTypeWarning = {};\n      var warnForMissingKey = function (child) {\n        if (child === null || typeof child !== 'object') {\n          return;\n        }\n        if (!child._store || child._store.validated || child.key != null) {\n          return;\n        }\n        !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        child._store.validated = true;\n        var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n        warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());\n      };\n    }\n    var isArray$1 = Array.isArray;\n    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n    var REACT_ELEMENT_TYPE;\n    var REACT_CALL_TYPE;\n    var REACT_RETURN_TYPE;\n    var REACT_FRAGMENT_TYPE;\n    if (typeof Symbol === 'function' && Symbol['for']) {\n      REACT_ELEMENT_TYPE = Symbol['for']('react.element');\n      REACT_CALL_TYPE = Symbol['for']('react.call');\n      REACT_RETURN_TYPE = Symbol['for']('react.return');\n      REACT_FRAGMENT_TYPE = Symbol['for']('react.fragment');\n    } else {\n      REACT_ELEMENT_TYPE = 0xeac7;\n      REACT_CALL_TYPE = 0xeac8;\n      REACT_RETURN_TYPE = 0xeac9;\n      REACT_FRAGMENT_TYPE = 0xeacb;\n    }\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n        return null;\n      }\n      var iteratorFn = ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n      if (typeof iteratorFn === 'function') {\n        return iteratorFn;\n      }\n      return null;\n    }\n    function coerceRef(current, element) {\n      var mixedRef = element.ref;\n      if (mixedRef !== null && typeof mixedRef !== 'function') {\n        if (element._owner) {\n          var owner = element._owner;\n          var inst = void 0;\n          if (owner) {\n            var ownerFiber = owner;\n            !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n            inst = ownerFiber.stateNode;\n          }\n          !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n          var stringRef = '' + mixedRef;\n          // Check if previous string ref matches new string ref\n          if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n            return current.ref;\n          }\n          var ref = function (value) {\n            var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n            if (value === null) {\n              delete refs[stringRef];\n            } else {\n              refs[stringRef] = value;\n            }\n          };\n          ref._stringRef = stringRef;\n          return ref;\n        } else {\n          !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n          !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n        }\n      }\n      return mixedRef;\n    }\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n      if (returnFiber.type !== 'textarea') {\n        var addendum = '';\n        {\n          addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');\n        }\n        invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n      }\n    }\n    function warnOnFunctionType() {\n      var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');\n      if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n        return;\n      }\n      ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n      warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');\n    }\n\n    // This wrapper function exists because I expect to clone the code in each path\n    // to be able to optimize each path individually by branching early. This needs\n    // a compiler or we can do it manually. Helpers that don't need this branching\n    // live outside of this function.\n    function ChildReconciler(shouldClone, shouldTrackSideEffects) {\n      function deleteChild(returnFiber, childToDelete) {\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return;\n        }\n        if (!shouldClone) {\n          // When we're reconciling in place we have a work in progress copy. We\n          // actually want the current copy. If there is no current copy, then we\n          // don't need to track deletion side-effects.\n          if (childToDelete.alternate === null) {\n            return;\n          }\n          childToDelete = childToDelete.alternate;\n        }\n        // Deletions are added in reversed order so we add it to the front.\n        // At this point, the return fiber's effect list is empty except for\n        // deletions, so we can just append the deletion to the list. The remaining\n        // effects aren't added until the complete phase. Once we implement\n        // resuming, this may not be true.\n        var last = returnFiber.lastEffect;\n        if (last !== null) {\n          last.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n        childToDelete.nextEffect = null;\n        childToDelete.effectTag = Deletion;\n      }\n      function deleteRemainingChildren(returnFiber, currentFirstChild) {\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return null;\n        }\n\n        // TODO: For the shouldClone case, this could be micro-optimized a bit by\n        // assuming that after the first child we've already added everything.\n        var childToDelete = currentFirstChild;\n        while (childToDelete !== null) {\n          deleteChild(returnFiber, childToDelete);\n          childToDelete = childToDelete.sibling;\n        }\n        return null;\n      }\n      function mapRemainingChildren(returnFiber, currentFirstChild) {\n        // Add the remaining children to a temporary map so that we can find them by\n        // keys quickly. Implicit (null) keys get added to this set with their index\n        var existingChildren = new Map();\n        var existingChild = currentFirstChild;\n        while (existingChild !== null) {\n          if (existingChild.key !== null) {\n            existingChildren.set(existingChild.key, existingChild);\n          } else {\n            existingChildren.set(existingChild.index, existingChild);\n          }\n          existingChild = existingChild.sibling;\n        }\n        return existingChildren;\n      }\n      function useFiber(fiber, pendingProps, expirationTime) {\n        // We currently set sibling to null and index to 0 here because it is easy\n        // to forget to do before returning it. E.g. for the single child case.\n        if (shouldClone) {\n          var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n          clone.index = 0;\n          clone.sibling = null;\n          return clone;\n        } else {\n          // We override the expiration time even if it is earlier, because if\n          // we're reconciling at a later time that means that this was\n          // down-prioritized.\n          fiber.expirationTime = expirationTime;\n          fiber.effectTag = NoEffect;\n          fiber.index = 0;\n          fiber.sibling = null;\n          fiber.pendingProps = pendingProps;\n          return fiber;\n        }\n      }\n      function placeChild(newFiber, lastPlacedIndex, newIndex) {\n        newFiber.index = newIndex;\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return lastPlacedIndex;\n        }\n        var current = newFiber.alternate;\n        if (current !== null) {\n          var oldIndex = current.index;\n          if (oldIndex < lastPlacedIndex) {\n            // This is a move.\n            newFiber.effectTag = Placement;\n            return lastPlacedIndex;\n          } else {\n            // This item can stay in place.\n            return oldIndex;\n          }\n        } else {\n          // This is an insertion.\n          newFiber.effectTag = Placement;\n          return lastPlacedIndex;\n        }\n      }\n      function placeSingleChild(newFiber) {\n        // This is simpler for the single child case. We only need to do a\n        // placement for inserting new children.\n        if (shouldTrackSideEffects && newFiber.alternate === null) {\n          newFiber.effectTag = Placement;\n        }\n        return newFiber;\n      }\n      function updateTextNode(returnFiber, current, textContent, expirationTime) {\n        if (current === null || current.tag !== HostText) {\n          // Insert\n          var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, textContent, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n      function updateElement(returnFiber, current, element, expirationTime) {\n        if (current !== null && current.type === element.type) {\n          // Move based on index\n          var existing = useFiber(current, element.props, expirationTime);\n          existing.ref = coerceRef(current, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          // Insert\n          var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n          created.ref = coerceRef(current, element);\n          created['return'] = returnFiber;\n          return created;\n        }\n      }\n      function updateCall(returnFiber, current, call, expirationTime) {\n        // TODO: Should this also compare handler to determine whether to reuse?\n        if (current === null || current.tag !== CallComponent) {\n          // Insert\n          var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, call, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n      function updateReturn(returnFiber, current, returnNode, expirationTime) {\n        if (current === null || current.tag !== ReturnComponent) {\n          // Insert\n          var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n          created.type = returnNode.value;\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, null, expirationTime);\n          existing.type = returnNode.value;\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n      function updatePortal(returnFiber, current, portal, expirationTime) {\n        if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n          // Insert\n          var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n      function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n        if (current === null || current.tag !== Fragment) {\n          // Insert\n          var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, fragment, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n      function createChild(returnFiber, newChild, expirationTime) {\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a text\n          // node.\n          var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        }\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                if (newChild.type === REACT_FRAGMENT_TYPE) {\n                  var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);\n                  _created['return'] = returnFiber;\n                  return _created;\n                } else {\n                  var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);\n                  _created2.ref = coerceRef(null, newChild);\n                  _created2['return'] = returnFiber;\n                  return _created2;\n                }\n              }\n            case REACT_CALL_TYPE:\n              {\n                var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);\n                _created3['return'] = returnFiber;\n                return _created3;\n              }\n            case REACT_RETURN_TYPE:\n              {\n                var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);\n                _created4.type = newChild.value;\n                _created4['return'] = returnFiber;\n                return _created4;\n              }\n            case REACT_PORTAL_TYPE:\n              {\n                var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);\n                _created5['return'] = returnFiber;\n                return _created5;\n              }\n          }\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);\n            _created6['return'] = returnFiber;\n            return _created6;\n          }\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n      function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n        // Update the fiber if the keys match, otherwise return null.\n\n        var key = oldFiber !== null ? oldFiber.key : null;\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a text\n          // node.\n          if (key !== null) {\n            return null;\n          }\n          return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n        }\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                if (newChild.key === key) {\n                  if (newChild.type === REACT_FRAGMENT_TYPE) {\n                    return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n                  }\n                  return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n            case REACT_CALL_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updateCall(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n            case REACT_RETURN_TYPE:\n              {\n                // Returns don't have keys. If the previous node is implicitly keyed\n                // we can continue to replace it without aborting even if it is not a\n                // yield.\n                if (key === null) {\n                  return updateReturn(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n            case REACT_PORTAL_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n          }\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            if (key !== null) {\n              return null;\n            }\n            return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n          }\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys, so we neither have to check the old nor\n          // new node for the key. If both are text nodes, they match.\n          var matchedFiber = existingChildren.get(newIdx) || null;\n          return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n        }\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                if (newChild.type === REACT_FRAGMENT_TYPE) {\n                  return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n                }\n                return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n              }\n            case REACT_CALL_TYPE:\n              {\n                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);\n              }\n            case REACT_RETURN_TYPE:\n              {\n                // Returns don't have keys, so we neither have to check the old nor\n                // new node for the key. If both are returns, they match.\n                var _matchedFiber3 = existingChildren.get(newIdx) || null;\n                return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);\n              }\n            case REACT_PORTAL_TYPE:\n              {\n                var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);\n              }\n          }\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            var _matchedFiber5 = existingChildren.get(newIdx) || null;\n            return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);\n          }\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      /**\n       * Warns if there is a duplicate or missing key\n       */\n      function warnOnInvalidKey(child, knownKeys) {\n        {\n          if (typeof child !== 'object' || child === null) {\n            return knownKeys;\n          }\n          switch (child.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n            case REACT_CALL_TYPE:\n            case REACT_PORTAL_TYPE:\n              warnForMissingKey(child);\n              var key = child.key;\n              if (typeof key !== 'string') {\n                break;\n              }\n              if (knownKeys === null) {\n                knownKeys = new Set();\n                knownKeys.add(key);\n                break;\n              }\n              if (!knownKeys.has(key)) {\n                knownKeys.add(key);\n                break;\n              }\n              warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());\n              break;\n            default:\n              break;\n          }\n        }\n        return knownKeys;\n      }\n      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n        // This algorithm can't optimize by searching from boths ends since we\n        // don't have backpointers on fibers. I'm trying to see how far we can get\n        // with that model. If it ends up not being worth the tradeoffs, we can\n        // add it later.\n\n        // Even with a two ended optimization, we'd want to optimize for the case\n        // where there are few changes and brute force the comparison instead of\n        // going for the Map. It'd like to explore hitting that path first in\n        // forward-only mode and only go for the Map once we notice that we need\n        // lots of look ahead. This doesn't handle reversal as well as two ended\n        // search but that's unusual. Besides, for the two ended optimization to\n        // work on Iterables, we'd need to copy the whole set.\n\n        // In this first iteration, we'll just live with hitting the bad case\n        // (adding everything to a Map) in for every insert/move.\n\n        // If you change this code, also update reconcileChildrenIterator() which\n        // uses the same algorithm.\n\n        {\n          // First, validate keys.\n          var knownKeys = null;\n          for (var i = 0; i < newChildren.length; i++) {\n            var child = newChildren[i];\n            knownKeys = warnOnInvalidKey(child, knownKeys);\n          }\n        }\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n        for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n          if (newFiber === null) {\n            // TODO: This breaks on empty slots like null children. That's\n            // unfortunate because it triggers the slow path all the time. We need\n            // a better way to communicate whether this was a miss or null,\n            // boolean, undefined, etc.\n            if (oldFiber === null) {\n              oldFiber = nextOldFiber;\n            }\n            break;\n          }\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              // We matched the slot, but we didn't reuse the existing fiber, so we\n              // need to delete the existing child.\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n          if (previousNewFiber === null) {\n            // TODO: Move out of the loop. This only happens for the first run.\n            resultingFirstChild = newFiber;\n          } else {\n            // TODO: Defer siblings if we're not at the right index for this slot.\n            // I.e. if we had null values before, then we want to defer this\n            // for each null value. However, we also don't want to call updateSlot\n            // with the previous one.\n            previousNewFiber.sibling = newFiber;\n          }\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n        if (newIdx === newChildren.length) {\n          // We've reached the end of the new children. We can delete the rest.\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n        if (oldFiber === null) {\n          // If we don't have any more existing children we can choose a fast path\n          // since the rest will all be insertions.\n          for (; newIdx < newChildren.length; newIdx++) {\n            var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n            if (!_newFiber) {\n              continue;\n            }\n            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n            if (previousNewFiber === null) {\n              // TODO: Move out of the loop. This only happens for the first run.\n              resultingFirstChild = _newFiber;\n            } else {\n              previousNewFiber.sibling = _newFiber;\n            }\n            previousNewFiber = _newFiber;\n          }\n          return resultingFirstChild;\n        }\n\n        // Add all children to a key map for quick lookups.\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n        // Keep scanning and use the map to restore deleted items as moves.\n        for (; newIdx < newChildren.length; newIdx++) {\n          var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n          if (_newFiber2) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber2.alternate !== null) {\n                // The new fiber is a work in progress, but if there exists a\n                // current, that means that we reused the fiber. We need to delete\n                // it from the child list so that we don't add it to the deletion\n                // list.\n                existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n              }\n            }\n            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber2;\n            } else {\n              previousNewFiber.sibling = _newFiber2;\n            }\n            previousNewFiber = _newFiber2;\n          }\n        }\n        if (shouldTrackSideEffects) {\n          // Any existing children that weren't consumed above were deleted. We need\n          // to add them to the deletion list.\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n        return resultingFirstChild;\n      }\n      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n        // This is the same implementation as reconcileChildrenArray(),\n        // but using the iterator instead.\n\n        var iteratorFn = getIteratorFn(newChildrenIterable);\n        !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        {\n          // Warn about using Maps as children\n          if (typeof newChildrenIterable.entries === 'function') {\n            var possibleMap = newChildrenIterable;\n            if (possibleMap.entries === iteratorFn) {\n              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());\n              didWarnAboutMaps = true;\n            }\n          }\n\n          // First, validate keys.\n          // We'll get a different iterator later for the main pass.\n          var _newChildren = iteratorFn.call(newChildrenIterable);\n          if (_newChildren) {\n            var knownKeys = null;\n            var _step = _newChildren.next();\n            for (; !_step.done; _step = _newChildren.next()) {\n              var child = _step.value;\n              knownKeys = warnOnInvalidKey(child, knownKeys);\n            }\n          }\n        }\n        var newChildren = iteratorFn.call(newChildrenIterable);\n        !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n        var step = newChildren.next();\n        for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n          var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n          if (newFiber === null) {\n            // TODO: This breaks on empty slots like null children. That's\n            // unfortunate because it triggers the slow path all the time. We need\n            // a better way to communicate whether this was a miss or null,\n            // boolean, undefined, etc.\n            if (!oldFiber) {\n              oldFiber = nextOldFiber;\n            }\n            break;\n          }\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              // We matched the slot, but we didn't reuse the existing fiber, so we\n              // need to delete the existing child.\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n          if (previousNewFiber === null) {\n            // TODO: Move out of the loop. This only happens for the first run.\n            resultingFirstChild = newFiber;\n          } else {\n            // TODO: Defer siblings if we're not at the right index for this slot.\n            // I.e. if we had null values before, then we want to defer this\n            // for each null value. However, we also don't want to call updateSlot\n            // with the previous one.\n            previousNewFiber.sibling = newFiber;\n          }\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n        if (step.done) {\n          // We've reached the end of the new children. We can delete the rest.\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n        if (oldFiber === null) {\n          // If we don't have any more existing children we can choose a fast path\n          // since the rest will all be insertions.\n          for (; !step.done; newIdx++, step = newChildren.next()) {\n            var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n            if (_newFiber3 === null) {\n              continue;\n            }\n            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n            if (previousNewFiber === null) {\n              // TODO: Move out of the loop. This only happens for the first run.\n              resultingFirstChild = _newFiber3;\n            } else {\n              previousNewFiber.sibling = _newFiber3;\n            }\n            previousNewFiber = _newFiber3;\n          }\n          return resultingFirstChild;\n        }\n\n        // Add all children to a key map for quick lookups.\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n        // Keep scanning and use the map to restore deleted items as moves.\n        for (; !step.done; newIdx++, step = newChildren.next()) {\n          var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n          if (_newFiber4 !== null) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber4.alternate !== null) {\n                // The new fiber is a work in progress, but if there exists a\n                // current, that means that we reused the fiber. We need to delete\n                // it from the child list so that we don't add it to the deletion\n                // list.\n                existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n              }\n            }\n            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber4;\n            } else {\n              previousNewFiber.sibling = _newFiber4;\n            }\n            previousNewFiber = _newFiber4;\n          }\n        }\n        if (shouldTrackSideEffects) {\n          // Any existing children that weren't consumed above were deleted. We need\n          // to add them to the deletion list.\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n        return resultingFirstChild;\n      }\n      function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n        // There's no need to check for keys on text nodes since we don't have a\n        // way to define them.\n        if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n          // We already have an existing node so let's just update it and delete\n          // the rest.\n          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n          var existing = useFiber(currentFirstChild, textContent, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n        // The existing first child is not a text node so we need to create one\n        // and delete the existing ones.\n        deleteRemainingChildren(returnFiber, currentFirstChild);\n        var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      }\n      function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n        var key = element.key;\n        var child = currentFirstChild;\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n              existing.ref = coerceRef(child, element);\n              existing['return'] = returnFiber;\n              {\n                existing._debugSource = element._source;\n                existing._debugOwner = element._owner;\n              }\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n          child = child.sibling;\n        }\n        if (element.type === REACT_FRAGMENT_TYPE) {\n          var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n          _created7.ref = coerceRef(currentFirstChild, element);\n          _created7['return'] = returnFiber;\n          return _created7;\n        }\n      }\n      function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {\n        var key = call.key;\n        var child = currentFirstChild;\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === CallComponent) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, call, expirationTime);\n              existing['return'] = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n          child = child.sibling;\n        }\n        var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      }\n      function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {\n        // There's no need to check for keys on yields since they're stateless.\n        var child = currentFirstChild;\n        if (child !== null) {\n          if (child.tag === ReturnComponent) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            var existing = useFiber(child, null, expirationTime);\n            existing.type = returnNode.value;\n            existing['return'] = returnFiber;\n            return existing;\n          } else {\n            deleteRemainingChildren(returnFiber, child);\n          }\n        }\n        var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n        created.type = returnNode.value;\n        created['return'] = returnFiber;\n        return created;\n      }\n      function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n        var key = portal.key;\n        var child = currentFirstChild;\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, portal.children || [], expirationTime);\n              existing['return'] = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n          child = child.sibling;\n        }\n        var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      // This API will tag the children with the side-effect of the reconciliation\n      // itself. They will be added to the side-effect list as we pass through the\n      // children and the parent.\n      function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n        // This function is not recursive.\n        // If the top level item is an array, we treat it as a set of children,\n        // not as a fragment. Nested arrays on the other hand will be treated as\n        // fragment nodes. Recursion happens at the normal flow.\n\n        // Handle top level unkeyed fragments as if they were arrays.\n        // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n        // We treat the ambiguous cases above the same.\n        if (ReactFeatureFlags.enableReactFragment && typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n          newChild = newChild.props.children;\n        }\n\n        // Handle object types\n        var isObject = typeof newChild === 'object' && newChild !== null;\n        if (isObject) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n            case REACT_CALL_TYPE:\n              return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));\n            case REACT_RETURN_TYPE:\n              return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));\n            case REACT_PORTAL_TYPE:\n              return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n          }\n        }\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n        }\n        if (isArray$1(newChild)) {\n          return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n        }\n        if (getIteratorFn(newChild)) {\n          return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n        }\n        if (isObject) {\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        if (typeof newChild === 'undefined') {\n          // If the new child is undefined, and the return fiber is a composite\n          // component, throw an error. If Fiber return types are disabled,\n          // we already threw above.\n          switch (returnFiber.tag) {\n            case ClassComponent:\n              {\n                {\n                  var instance = returnFiber.stateNode;\n                  if (instance.render._isMockFunction) {\n                    // We allow auto-mocks to proceed as if they're returning null.\n                    break;\n                  }\n                }\n              }\n            // Intentionally fall through to the next case, which handles both\n            // functions and classes\n            // eslint-disable-next-lined no-fallthrough\n            case FunctionalComponent:\n              {\n                var Component = returnFiber.type;\n                invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n              }\n          }\n        }\n\n        // Remaining cases are all treated as empty.\n        return deleteRemainingChildren(returnFiber, currentFirstChild);\n      }\n      return reconcileChildFibers;\n    }\n    var reconcileChildFibers = ChildReconciler(true, true);\n    var reconcileChildFibersInPlace = ChildReconciler(false, true);\n    var mountChildFibersInPlace = ChildReconciler(false, false);\n    function cloneChildFibers(current, workInProgress) {\n      !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n      if (workInProgress.child === null) {\n        return;\n      }\n      var currentChild = workInProgress.child;\n      var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n      workInProgress.child = newChild;\n      newChild['return'] = workInProgress;\n      while (currentChild.sibling !== null) {\n        currentChild = currentChild.sibling;\n        newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n        newChild['return'] = workInProgress;\n      }\n      newChild.sibling = null;\n    }\n    var cancelWorkTimer = ReactDebugFiberPerf$1.cancelWorkTimer;\n    {\n      var warnedAboutStatelessRefs = {};\n    }\n    var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n      var shouldSetTextContent = config.shouldSetTextContent,\n        useSyncScheduling = config.useSyncScheduling,\n        shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n      var pushHostContext = hostContext.pushHostContext,\n        pushHostContainer = hostContext.pushHostContainer;\n      var enterHydrationState = hydrationContext.enterHydrationState,\n        resetHydrationState = hydrationContext.resetHydrationState,\n        tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n      var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n        adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n        constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n        mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n        updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n      // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n      function reconcileChildren(current, workInProgress, nextChildren) {\n        reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n      }\n      function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n        if (current === null) {\n          // If this is a fresh new component that hasn't been rendered yet, we\n          // won't update its child set by applying minimal side-effects. Instead,\n          // we will add them all to the child before it gets rendered. That means\n          // we can optimize this reconciliation pass by not tracking side-effects.\n          workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n        } else if (current.child === workInProgress.child) {\n          // If the current child is the same as the work in progress, it means that\n          // we haven't yet started any work on these children. Therefore, we use\n          // the clone algorithm to create a copy of all the current children.\n\n          // If we had any progressed work already, that is invalid at this point so\n          // let's throw it out.\n          workInProgress.child = reconcileChildFibers(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n        } else {\n          // If, on the other hand, it is already using a clone, that means we've\n          // already begun some work on this tree and we can continue where we left\n          // off by reconciling against the existing children.\n          workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n        }\n      }\n      function updateFragment(current, workInProgress) {\n        var nextChildren = workInProgress.pendingProps;\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextChildren === null) {\n            nextChildren = workInProgress.memoizedProps;\n          }\n        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextChildren);\n        return workInProgress.child;\n      }\n      function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n        if (ref !== null && (!current || current.ref !== ref)) {\n          // Schedule a Ref effect\n          workInProgress.effectTag |= Ref;\n        }\n      }\n      function updateFunctionalComponent(current, workInProgress) {\n        var fn = workInProgress.type;\n        var nextProps = workInProgress.pendingProps;\n        var memoizedProps = workInProgress.memoizedProps;\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextProps === null) {\n            nextProps = memoizedProps;\n          }\n        } else {\n          if (nextProps === null || memoizedProps === nextProps) {\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n          // TODO: consider bringing fn.shouldComponentUpdate() back.\n          // It used to be here.\n        }\n\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var context = getMaskedContext(workInProgress, unmaskedContext);\n        var nextChildren;\n        {\n          ReactCurrentOwner.current = workInProgress;\n          ReactDebugCurrentFiber.setCurrentPhase('render');\n          nextChildren = fn(nextProps, context);\n          ReactDebugCurrentFiber.setCurrentPhase(null);\n        }\n        // React DevTools reads this flag.\n        workInProgress.effectTag |= PerformedWork;\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextProps);\n        return workInProgress.child;\n      }\n      function updateClassComponent(current, workInProgress, renderExpirationTime) {\n        // Push context providers early to prevent context stack mismatches.\n        // During mounting we don't know the child context yet as the instance doesn't exist.\n        // We will invalidate the child context in finishClassComponent() right after rendering.\n        var hasContext = pushContextProvider(workInProgress);\n        var shouldUpdate = void 0;\n        if (current === null) {\n          if (!workInProgress.stateNode) {\n            // In the initial pass we might need to construct the instance.\n            constructClassInstance(workInProgress, workInProgress.pendingProps);\n            mountClassInstance(workInProgress, renderExpirationTime);\n            shouldUpdate = true;\n          } else {\n            invariant(false, 'Resuming work not yet implemented.');\n            // In a resume, we'll already have an instance we can reuse.\n            // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n          }\n        } else {\n          shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n        }\n        return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n      }\n      function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n        // Refs should update even if shouldComponentUpdate returns false\n        markRef(current, workInProgress);\n        if (!shouldUpdate) {\n          // Context providers should defer to sCU for rendering\n          if (hasContext) {\n            invalidateContextProvider(workInProgress, false);\n          }\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n        var instance = workInProgress.stateNode;\n\n        // Rerender\n        ReactCurrentOwner.current = workInProgress;\n        var nextChildren = void 0;\n        {\n          ReactDebugCurrentFiber.setCurrentPhase('render');\n          nextChildren = instance.render();\n          ReactDebugCurrentFiber.setCurrentPhase(null);\n        }\n        // React DevTools reads this flag.\n        workInProgress.effectTag |= PerformedWork;\n        reconcileChildren(current, workInProgress, nextChildren);\n        // Memoize props and state using the values we just used to render.\n        // TODO: Restructure so we never read values from the instance.\n        memoizeState(workInProgress, instance.state);\n        memoizeProps(workInProgress, instance.props);\n\n        // The context might have changed so we need to recalculate it.\n        if (hasContext) {\n          invalidateContextProvider(workInProgress, true);\n        }\n        return workInProgress.child;\n      }\n      function pushHostRootContext(workInProgress) {\n        var root = workInProgress.stateNode;\n        if (root.pendingContext) {\n          pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n        } else if (root.context) {\n          // Should always be set\n          pushTopLevelContextObject(workInProgress, root.context, false);\n        }\n        pushHostContainer(workInProgress, root.containerInfo);\n      }\n      function updateHostRoot(current, workInProgress, renderExpirationTime) {\n        pushHostRootContext(workInProgress);\n        var updateQueue = workInProgress.updateQueue;\n        if (updateQueue !== null) {\n          var prevState = workInProgress.memoizedState;\n          var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n          if (prevState === state) {\n            // If the state is the same as before, that's a bailout because we had\n            // no work that expires at this time.\n            resetHydrationState();\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n          var element = state.element;\n          var root = workInProgress.stateNode;\n          if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n            // If we don't have any current children this might be the first pass.\n            // We always try to hydrate. If this isn't a hydration pass there won't\n            // be any children to hydrate which is effectively the same thing as\n            // not hydrating.\n\n            // This is a bit of a hack. We track the host root as a placement to\n            // know that we're currently in a mounting state. That way isMounted\n            // works as expected. We must reset this before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag |= Placement;\n\n            // Ensure that children mount into this root without tracking\n            // side-effects. This ensures that we don't store Placement effects on\n            // nodes that will be hydrated.\n            workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, element, renderExpirationTime);\n          } else {\n            // Otherwise reset hydration state in case we aborted and resumed another\n            // root.\n            resetHydrationState();\n            reconcileChildren(current, workInProgress, element);\n          }\n          memoizeState(workInProgress, state);\n          return workInProgress.child;\n        }\n        resetHydrationState();\n        // If there is no update queue, that's a bailout because the root has no props.\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      function updateHostComponent(current, workInProgress, renderExpirationTime) {\n        pushHostContext(workInProgress);\n        if (current === null) {\n          tryToClaimNextHydratableInstance(workInProgress);\n        }\n        var type = workInProgress.type;\n        var memoizedProps = workInProgress.memoizedProps;\n        var nextProps = workInProgress.pendingProps;\n        if (nextProps === null) {\n          nextProps = memoizedProps;\n          !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        }\n        var prevProps = current !== null ? current.memoizedProps : null;\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n        } else if (nextProps === null || memoizedProps === nextProps) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n        var nextChildren = nextProps.children;\n        var isDirectTextChild = shouldSetTextContent(type, nextProps);\n        if (isDirectTextChild) {\n          // We special case a direct text child of a host node. This is a common\n          // case. We won't handle it as a reified child. We will instead handle\n          // this in the host environment that also have access to this prop. That\n          // avoids allocating another HostText fiber and traversing it.\n          nextChildren = null;\n        } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n          // If we're switching from a direct text child to a normal child, or to\n          // empty, we need to schedule the text content to be reset.\n          workInProgress.effectTag |= ContentReset;\n        }\n        markRef(current, workInProgress);\n\n        // Check the host config to see if the children are offscreen/hidden.\n        if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n          // Down-prioritize the children.\n          workInProgress.expirationTime = Never;\n          // Bailout and come back to this fiber later.\n          return null;\n        }\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextProps);\n        return workInProgress.child;\n      }\n      function updateHostText(current, workInProgress) {\n        if (current === null) {\n          tryToClaimNextHydratableInstance(workInProgress);\n        }\n        var nextProps = workInProgress.pendingProps;\n        if (nextProps === null) {\n          nextProps = workInProgress.memoizedProps;\n        }\n        memoizeProps(workInProgress, nextProps);\n        // Nothing to do here. This is terminal. We'll do the completion step\n        // immediately after.\n        return null;\n      }\n      function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n        !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var fn = workInProgress.type;\n        var props = workInProgress.pendingProps;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var context = getMaskedContext(workInProgress, unmaskedContext);\n        var value;\n        {\n          if (fn.prototype && typeof fn.prototype.render === 'function') {\n            var componentName = getComponentName(workInProgress);\n            warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n          }\n          ReactCurrentOwner.current = workInProgress;\n          value = fn(props, context);\n        }\n        // React DevTools reads this flag.\n        workInProgress.effectTag |= PerformedWork;\n        if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n          // Proceed under the assumption that this is a class instance\n          workInProgress.tag = ClassComponent;\n\n          // Push context providers early to prevent context stack mismatches.\n          // During mounting we don't know the child context yet as the instance doesn't exist.\n          // We will invalidate the child context in finishClassComponent() right after rendering.\n          var hasContext = pushContextProvider(workInProgress);\n          adoptClassInstance(workInProgress, value);\n          mountClassInstance(workInProgress, renderExpirationTime);\n          return finishClassComponent(current, workInProgress, true, hasContext);\n        } else {\n          // Proceed under the assumption that this is a functional component\n          workInProgress.tag = FunctionalComponent;\n          {\n            var Component = workInProgress.type;\n            if (Component) {\n              warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n            }\n            if (workInProgress.ref !== null) {\n              var info = '';\n              var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n              if (ownerName) {\n                info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n              }\n              var warningKey = ownerName || workInProgress._debugID || '';\n              var debugSource = workInProgress._debugSource;\n              if (debugSource) {\n                warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n              }\n              if (!warnedAboutStatelessRefs[warningKey]) {\n                warnedAboutStatelessRefs[warningKey] = true;\n                warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n              }\n            }\n          }\n          reconcileChildren(current, workInProgress, value);\n          memoizeProps(workInProgress, props);\n          return workInProgress.child;\n        }\n      }\n      function updateCallComponent(current, workInProgress, renderExpirationTime) {\n        var nextCall = workInProgress.pendingProps;\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextCall === null) {\n            nextCall = current && current.memoizedProps;\n            !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          }\n        } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {\n          nextCall = workInProgress.memoizedProps;\n          // TODO: When bailing out, we might need to return the stateNode instead\n          // of the child. To check it for work.\n          // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var nextChildren = nextCall.children;\n\n        // The following is a fork of reconcileChildrenAtExpirationTime but using\n        // stateNode to store the child.\n        if (current === null) {\n          workInProgress.stateNode = mountChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        } else if (current.child === workInProgress.child) {\n          workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        } else {\n          workInProgress.stateNode = reconcileChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        }\n        memoizeProps(workInProgress, nextCall);\n        // This doesn't take arbitrary time so we could synchronously just begin\n        // eagerly do the work of workInProgress.child as an optimization.\n        return workInProgress.stateNode;\n      }\n      function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        var nextChildren = workInProgress.pendingProps;\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextChildren === null) {\n            nextChildren = current && current.memoizedProps;\n            !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          }\n        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n        if (current === null) {\n          // Portals are special because we don't append the children during mount\n          // but at commit. Therefore we need to track insertions which the normal\n          // flow doesn't do during mount. This doesn't happen at the root because\n          // the root always starts with a \"current\" with a null child.\n          // TODO: Consider unifying this with how the root works.\n          workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n          memoizeProps(workInProgress, nextChildren);\n        } else {\n          reconcileChildren(current, workInProgress, nextChildren);\n          memoizeProps(workInProgress, nextChildren);\n        }\n        return workInProgress.child;\n      }\n\n      /*\n      function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n        let child = firstChild;\n        do {\n          // Ensure that the first and last effect of the parent corresponds\n          // to the children's first and last effect.\n          if (!returnFiber.firstEffect) {\n            returnFiber.firstEffect = child.firstEffect;\n          }\n          if (child.lastEffect) {\n            if (returnFiber.lastEffect) {\n              returnFiber.lastEffect.nextEffect = child.firstEffect;\n            }\n            returnFiber.lastEffect = child.lastEffect;\n          }\n        } while (child = child.sibling);\n      }\n      */\n\n      function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n        {\n          cancelWorkTimer(workInProgress);\n        }\n\n        // TODO: We should ideally be able to bail out early if the children have no\n        // more work to do. However, since we don't have a separation of this\n        // Fiber's priority and its children yet - we don't know without doing lots\n        // of the same work we do anyway. Once we have that separation we can just\n        // bail out here if the children has no more work at this priority level.\n        // if (workInProgress.priorityOfChildren <= priorityLevel) {\n        //   // If there are side-effects in these children that have not yet been\n        //   // committed we need to ensure that they get properly transferred up.\n        //   if (current && current.child !== workInProgress.child) {\n        //     reuseChildrenEffects(workInProgress, child);\n        //   }\n        //   return null;\n        // }\n\n        cloneChildFibers(current, workInProgress);\n        return workInProgress.child;\n      }\n      function bailoutOnLowPriority(current, workInProgress) {\n        {\n          cancelWorkTimer(workInProgress);\n        }\n\n        // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n        // See PR 8590 discussion for context\n        switch (workInProgress.tag) {\n          case HostRoot:\n            pushHostRootContext(workInProgress);\n            break;\n          case ClassComponent:\n            pushContextProvider(workInProgress);\n            break;\n          case HostPortal:\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            break;\n        }\n        // TODO: What if this is currently in progress?\n        // How can that happen? How is this not being cloned?\n        return null;\n      }\n\n      // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n      function memoizeProps(workInProgress, nextProps) {\n        workInProgress.memoizedProps = nextProps;\n      }\n      function memoizeState(workInProgress, nextState) {\n        workInProgress.memoizedState = nextState;\n        // Don't reset the updateQueue, in case there are pending updates. Resetting\n        // is handled by processUpdateQueue.\n      }\n\n      function beginWork(current, workInProgress, renderExpirationTime) {\n        if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n          return bailoutOnLowPriority(current, workInProgress);\n        }\n        switch (workInProgress.tag) {\n          case IndeterminateComponent:\n            return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n          case FunctionalComponent:\n            return updateFunctionalComponent(current, workInProgress);\n          case ClassComponent:\n            return updateClassComponent(current, workInProgress, renderExpirationTime);\n          case HostRoot:\n            return updateHostRoot(current, workInProgress, renderExpirationTime);\n          case HostComponent:\n            return updateHostComponent(current, workInProgress, renderExpirationTime);\n          case HostText:\n            return updateHostText(current, workInProgress);\n          case CallHandlerPhase:\n            // This is a restart. Reset the tag to the initial phase.\n            workInProgress.tag = CallComponent;\n          // Intentionally fall through since this is now the same.\n          case CallComponent:\n            return updateCallComponent(current, workInProgress, renderExpirationTime);\n          case ReturnComponent:\n            // A return component is just a placeholder, we can just run through the\n            // next one immediately.\n            return null;\n          case HostPortal:\n            return updatePortalComponent(current, workInProgress, renderExpirationTime);\n          case Fragment:\n            return updateFragment(current, workInProgress);\n          default:\n            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n      function beginFailedWork(current, workInProgress, renderExpirationTime) {\n        // Push context providers here to avoid a push/pop context mismatch.\n        switch (workInProgress.tag) {\n          case ClassComponent:\n            pushContextProvider(workInProgress);\n            break;\n          case HostRoot:\n            pushHostRootContext(workInProgress);\n            break;\n          default:\n            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n        }\n\n        // Add an error effect so we can handle the error during the commit phase\n        workInProgress.effectTag |= Err;\n\n        // This is a weird case where we do \"resume\" work — work that failed on\n        // our first attempt. Because we no longer have a notion of \"progressed\n        // deletions,\" reset the child to the current child to make sure we delete\n        // it again. TODO: Find a better way to handle this, perhaps during a more\n        // general overhaul of error handling.\n        if (current === null) {\n          workInProgress.child = null;\n        } else if (workInProgress.child !== current.child) {\n          workInProgress.child = current.child;\n        }\n        if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n          return bailoutOnLowPriority(current, workInProgress);\n        }\n\n        // If we don't bail out, we're going be recomputing our children so we need\n        // to drop our effect list.\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null;\n\n        // Unmount the current children as if the component rendered null\n        var nextChildren = null;\n        reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n        if (workInProgress.tag === ClassComponent) {\n          var instance = workInProgress.stateNode;\n          workInProgress.memoizedProps = instance.props;\n          workInProgress.memoizedState = instance.state;\n        }\n        return workInProgress.child;\n      }\n      return {\n        beginWork: beginWork,\n        beginFailedWork: beginFailedWork\n      };\n    };\n    var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {\n      var createInstance = config.createInstance,\n        createTextInstance = config.createTextInstance,\n        appendInitialChild = config.appendInitialChild,\n        finalizeInitialChildren = config.finalizeInitialChildren,\n        prepareUpdate = config.prepareUpdate,\n        mutation = config.mutation,\n        persistence = config.persistence;\n      var getRootHostContainer = hostContext.getRootHostContainer,\n        popHostContext = hostContext.popHostContext,\n        getHostContext = hostContext.getHostContext,\n        popHostContainer = hostContext.popHostContainer;\n      var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n        prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n        popHydrationState = hydrationContext.popHydrationState;\n      function markUpdate(workInProgress) {\n        // Tag the fiber with an update effect. This turns a Placement into\n        // an UpdateAndPlacement.\n        workInProgress.effectTag |= Update;\n      }\n      function markRef(workInProgress) {\n        workInProgress.effectTag |= Ref;\n      }\n      function appendAllReturns(returns, workInProgress) {\n        var node = workInProgress.stateNode;\n        if (node) {\n          node['return'] = workInProgress;\n        }\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n            invariant(false, 'A call cannot have host component children.');\n          } else if (node.tag === ReturnComponent) {\n            returns.push(node.type);\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n      function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n        var call = workInProgress.memoizedProps;\n        !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n        // First step of the call has completed. Now we need to do the second.\n        // TODO: It would be nice to have a multi stage call represented by a\n        // single component, or at least tail call optimize nested ones. Currently\n        // that requires additional fields that we don't want to add to the fiber.\n        // So this requires nested handlers.\n        // Note: This doesn't mutate the alternate node. I don't think it needs to\n        // since this stage is reset for every pass.\n        workInProgress.tag = CallHandlerPhase;\n\n        // Build up the returns.\n        // TODO: Compare this to a generator or opaque helpers like Children.\n        var returns = [];\n        appendAllReturns(returns, workInProgress);\n        var fn = call.handler;\n        var props = call.props;\n        var nextChildren = fn(props, returns);\n        var currentFirstChild = current !== null ? current.child : null;\n        workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n        return workInProgress.child;\n      }\n      function appendAllChildren(parent, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendInitialChild(parent, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n      var updateHostContainer = void 0;\n      var updateHostComponent = void 0;\n      var updateHostText = void 0;\n      if (mutation) {\n        if (ReactFeatureFlags.enableMutatingReconciler) {\n          // Mutation mode\n          updateHostContainer = function (workInProgress) {\n            // Noop\n          };\n          updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n            // TODO: Type this specific to this type of component.\n            workInProgress.updateQueue = updatePayload;\n            // If the update payload indicates that there is a change or if there\n            // is a new ref we mark this as an update. All the work is done in commitWork.\n            if (updatePayload) {\n              markUpdate(workInProgress);\n            }\n          };\n          updateHostText = function (current, workInProgress, oldText, newText) {\n            // If the text differs, mark it as an update. All the work in done in commitWork.\n            if (oldText !== newText) {\n              markUpdate(workInProgress);\n            }\n          };\n        } else {\n          invariant(false, 'Mutating reconciler is disabled.');\n        }\n      } else if (persistence) {\n        if (ReactFeatureFlags.enablePersistentReconciler) {\n          // Persistent host tree mode\n          var cloneInstance = persistence.cloneInstance,\n            createContainerChildSet = persistence.createContainerChildSet,\n            appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n            finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n          // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n          var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n            // We only have the top Fiber that was created but we need recurse down its\n            // children to find all the terminal nodes.\n            var node = workInProgress.child;\n            while (node !== null) {\n              if (node.tag === HostComponent || node.tag === HostText) {\n                appendChildToContainerChildSet(containerChildSet, node.stateNode);\n              } else if (node.tag === HostPortal) {\n                // If we have a portal child, then we don't want to traverse\n                // down its children. Instead, we'll get insertions from each child in\n                // the portal directly.\n              } else if (node.child !== null) {\n                node.child['return'] = node;\n                node = node.child;\n                continue;\n              }\n              if (node === workInProgress) {\n                return;\n              }\n              while (node.sibling === null) {\n                if (node['return'] === null || node['return'] === workInProgress) {\n                  return;\n                }\n                node = node['return'];\n              }\n              node.sibling['return'] = node['return'];\n              node = node.sibling;\n            }\n          };\n          updateHostContainer = function (workInProgress) {\n            var portalOrRoot = workInProgress.stateNode;\n            var childrenUnchanged = workInProgress.firstEffect === null;\n            if (childrenUnchanged) {\n              // No changes, just reuse the existing instance.\n            } else {\n              var container = portalOrRoot.containerInfo;\n              var newChildSet = createContainerChildSet(container);\n              if (finalizeContainerChildren(container, newChildSet)) {\n                markUpdate(workInProgress);\n              }\n              portalOrRoot.pendingChildren = newChildSet;\n              // If children might have changed, we have to add them all to the set.\n              appendAllChildrenToContainer(newChildSet, workInProgress);\n              // Schedule an update on the container to swap out the container.\n              markUpdate(workInProgress);\n            }\n          };\n          updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n            // If there are no effects associated with this node, then none of our children had any updates.\n            // This guarantees that we can reuse all of them.\n            var childrenUnchanged = workInProgress.firstEffect === null;\n            var currentInstance = current.stateNode;\n            if (childrenUnchanged && updatePayload === null) {\n              // No changes, just reuse the existing instance.\n              // Note that this might release a previous clone.\n              workInProgress.stateNode = currentInstance;\n            } else {\n              var recyclableInstance = workInProgress.stateNode;\n              var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n              if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {\n                markUpdate(workInProgress);\n              }\n              workInProgress.stateNode = newInstance;\n              if (childrenUnchanged) {\n                // If there are no other effects in this tree, we need to flag this node as having one.\n                // Even though we're not going to use it for anything.\n                // Otherwise parents won't know that there are new children to propagate upwards.\n                markUpdate(workInProgress);\n              } else {\n                // If children might have changed, we have to add them all to the set.\n                appendAllChildren(newInstance, workInProgress);\n              }\n            }\n          };\n          updateHostText = function (current, workInProgress, oldText, newText) {\n            if (oldText !== newText) {\n              // If the text content differs, we'll create a new text instance for it.\n              var rootContainerInstance = getRootHostContainer();\n              var currentHostContext = getHostContext();\n              workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n              // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n              // This lets the parents know that at least one of their children has changed.\n              markUpdate(workInProgress);\n            }\n          };\n        } else {\n          invariant(false, 'Persistent reconciler is disabled.');\n        }\n      } else {\n        if (ReactFeatureFlags.enableNoopReconciler) {\n          // No host operations\n          updateHostContainer = function (workInProgress) {\n            // Noop\n          };\n          updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n            // Noop\n          };\n          updateHostText = function (current, workInProgress, oldText, newText) {\n            // Noop\n          };\n        } else {\n          invariant(false, 'Noop reconciler is disabled.');\n        }\n      }\n      function completeWork(current, workInProgress, renderExpirationTime) {\n        // Get the latest props.\n        var newProps = workInProgress.pendingProps;\n        if (newProps === null) {\n          newProps = workInProgress.memoizedProps;\n        } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {\n          // Reset the pending props, unless this was a down-prioritization.\n          workInProgress.pendingProps = null;\n        }\n        switch (workInProgress.tag) {\n          case FunctionalComponent:\n            return null;\n          case ClassComponent:\n            {\n              // We are leaving this subtree, so pop context if any.\n              popContextProvider(workInProgress);\n              return null;\n            }\n          case HostRoot:\n            {\n              popHostContainer(workInProgress);\n              popTopLevelContextObject(workInProgress);\n              var fiberRoot = workInProgress.stateNode;\n              if (fiberRoot.pendingContext) {\n                fiberRoot.context = fiberRoot.pendingContext;\n                fiberRoot.pendingContext = null;\n              }\n              if (current === null || current.child === null) {\n                // If we hydrated, pop so that we can delete any remaining children\n                // that weren't hydrated.\n                popHydrationState(workInProgress);\n                // This resets the hacky state to fix isMounted before committing.\n                // TODO: Delete this when we delete isMounted and findDOMNode.\n                workInProgress.effectTag &= ~Placement;\n              }\n              updateHostContainer(workInProgress);\n              return null;\n            }\n          case HostComponent:\n            {\n              popHostContext(workInProgress);\n              var rootContainerInstance = getRootHostContainer();\n              var type = workInProgress.type;\n              if (current !== null && workInProgress.stateNode != null) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps;\n                // If we get updated because one of our children updated, we don't\n                // have newProps so we'll have to reuse them.\n                // TODO: Split the update API as separate for the props vs. children.\n                // Even better would be if children weren't special cased at all tho.\n                var instance = workInProgress.stateNode;\n                var currentHostContext = getHostContext();\n                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n                updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);\n                if (current.ref !== workInProgress.ref) {\n                  markRef(workInProgress);\n                }\n              } else {\n                if (!newProps) {\n                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n                  // This can happen when we abort work.\n                  return null;\n                }\n                var _currentHostContext = getHostContext();\n                // TODO: Move createInstance to beginWork and keep it on a context\n                // \"stack\" as the parent. Then append children as we go in beginWork\n                // or completeWork depending on we want to add then top->down or\n                // bottom->up. Top->down is faster in IE11.\n                var wasHydrated = popHydrationState(workInProgress);\n                if (wasHydrated) {\n                  // TODO: Move this and createInstance step into the beginPhase\n                  // to consolidate.\n                  if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                    // If changes to the hydrated node needs to be applied at the\n                    // commit-phase we mark this as such.\n                    markUpdate(workInProgress);\n                  }\n                } else {\n                  var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n                  appendAllChildren(_instance, workInProgress);\n\n                  // Certain renderers require commit-time effects for initial mount.\n                  // (eg DOM renderer supports auto-focus for certain elements).\n                  // Make sure such renderers get scheduled for later work.\n                  if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                    markUpdate(workInProgress);\n                  }\n                  workInProgress.stateNode = _instance;\n                }\n                if (workInProgress.ref !== null) {\n                  // If there is a ref on a host node we need to schedule a callback\n                  markRef(workInProgress);\n                }\n              }\n              return null;\n            }\n          case HostText:\n            {\n              var newText = newProps;\n              if (current && workInProgress.stateNode != null) {\n                var oldText = current.memoizedProps;\n                // If we have an alternate, that means this is an update and we need\n                // to schedule a side-effect to do the updates.\n                updateHostText(current, workInProgress, oldText, newText);\n              } else {\n                if (typeof newText !== 'string') {\n                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n                  // This can happen when we abort work.\n                  return null;\n                }\n                var _rootContainerInstance = getRootHostContainer();\n                var _currentHostContext2 = getHostContext();\n                var _wasHydrated = popHydrationState(workInProgress);\n                if (_wasHydrated) {\n                  if (prepareToHydrateHostTextInstance(workInProgress)) {\n                    markUpdate(workInProgress);\n                  }\n                } else {\n                  workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n                }\n              }\n              return null;\n            }\n          case CallComponent:\n            return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n          case CallHandlerPhase:\n            // Reset the tag to now be a first phase call.\n            workInProgress.tag = CallComponent;\n            return null;\n          case ReturnComponent:\n            // Does nothing.\n            return null;\n          case Fragment:\n            return null;\n          case HostPortal:\n            popHostContainer(workInProgress);\n            updateHostContainer(workInProgress);\n            return null;\n          // Error cases\n          case IndeterminateComponent:\n            invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n          // eslint-disable-next-line no-fallthrough\n          default:\n            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n      return {\n        completeWork: completeWork\n      };\n    };\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var onCommitFiberRoot = null;\n    var onCommitFiberUnmount = null;\n    function onCommitRoot(root) {\n      if (typeof onCommitFiberRoot === 'function') {\n        onCommitFiberRoot(root);\n      }\n    }\n    function onCommitUnmount(fiber) {\n      if (typeof onCommitFiberUnmount === 'function') {\n        onCommitFiberUnmount(fiber);\n      }\n    }\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\n    var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\n    var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n    var startPhaseTimer$2 = ReactDebugFiberPerf$1.startPhaseTimer;\n    var stopPhaseTimer$2 = ReactDebugFiberPerf$1.stopPhaseTimer;\n    var ReactFiberCommitWork = function (config, captureError) {\n      var getPublicInstance = config.getPublicInstance,\n        mutation = config.mutation,\n        persistence = config.persistence;\n      {\n        var callComponentWillUnmountWithTimerInDev = function (current, instance) {\n          startPhaseTimer$2(current, 'componentWillUnmount');\n          instance.props = current.memoizedProps;\n          instance.state = current.memoizedState;\n          instance.componentWillUnmount();\n          stopPhaseTimer$2();\n        };\n      }\n\n      // Capture errors so they don't interrupt unmounting.\n      function safelyCallComponentWillUnmount(current, instance) {\n        {\n          invokeGuardedCallback$2(null, callComponentWillUnmountWithTimerInDev, null, current, instance);\n          if (hasCaughtError$1()) {\n            var unmountError = clearCaughtError$1();\n            captureError(current, unmountError);\n          }\n        }\n      }\n      function safelyDetachRef(current) {\n        var ref = current.ref;\n        if (ref !== null) {\n          {\n            invokeGuardedCallback$2(null, ref, null, null);\n            if (hasCaughtError$1()) {\n              var refError = clearCaughtError$1();\n              captureError(current, refError);\n            }\n          }\n        }\n      }\n      function commitLifeCycles(current, finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              var instance = finishedWork.stateNode;\n              if (finishedWork.effectTag & Update) {\n                if (current === null) {\n                  {\n                    startPhaseTimer$2(finishedWork, 'componentDidMount');\n                  }\n                  instance.props = finishedWork.memoizedProps;\n                  instance.state = finishedWork.memoizedState;\n                  instance.componentDidMount();\n                  {\n                    stopPhaseTimer$2();\n                  }\n                } else {\n                  var prevProps = current.memoizedProps;\n                  var prevState = current.memoizedState;\n                  {\n                    startPhaseTimer$2(finishedWork, 'componentDidUpdate');\n                  }\n                  instance.props = finishedWork.memoizedProps;\n                  instance.state = finishedWork.memoizedState;\n                  instance.componentDidUpdate(prevProps, prevState);\n                  {\n                    stopPhaseTimer$2();\n                  }\n                }\n              }\n              var updateQueue = finishedWork.updateQueue;\n              if (updateQueue !== null) {\n                commitCallbacks(updateQueue, instance);\n              }\n              return;\n            }\n          case HostRoot:\n            {\n              var _updateQueue = finishedWork.updateQueue;\n              if (_updateQueue !== null) {\n                var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;\n                commitCallbacks(_updateQueue, _instance);\n              }\n              return;\n            }\n          case HostComponent:\n            {\n              var _instance2 = finishedWork.stateNode;\n\n              // Renderers may schedule work to be done after host components are mounted\n              // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n              // These effects should only be committed when components are first mounted,\n              // aka when there is no current/alternate.\n              if (current === null && finishedWork.effectTag & Update) {\n                var type = finishedWork.type;\n                var props = finishedWork.memoizedProps;\n                commitMount(_instance2, type, props, finishedWork);\n              }\n              return;\n            }\n          case HostText:\n            {\n              // We have no life-cycles associated with text.\n              return;\n            }\n          case HostPortal:\n            {\n              // We have no life-cycles associated with portals.\n              return;\n            }\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      }\n      function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n        if (ref !== null) {\n          var instance = finishedWork.stateNode;\n          switch (finishedWork.tag) {\n            case HostComponent:\n              ref(getPublicInstance(instance));\n              break;\n            default:\n              ref(instance);\n          }\n        }\n      }\n      function commitDetachRef(current) {\n        var currentRef = current.ref;\n        if (currentRef !== null) {\n          currentRef(null);\n        }\n      }\n\n      // User-originating errors (lifecycles and refs) should not interrupt\n      // deletion, so don't let them throw. Host-originating errors should\n      // interrupt deletion, so it's okay\n      function commitUnmount(current) {\n        if (typeof onCommitUnmount === 'function') {\n          onCommitUnmount(current);\n        }\n        switch (current.tag) {\n          case ClassComponent:\n            {\n              safelyDetachRef(current);\n              var instance = current.stateNode;\n              if (typeof instance.componentWillUnmount === 'function') {\n                safelyCallComponentWillUnmount(current, instance);\n              }\n              return;\n            }\n          case HostComponent:\n            {\n              safelyDetachRef(current);\n              return;\n            }\n          case CallComponent:\n            {\n              commitNestedUnmounts(current.stateNode);\n              return;\n            }\n          case HostPortal:\n            {\n              // TODO: this is recursive.\n              // We are also not using this parent because\n              // the portal will get pushed immediately.\n              if (ReactFeatureFlags.enableMutatingReconciler && mutation) {\n                unmountHostComponents(current);\n              } else if (ReactFeatureFlags.enablePersistentReconciler && persistence) {\n                emptyPortalContainer(current);\n              }\n              return;\n            }\n        }\n      }\n      function commitNestedUnmounts(root) {\n        // While we're inside a removed host node we don't want to call\n        // removeChild on the inner nodes because they're removed by the top\n        // call anyway. We also want to call componentWillUnmount on all\n        // composites before this host node is removed from the tree. Therefore\n        var node = root;\n        while (true) {\n          commitUnmount(node);\n          // Visit children because they may contain more composite or host nodes.\n          // Skip portals because commitUnmount() currently visits them recursively.\n          if (node.child !== null && (\n          // If we use mutation we drill down into portals using commitUnmount above.\n          // If we don't use mutation we drill down into portals here instead.\n          !mutation || node.tag !== HostPortal)) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === root) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === root) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n      function detachFiber(current) {\n        // Cut off the return pointers to disconnect it from the tree. Ideally, we\n        // should clear the child pointer of the parent alternate to let this\n        // get GC:ed but we don't know which for sure which parent is the current\n        // one so we'll settle for GC:ing the subtree of this child. This child\n        // itself will be GC:ed when the parent updates the next time.\n        current['return'] = null;\n        current.child = null;\n        if (current.alternate) {\n          current.alternate.child = null;\n          current.alternate['return'] = null;\n        }\n      }\n      if (!mutation) {\n        var commitContainer = void 0;\n        if (persistence) {\n          var replaceContainerChildren = persistence.replaceContainerChildren,\n            createContainerChildSet = persistence.createContainerChildSet;\n          var emptyPortalContainer = function (current) {\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet(containerInfo);\n            replaceContainerChildren(containerInfo, emptyChildSet);\n          };\n          commitContainer = function (finishedWork) {\n            switch (finishedWork.tag) {\n              case ClassComponent:\n                {\n                  return;\n                }\n              case HostComponent:\n                {\n                  return;\n                }\n              case HostText:\n                {\n                  return;\n                }\n              case HostRoot:\n              case HostPortal:\n                {\n                  var portalOrRoot = finishedWork.stateNode;\n                  var containerInfo = portalOrRoot.containerInfo,\n                    _pendingChildren = portalOrRoot.pendingChildren;\n                  replaceContainerChildren(containerInfo, _pendingChildren);\n                  return;\n                }\n              default:\n                {\n                  invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n                }\n            }\n          };\n        } else {\n          commitContainer = function (finishedWork) {\n            // Noop\n          };\n        }\n        if (ReactFeatureFlags.enablePersistentReconciler || ReactFeatureFlags.enableNoopReconciler) {\n          return {\n            commitResetTextContent: function (finishedWork) {},\n            commitPlacement: function (finishedWork) {},\n            commitDeletion: function (current) {\n              // Detach refs and call componentWillUnmount() on the whole subtree.\n              commitNestedUnmounts(current);\n              detachFiber(current);\n            },\n            commitWork: function (current, finishedWork) {\n              commitContainer(finishedWork);\n            },\n            commitLifeCycles: commitLifeCycles,\n            commitAttachRef: commitAttachRef,\n            commitDetachRef: commitDetachRef\n          };\n        } else if (persistence) {\n          invariant(false, 'Persistent reconciler is disabled.');\n        } else {\n          invariant(false, 'Noop reconciler is disabled.');\n        }\n      }\n      var commitMount = mutation.commitMount,\n        commitUpdate = mutation.commitUpdate,\n        resetTextContent = mutation.resetTextContent,\n        commitTextUpdate = mutation.commitTextUpdate,\n        appendChild = mutation.appendChild,\n        appendChildToContainer = mutation.appendChildToContainer,\n        insertBefore = mutation.insertBefore,\n        insertInContainerBefore = mutation.insertInContainerBefore,\n        removeChild = mutation.removeChild,\n        removeChildFromContainer = mutation.removeChildFromContainer;\n      function getHostParentFiber(fiber) {\n        var parent = fiber['return'];\n        while (parent !== null) {\n          if (isHostParent(parent)) {\n            return parent;\n          }\n          parent = parent['return'];\n        }\n        invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n      }\n      function isHostParent(fiber) {\n        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n      }\n      function getHostSibling(fiber) {\n        // We're going to search forward into the tree until we find a sibling host\n        // node. Unfortunately, if multiple insertions are done in a row we have to\n        // search past them. This leads to exponential search for the next sibling.\n        var node = fiber;\n        siblings: while (true) {\n          // If we didn't find anything, let's try the next sibling.\n          while (node.sibling === null) {\n            if (node['return'] === null || isHostParent(node['return'])) {\n              // If we pop out of the root or hit the parent the fiber we are the\n              // last sibling.\n              return null;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n          while (node.tag !== HostComponent && node.tag !== HostText) {\n            // If it is not host node and, we might have a host node inside it.\n            // Try to search down until we find one.\n            if (node.effectTag & Placement) {\n              // If we don't have a child, try the siblings instead.\n              continue siblings;\n            }\n            // If we don't have a child, try the siblings instead.\n            // We also skip portals because they are not part of this host tree.\n            if (node.child === null || node.tag === HostPortal) {\n              continue siblings;\n            } else {\n              node.child['return'] = node;\n              node = node.child;\n            }\n          }\n          // Check if this host node is stable or about to be placed.\n          if (!(node.effectTag & Placement)) {\n            // Found it!\n            return node.stateNode;\n          }\n        }\n      }\n      function commitPlacement(finishedWork) {\n        // Recursively insert all host nodes into the parent.\n        var parentFiber = getHostParentFiber(finishedWork);\n        var parent = void 0;\n        var isContainer = void 0;\n        switch (parentFiber.tag) {\n          case HostComponent:\n            parent = parentFiber.stateNode;\n            isContainer = false;\n            break;\n          case HostRoot:\n            parent = parentFiber.stateNode.containerInfo;\n            isContainer = true;\n            break;\n          case HostPortal:\n            parent = parentFiber.stateNode.containerInfo;\n            isContainer = true;\n            break;\n          default:\n            invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n        }\n        if (parentFiber.effectTag & ContentReset) {\n          // Reset the text content of the parent before doing any insertions\n          resetTextContent(parent);\n          // Clear ContentReset from the effect tag\n          parentFiber.effectTag &= ~ContentReset;\n        }\n        var before = getHostSibling(finishedWork);\n        // We only have the top Fiber that was inserted but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = finishedWork;\n        while (true) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            if (before) {\n              if (isContainer) {\n                insertInContainerBefore(parent, node.stateNode, before);\n              } else {\n                insertBefore(parent, node.stateNode, before);\n              }\n            } else {\n              if (isContainer) {\n                appendChildToContainer(parent, node.stateNode);\n              } else {\n                appendChild(parent, node.stateNode);\n              }\n            }\n          } else if (node.tag === HostPortal) {\n            // If the insertion itself is a portal, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === finishedWork) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === finishedWork) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n      function unmountHostComponents(current) {\n        // We only have the top Fiber that was inserted but we need recurse down its\n        var node = current;\n\n        // Each iteration, currentParent is populated with node's host parent if not\n        // currentParentIsValid.\n        var currentParentIsValid = false;\n        var currentParent = void 0;\n        var currentParentIsContainer = void 0;\n        while (true) {\n          if (!currentParentIsValid) {\n            var parent = node['return'];\n            findParent: while (true) {\n              !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              switch (parent.tag) {\n                case HostComponent:\n                  currentParent = parent.stateNode;\n                  currentParentIsContainer = false;\n                  break findParent;\n                case HostRoot:\n                  currentParent = parent.stateNode.containerInfo;\n                  currentParentIsContainer = true;\n                  break findParent;\n                case HostPortal:\n                  currentParent = parent.stateNode.containerInfo;\n                  currentParentIsContainer = true;\n                  break findParent;\n              }\n              parent = parent['return'];\n            }\n            currentParentIsValid = true;\n          }\n          if (node.tag === HostComponent || node.tag === HostText) {\n            commitNestedUnmounts(node);\n            // After all the children have unmounted, it is now safe to remove the\n            // node from the tree.\n            if (currentParentIsContainer) {\n              removeChildFromContainer(currentParent, node.stateNode);\n            } else {\n              removeChild(currentParent, node.stateNode);\n            }\n            // Don't visit children because we already visited them.\n          } else if (node.tag === HostPortal) {\n            // When we go into a portal, it becomes the parent to remove from.\n            // We will reassign it back when we pop the portal on the way up.\n            currentParent = node.stateNode.containerInfo;\n            // Visit children because portals might contain host components.\n            if (node.child !== null) {\n              node.child['return'] = node;\n              node = node.child;\n              continue;\n            }\n          } else {\n            commitUnmount(node);\n            // Visit children because we may find more host components below.\n            if (node.child !== null) {\n              node.child['return'] = node;\n              node = node.child;\n              continue;\n            }\n          }\n          if (node === current) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === current) {\n              return;\n            }\n            node = node['return'];\n            if (node.tag === HostPortal) {\n              // When we go out of the portal, we need to restore the parent.\n              // Since we don't keep a stack of them, we will search for it.\n              currentParentIsValid = false;\n            }\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n      function commitDeletion(current) {\n        // Recursively delete all host nodes from the parent.\n        // Detach refs and call componentWillUnmount() on the whole subtree.\n        unmountHostComponents(current);\n        detachFiber(current);\n      }\n      function commitWork(current, finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n          case HostComponent:\n            {\n              var instance = finishedWork.stateNode;\n              if (instance != null) {\n                // Commit the work prepared earlier.\n                var newProps = finishedWork.memoizedProps;\n                // For hydration we reuse the update path but we treat the oldProps\n                // as the newProps. The updatePayload will contain the real change in\n                // this case.\n                var oldProps = current !== null ? current.memoizedProps : newProps;\n                var type = finishedWork.type;\n                // TODO: Type the updateQueue to be specific to host components.\n                var updatePayload = finishedWork.updateQueue;\n                finishedWork.updateQueue = null;\n                if (updatePayload !== null) {\n                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n                }\n              }\n              return;\n            }\n          case HostText:\n            {\n              !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              var textInstance = finishedWork.stateNode;\n              var newText = finishedWork.memoizedProps;\n              // For hydration we reuse the update path but we treat the oldProps\n              // as the newProps. The updatePayload will contain the real change in\n              // this case.\n              var oldText = current !== null ? current.memoizedProps : newText;\n              commitTextUpdate(textInstance, oldText, newText);\n              return;\n            }\n          case HostRoot:\n            {\n              return;\n            }\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      }\n      function commitResetTextContent(current) {\n        resetTextContent(current.stateNode);\n      }\n      if (ReactFeatureFlags.enableMutatingReconciler) {\n        return {\n          commitResetTextContent: commitResetTextContent,\n          commitPlacement: commitPlacement,\n          commitDeletion: commitDeletion,\n          commitWork: commitWork,\n          commitLifeCycles: commitLifeCycles,\n          commitAttachRef: commitAttachRef,\n          commitDetachRef: commitDetachRef\n        };\n      } else {\n        invariant(false, 'Mutating reconciler is disabled.');\n      }\n    };\n    var NO_CONTEXT = {};\n    var ReactFiberHostContext = function (config) {\n      var getChildHostContext = config.getChildHostContext,\n        getRootHostContext = config.getRootHostContext;\n      var contextStackCursor = createCursor(NO_CONTEXT);\n      var contextFiberStackCursor = createCursor(NO_CONTEXT);\n      var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n      function requiredContext(c) {\n        !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        return c;\n      }\n      function getRootHostContainer() {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        return rootInstance;\n      }\n      function pushHostContainer(fiber, nextRootInstance) {\n        // Push current root instance onto the stack;\n        // This allows us to reset root when portals are popped.\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        var nextRootContext = getRootHostContext(nextRootInstance);\n\n        // Track the context and the Fiber that provided it.\n        // This enables us to pop only Fibers that provide unique contexts.\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, nextRootContext, fiber);\n      }\n      function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n      }\n      function getHostContext() {\n        var context = requiredContext(contextStackCursor.current);\n        return context;\n      }\n      function pushHostContext(fiber) {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        var context = requiredContext(contextStackCursor.current);\n        var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n        // Don't push this Fiber's context unless it's unique.\n        if (context === nextContext) {\n          return;\n        }\n\n        // Track the context and the Fiber that provided it.\n        // This enables us to pop only Fibers that provide unique contexts.\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, nextContext, fiber);\n      }\n      function popHostContext(fiber) {\n        // Do not pop unless this Fiber provided the current context.\n        // pushHostContext() only pushes Fibers that provide unique contexts.\n        if (contextFiberStackCursor.current !== fiber) {\n          return;\n        }\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n      }\n      function resetHostContainer() {\n        contextStackCursor.current = NO_CONTEXT;\n        rootInstanceStackCursor.current = NO_CONTEXT;\n      }\n      return {\n        getHostContext: getHostContext,\n        getRootHostContainer: getRootHostContainer,\n        popHostContainer: popHostContainer,\n        popHostContext: popHostContext,\n        pushHostContainer: pushHostContainer,\n        pushHostContext: pushHostContext,\n        resetHostContainer: resetHostContainer\n      };\n    };\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var ReactFiberHydrationContext = function (config) {\n      var shouldSetTextContent = config.shouldSetTextContent,\n        hydration = config.hydration;\n\n      // If this doesn't have hydration mode.\n\n      if (!hydration) {\n        return {\n          enterHydrationState: function () {\n            return false;\n          },\n          resetHydrationState: function () {},\n          tryToClaimNextHydratableInstance: function () {},\n          prepareToHydrateHostInstance: function () {\n            invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n          },\n          prepareToHydrateHostTextInstance: function () {\n            invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n          },\n          popHydrationState: function (fiber) {\n            return false;\n          }\n        };\n      }\n      var canHydrateInstance = hydration.canHydrateInstance,\n        canHydrateTextInstance = hydration.canHydrateTextInstance,\n        getNextHydratableSibling = hydration.getNextHydratableSibling,\n        getFirstHydratableChild = hydration.getFirstHydratableChild,\n        hydrateInstance = hydration.hydrateInstance,\n        hydrateTextInstance = hydration.hydrateTextInstance,\n        didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n        didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n        didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n        didNotHydrateInstance = hydration.didNotHydrateInstance,\n        didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n        didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n        didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n        didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;\n\n      // The deepest Fiber on the stack involved in a hydration context.\n      // This may have been an insertion or a hydration.\n\n      var hydrationParentFiber = null;\n      var nextHydratableInstance = null;\n      var isHydrating = false;\n      function enterHydrationState(fiber) {\n        var parentInstance = fiber.stateNode.containerInfo;\n        nextHydratableInstance = getFirstHydratableChild(parentInstance);\n        hydrationParentFiber = fiber;\n        isHydrating = true;\n        return true;\n      }\n      function deleteHydratableInstance(returnFiber, instance) {\n        {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n              break;\n            case HostComponent:\n              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n              break;\n          }\n        }\n        var childToDelete = createFiberFromHostInstanceForDeletion();\n        childToDelete.stateNode = instance;\n        childToDelete['return'] = returnFiber;\n        childToDelete.effectTag = Deletion;\n\n        // This might seem like it belongs on progressedFirstDeletion. However,\n        // these children are not part of the reconciliation list of children.\n        // Even if we abort and rereconcile the children, that will try to hydrate\n        // again and the nodes are still in the host tree so these will be\n        // recreated.\n        if (returnFiber.lastEffect !== null) {\n          returnFiber.lastEffect.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n      }\n      function insertNonHydratedInstance(returnFiber, fiber) {\n        fiber.effectTag |= Placement;\n        {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var type = fiber.type;\n                    var props = fiber.pendingProps;\n                    didNotFindHydratableContainerInstance(parentContainer, type, props);\n                    break;\n                  case HostText:\n                    var text = fiber.pendingProps;\n                    didNotFindHydratableContainerTextInstance(parentContainer, text);\n                    break;\n                }\n                break;\n              }\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var _type = fiber.type;\n                    var _props = fiber.pendingProps;\n                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                    break;\n                  case HostText:\n                    var _text = fiber.pendingProps;\n                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                    break;\n                }\n                break;\n              }\n            default:\n              return;\n          }\n        }\n      }\n      function canHydrate(fiber, nextInstance) {\n        switch (fiber.tag) {\n          case HostComponent:\n            {\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              return canHydrateInstance(nextInstance, type, props);\n            }\n          case HostText:\n            {\n              var text = fiber.pendingProps;\n              return canHydrateTextInstance(nextInstance, text);\n            }\n          default:\n            return false;\n        }\n      }\n      function tryToClaimNextHydratableInstance(fiber) {\n        if (!isHydrating) {\n          return;\n        }\n        var nextInstance = nextHydratableInstance;\n        if (!nextInstance) {\n          // Nothing to hydrate. Make it an insertion.\n          insertNonHydratedInstance(hydrationParentFiber, fiber);\n          isHydrating = false;\n          hydrationParentFiber = fiber;\n          return;\n        }\n        if (!canHydrate(fiber, nextInstance)) {\n          // If we can't hydrate this instance let's try the next one.\n          // We use this as a heuristic. It's based on intuition and not data so it\n          // might be flawed or unnecessary.\n          nextInstance = getNextHydratableSibling(nextInstance);\n          if (!nextInstance || !canHydrate(fiber, nextInstance)) {\n            // Nothing to hydrate. Make it an insertion.\n            insertNonHydratedInstance(hydrationParentFiber, fiber);\n            isHydrating = false;\n            hydrationParentFiber = fiber;\n            return;\n          }\n          // We matched the next one, we'll now assume that the first one was\n          // superfluous and we'll delete it. Since we can't eagerly delete it\n          // we'll have to schedule a deletion. To do that, this node needs a dummy\n          // fiber associated with it.\n          deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n        }\n        fiber.stateNode = nextInstance;\n        hydrationParentFiber = fiber;\n        nextHydratableInstance = getFirstHydratableChild(nextInstance);\n      }\n      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n        var instance = fiber.stateNode;\n        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n        // TODO: Type this specific to this type of component.\n        fiber.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update.\n        if (updatePayload !== null) {\n          return true;\n        }\n        return false;\n      }\n      function prepareToHydrateHostTextInstance(fiber) {\n        var textInstance = fiber.stateNode;\n        var textContent = fiber.memoizedProps;\n        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n        {\n          if (shouldUpdate) {\n            // We assume that prepareToHydrateHostTextInstance is called in a context where the\n            // hydration parent is the parent host component of this host text.\n            var returnFiber = hydrationParentFiber;\n            if (returnFiber !== null) {\n              switch (returnFiber.tag) {\n                case HostRoot:\n                  {\n                    var parentContainer = returnFiber.stateNode.containerInfo;\n                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                    break;\n                  }\n                case HostComponent:\n                  {\n                    var parentType = returnFiber.type;\n                    var parentProps = returnFiber.memoizedProps;\n                    var parentInstance = returnFiber.stateNode;\n                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                    break;\n                  }\n              }\n            }\n          }\n        }\n        return shouldUpdate;\n      }\n      function popToNextHostParent(fiber) {\n        var parent = fiber['return'];\n        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n          parent = parent['return'];\n        }\n        hydrationParentFiber = parent;\n      }\n      function popHydrationState(fiber) {\n        if (fiber !== hydrationParentFiber) {\n          // We're deeper than the current hydration context, inside an inserted\n          // tree.\n          return false;\n        }\n        if (!isHydrating) {\n          // If we're not currently hydrating but we're in a hydration context, then\n          // we were an insertion and now need to pop up reenter hydration of our\n          // siblings.\n          popToNextHostParent(fiber);\n          isHydrating = true;\n          return false;\n        }\n        var type = fiber.type;\n\n        // If we have any remaining hydratable nodes, we need to delete them now.\n        // We only do this deeper than head and body since they tend to have random\n        // other nodes in them. We also ignore components with pure text content in\n        // side of them.\n        // TODO: Better heuristic.\n        if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n          var nextInstance = nextHydratableInstance;\n          while (nextInstance) {\n            deleteHydratableInstance(fiber, nextInstance);\n            nextInstance = getNextHydratableSibling(nextInstance);\n          }\n        }\n        popToNextHostParent(fiber);\n        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return true;\n      }\n      function resetHydrationState() {\n        hydrationParentFiber = null;\n        nextHydratableInstance = null;\n        isHydrating = false;\n      }\n      return {\n        enterHydrationState: enterHydrationState,\n        resetHydrationState: resetHydrationState,\n        tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n        prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n        prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n        popHydrationState: popHydrationState\n      };\n    };\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    // This lets us hook into Fiber to debug what it's doing.\n    // See https://github.com/facebook/react/pull/8033.\n    // This is not part of the public API, not even for React DevTools.\n    // You may only inject a debugTool if you work on React Fiber itself.\n    var ReactFiberInstrumentation = {\n      debugTool: null\n    };\n    var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n    var defaultShowDialog = function (capturedError) {\n      return true;\n    };\n    var showDialog = defaultShowDialog;\n    function logCapturedError(capturedError) {\n      var logError = showDialog(capturedError);\n\n      // Allow injected showDialog() to prevent default console.error logging.\n      // This enables renderers like ReactNative to better manage redbox behavior.\n      if (logError === false) {\n        return;\n      }\n      {\n        var componentName = capturedError.componentName,\n          componentStack = capturedError.componentStack,\n          errorBoundaryName = capturedError.errorBoundaryName,\n          errorBoundaryFound = capturedError.errorBoundaryFound,\n          willRetry = capturedError.willRetry;\n        var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n        var errorBoundaryMessage = void 0;\n        // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n        if (errorBoundaryFound && errorBoundaryName) {\n          if (willRetry) {\n            errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n          } else {\n            errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n          }\n        } else {\n          errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n        }\n        var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n        // In development, we provide our own message with just the component stack.\n        // We don't include the original error message and JS stack because the browser\n        // has already printed it. Even if the application swallows the error, it is still\n        // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n        console.error(combinedMessage);\n      }\n    }\n    var invokeGuardedCallback = ReactErrorUtils.invokeGuardedCallback;\n    var hasCaughtError = ReactErrorUtils.hasCaughtError;\n    var clearCaughtError = ReactErrorUtils.clearCaughtError;\n    var recordEffect = ReactDebugFiberPerf$1.recordEffect;\n    var recordScheduleUpdate = ReactDebugFiberPerf$1.recordScheduleUpdate;\n    var startWorkTimer = ReactDebugFiberPerf$1.startWorkTimer;\n    var stopWorkTimer = ReactDebugFiberPerf$1.stopWorkTimer;\n    var stopFailedWorkTimer = ReactDebugFiberPerf$1.stopFailedWorkTimer;\n    var startWorkLoopTimer = ReactDebugFiberPerf$1.startWorkLoopTimer;\n    var stopWorkLoopTimer = ReactDebugFiberPerf$1.stopWorkLoopTimer;\n    var startCommitTimer = ReactDebugFiberPerf$1.startCommitTimer;\n    var stopCommitTimer = ReactDebugFiberPerf$1.stopCommitTimer;\n    var startCommitHostEffectsTimer = ReactDebugFiberPerf$1.startCommitHostEffectsTimer;\n    var stopCommitHostEffectsTimer = ReactDebugFiberPerf$1.stopCommitHostEffectsTimer;\n    var startCommitLifeCyclesTimer = ReactDebugFiberPerf$1.startCommitLifeCyclesTimer;\n    var stopCommitLifeCyclesTimer = ReactDebugFiberPerf$1.stopCommitLifeCyclesTimer;\n    {\n      var didWarnAboutStateTransition = false;\n      var didWarnSetStateChildContext = false;\n      var didWarnStateUpdateForUnmountedComponent = {};\n      var warnAboutUpdateOnUnmounted = function (fiber) {\n        var componentName = getComponentName(fiber) || 'ReactClass';\n        if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n          return;\n        }\n        warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease ' + 'check the code for the %s component.', componentName);\n        didWarnStateUpdateForUnmountedComponent[componentName] = true;\n      };\n      var warnAboutInvalidUpdates = function (instance) {\n        switch (ReactDebugCurrentFiber.phase) {\n          case 'getChildContext':\n            if (didWarnSetStateChildContext) {\n              return;\n            }\n            warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n            didWarnSetStateChildContext = true;\n            break;\n          case 'render':\n            if (didWarnAboutStateTransition) {\n              return;\n            }\n            warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n            didWarnAboutStateTransition = true;\n            break;\n        }\n      };\n    }\n    var ReactFiberScheduler = function (config) {\n      var hostContext = ReactFiberHostContext(config);\n      var hydrationContext = ReactFiberHydrationContext(config);\n      var popHostContainer = hostContext.popHostContainer,\n        popHostContext = hostContext.popHostContext,\n        resetHostContainer = hostContext.resetHostContainer;\n      var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n        beginWork = _ReactFiberBeginWork.beginWork,\n        beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n      var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n        completeWork = _ReactFiberCompleteWo.completeWork;\n      var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n        commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n        commitPlacement = _ReactFiberCommitWork.commitPlacement,\n        commitDeletion = _ReactFiberCommitWork.commitDeletion,\n        commitWork = _ReactFiberCommitWork.commitWork,\n        commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n        commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n        commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n      var now = config.now,\n        scheduleDeferredCallback = config.scheduleDeferredCallback,\n        useSyncScheduling = config.useSyncScheduling,\n        prepareForCommit = config.prepareForCommit,\n        resetAfterCommit = config.resetAfterCommit;\n\n      // Represents the current time in ms.\n\n      var startTime = now();\n      var mostRecentCurrentTime = msToExpirationTime(0);\n\n      // Represents the expiration time that incoming updates should use. (If this\n      // is NoWork, use the default strategy: async updates in async mode, sync\n      // updates in sync mode.)\n      var expirationContext = NoWork;\n      var isWorking = false;\n\n      // The next work in progress fiber that we're currently working on.\n      var nextUnitOfWork = null;\n      var nextRoot = null;\n      // The time at which we're currently rendering work.\n      var nextRenderExpirationTime = NoWork;\n\n      // The next fiber with an effect that we're currently committing.\n      var nextEffect = null;\n\n      // Keep track of which fibers have captured an error that need to be handled.\n      // Work is removed from this collection after componentDidCatch is called.\n      var capturedErrors = null;\n      // Keep track of which fibers have failed during the current batch of work.\n      // This is a different set than capturedErrors, because it is not reset until\n      // the end of the batch. This is needed to propagate errors correctly if a\n      // subtree fails more than once.\n      var failedBoundaries = null;\n      // Error boundaries that captured an error during the current commit.\n      var commitPhaseBoundaries = null;\n      var firstUncaughtError = null;\n      var didFatal = false;\n      var isCommitting = false;\n      var isUnmounting = false;\n      function resetContextStack() {\n        // Reset the stack\n        reset();\n        // Reset the cursors\n        resetContext();\n        resetHostContainer();\n      }\n      function commitAllHostEffects() {\n        while (nextEffect !== null) {\n          {\n            ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n            recordEffect();\n          }\n          var effectTag = nextEffect.effectTag;\n          if (effectTag & ContentReset) {\n            commitResetTextContent(nextEffect);\n          }\n          if (effectTag & Ref) {\n            var current = nextEffect.alternate;\n            if (current !== null) {\n              commitDetachRef(current);\n            }\n          }\n\n          // The following switch statement is only concerned about placement,\n          // updates, and deletions. To avoid needing to add a case for every\n          // possible bitmap value, we remove the secondary effects from the\n          // effect tag and switch on that value.\n          var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n          switch (primaryEffectTag) {\n            case Placement:\n              {\n                commitPlacement(nextEffect);\n                // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n                // any life-cycles like componentDidMount gets called.\n                // TODO: findDOMNode doesn't rely on this any more but isMounted\n                // does and isMounted is deprecated anyway so we should be able\n                // to kill this.\n                nextEffect.effectTag &= ~Placement;\n                break;\n              }\n            case PlacementAndUpdate:\n              {\n                // Placement\n                commitPlacement(nextEffect);\n                // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n                // any life-cycles like componentDidMount gets called.\n                nextEffect.effectTag &= ~Placement;\n\n                // Update\n                var _current = nextEffect.alternate;\n                commitWork(_current, nextEffect);\n                break;\n              }\n            case Update:\n              {\n                var _current2 = nextEffect.alternate;\n                commitWork(_current2, nextEffect);\n                break;\n              }\n            case Deletion:\n              {\n                isUnmounting = true;\n                commitDeletion(nextEffect);\n                isUnmounting = false;\n                break;\n              }\n          }\n          nextEffect = nextEffect.nextEffect;\n        }\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n      }\n      function commitAllLifeCycles() {\n        while (nextEffect !== null) {\n          var effectTag = nextEffect.effectTag;\n          if (effectTag & (Update | Callback)) {\n            {\n              recordEffect();\n            }\n            var current = nextEffect.alternate;\n            commitLifeCycles(current, nextEffect);\n          }\n          if (effectTag & Ref) {\n            {\n              recordEffect();\n            }\n            commitAttachRef(nextEffect);\n          }\n          if (effectTag & Err) {\n            {\n              recordEffect();\n            }\n            commitErrorHandling(nextEffect);\n          }\n          var next = nextEffect.nextEffect;\n          // Ensure that we clean these up so that we don't accidentally keep them.\n          // I'm not actually sure this matters because we can't reset firstEffect\n          // and lastEffect since they're on every node, not just the effectful\n          // ones. So we have to clean everything as we reuse nodes anyway.\n          nextEffect.nextEffect = null;\n          // Ensure that we reset the effectTag here so that we can rely on effect\n          // tags to reason about the current life-cycle.\n          nextEffect = next;\n        }\n      }\n      function commitRoot(finishedWork) {\n        // We keep track of this so that captureError can collect any boundaries\n        // that capture an error during the commit phase. The reason these aren't\n        // local to this function is because errors that occur during cWU are\n        // captured elsewhere, to prevent the unmount from being interrupted.\n        isWorking = true;\n        isCommitting = true;\n        {\n          startCommitTimer();\n        }\n        var root = finishedWork.stateNode;\n        !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        root.isReadyForCommit = false;\n\n        // Reset this to null before calling lifecycles\n        ReactCurrentOwner.current = null;\n        var firstEffect = void 0;\n        if (finishedWork.effectTag > PerformedWork) {\n          // A fiber's effect list consists only of its children, not itself. So if\n          // the root has an effect, we need to add it to the end of the list. The\n          // resulting list is the set that would belong to the root's parent, if\n          // it had one; that is, all the effects in the tree including the root.\n          if (finishedWork.lastEffect !== null) {\n            finishedWork.lastEffect.nextEffect = finishedWork;\n            firstEffect = finishedWork.firstEffect;\n          } else {\n            firstEffect = finishedWork;\n          }\n        } else {\n          // There is no effect on the root.\n          firstEffect = finishedWork.firstEffect;\n        }\n        prepareForCommit();\n\n        // Commit all the side-effects within a tree. We'll do this in two passes.\n        // The first pass performs all the host insertions, updates, deletions and\n        // ref unmounts.\n        nextEffect = firstEffect;\n        {\n          startCommitHostEffectsTimer();\n        }\n        while (nextEffect !== null) {\n          var didError = false;\n          var _error = void 0;\n          {\n            invokeGuardedCallback(null, commitAllHostEffects, null);\n            if (hasCaughtError()) {\n              didError = true;\n              _error = clearCaughtError();\n            }\n          }\n          if (didError) {\n            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            captureError(nextEffect, _error);\n            // Clean-up\n            if (nextEffect !== null) {\n              nextEffect = nextEffect.nextEffect;\n            }\n          }\n        }\n        {\n          stopCommitHostEffectsTimer();\n        }\n        resetAfterCommit();\n\n        // The work-in-progress tree is now the current tree. This must come after\n        // the first pass of the commit phase, so that the previous tree is still\n        // current during componentWillUnmount, but before the second pass, so that\n        // the finished work is current during componentDidMount/Update.\n        root.current = finishedWork;\n\n        // In the second pass we'll perform all life-cycles and ref callbacks.\n        // Life-cycles happen as a separate pass so that all placements, updates,\n        // and deletions in the entire tree have already been invoked.\n        // This pass also triggers any renderer-specific initial effects.\n        nextEffect = firstEffect;\n        {\n          startCommitLifeCyclesTimer();\n        }\n        while (nextEffect !== null) {\n          var _didError = false;\n          var _error2 = void 0;\n          {\n            invokeGuardedCallback(null, commitAllLifeCycles, null);\n            if (hasCaughtError()) {\n              _didError = true;\n              _error2 = clearCaughtError();\n            }\n          }\n          if (_didError) {\n            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            captureError(nextEffect, _error2);\n            if (nextEffect !== null) {\n              nextEffect = nextEffect.nextEffect;\n            }\n          }\n        }\n        isCommitting = false;\n        isWorking = false;\n        {\n          stopCommitLifeCyclesTimer();\n          stopCommitTimer();\n        }\n        if (typeof onCommitRoot === 'function') {\n          onCommitRoot(finishedWork.stateNode);\n        }\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n        }\n\n        // If we caught any errors during this commit, schedule their boundaries\n        // to update.\n        if (commitPhaseBoundaries) {\n          commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n          commitPhaseBoundaries = null;\n        }\n        if (firstUncaughtError !== null) {\n          var _error3 = firstUncaughtError;\n          firstUncaughtError = null;\n          onUncaughtError(_error3);\n        }\n        var remainingTime = root.current.expirationTime;\n        if (remainingTime === NoWork) {\n          capturedErrors = null;\n          failedBoundaries = null;\n        }\n        return remainingTime;\n      }\n      function resetExpirationTime(workInProgress, renderTime) {\n        if (renderTime !== Never && workInProgress.expirationTime === Never) {\n          // The children of this component are hidden. Don't bubble their\n          // expiration times.\n          return;\n        }\n\n        // Check for pending updates.\n        var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n        // TODO: Calls need to visit stateNode\n\n        // Bubble up the earliest expiration time.\n        var child = workInProgress.child;\n        while (child !== null) {\n          if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n            newExpirationTime = child.expirationTime;\n          }\n          child = child.sibling;\n        }\n        workInProgress.expirationTime = newExpirationTime;\n      }\n      function completeUnitOfWork(workInProgress) {\n        while (true) {\n          // The current, flushed, state of this fiber is the alternate.\n          // Ideally nothing should rely on this, but relying on it here\n          // means that we don't need an additional field on the work in\n          // progress.\n          var current = workInProgress.alternate;\n          {\n            ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n          }\n          var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n          {\n            ReactDebugCurrentFiber.resetCurrentFiber();\n          }\n          var returnFiber = workInProgress['return'];\n          var siblingFiber = workInProgress.sibling;\n          resetExpirationTime(workInProgress, nextRenderExpirationTime);\n          if (next !== null) {\n            {\n              stopWorkTimer(workInProgress);\n            }\n            if (true && ReactFiberInstrumentation_1.debugTool) {\n              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n            }\n            // If completing this work spawned new work, do that next. We'll come\n            // back here again.\n            return next;\n          }\n          if (returnFiber !== null) {\n            // Append all the effects of the subtree and this fiber onto the effect\n            // list of the parent. The completion order of the children affects the\n            // side-effect order.\n            if (returnFiber.firstEffect === null) {\n              returnFiber.firstEffect = workInProgress.firstEffect;\n            }\n            if (workInProgress.lastEffect !== null) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n              }\n              returnFiber.lastEffect = workInProgress.lastEffect;\n            }\n\n            // If this fiber had side-effects, we append it AFTER the children's\n            // side-effects. We can perform certain side-effects earlier if\n            // needed, by doing multiple passes over the effect list. We don't want\n            // to schedule our own side-effect on our own list because if end up\n            // reusing children we'll schedule this effect onto itself since we're\n            // at the end.\n            var effectTag = workInProgress.effectTag;\n            // Skip both NoWork and PerformedWork tags when creating the effect list.\n            // PerformedWork effect is read by React DevTools but shouldn't be committed.\n            if (effectTag > PerformedWork) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress;\n              } else {\n                returnFiber.firstEffect = workInProgress;\n              }\n              returnFiber.lastEffect = workInProgress;\n            }\n          }\n          {\n            stopWorkTimer(workInProgress);\n          }\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n          }\n          if (siblingFiber !== null) {\n            // If there is more work to do in this returnFiber, do that next.\n            return siblingFiber;\n          } else if (returnFiber !== null) {\n            // If there's no more work in this returnFiber. Complete the returnFiber.\n            workInProgress = returnFiber;\n            continue;\n          } else {\n            // We've reached the root.\n            var root = workInProgress.stateNode;\n            root.isReadyForCommit = true;\n            return null;\n          }\n        }\n\n        // Without this explicit null return Flow complains of invalid return type\n        // TODO Remove the above while(true) loop\n        // eslint-disable-next-line no-unreachable\n        return null;\n      }\n      function performUnitOfWork(workInProgress) {\n        // The current, flushed, state of this fiber is the alternate.\n        // Ideally nothing should rely on this, but relying on it here\n        // means that we don't need an additional field on the work in\n        // progress.\n        var current = workInProgress.alternate;\n\n        // See if beginning this work spawns more work.\n        {\n          startWorkTimer(workInProgress);\n          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n        }\n        var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n        }\n        if (next === null) {\n          // If this doesn't spawn new work, complete the current work.\n          next = completeUnitOfWork(workInProgress);\n        }\n        ReactCurrentOwner.current = null;\n        return next;\n      }\n      function performFailedUnitOfWork(workInProgress) {\n        // The current, flushed, state of this fiber is the alternate.\n        // Ideally nothing should rely on this, but relying on it here\n        // means that we don't need an additional field on the work in\n        // progress.\n        var current = workInProgress.alternate;\n\n        // See if beginning this work spawns more work.\n        {\n          startWorkTimer(workInProgress);\n          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n        }\n        var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n        }\n        if (next === null) {\n          // If this doesn't spawn new work, complete the current work.\n          next = completeUnitOfWork(workInProgress);\n        }\n        ReactCurrentOwner.current = null;\n        return next;\n      }\n      function workLoop(expirationTime) {\n        if (capturedErrors !== null) {\n          // If there are unhandled errors, switch to the slow work loop.\n          // TODO: How to avoid this check in the fast path? Maybe the renderer\n          // could keep track of which roots have unhandled errors and call a\n          // forked version of renderRoot.\n          slowWorkLoopThatChecksForFailedWork(expirationTime);\n          return;\n        }\n        if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n          return;\n        }\n        if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n          // Flush all expired work.\n          while (nextUnitOfWork !== null) {\n            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n          }\n        } else {\n          // Flush asynchronous work until the deadline runs out of time.\n          while (nextUnitOfWork !== null && !shouldYield()) {\n            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n          }\n        }\n      }\n      function slowWorkLoopThatChecksForFailedWork(expirationTime) {\n        if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n          return;\n        }\n        if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n          // Flush all expired work.\n          while (nextUnitOfWork !== null) {\n            if (hasCapturedError(nextUnitOfWork)) {\n              // Use a forked version of performUnitOfWork\n              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n            } else {\n              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n            }\n          }\n        } else {\n          // Flush asynchronous work until the deadline runs out of time.\n          while (nextUnitOfWork !== null && !shouldYield()) {\n            if (hasCapturedError(nextUnitOfWork)) {\n              // Use a forked version of performUnitOfWork\n              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n            } else {\n              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n            }\n          }\n        }\n      }\n      function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {\n        // We're going to restart the error boundary that captured the error.\n        // Conceptually, we're unwinding the stack. We need to unwind the\n        // context stack, too.\n        unwindContexts(failedWork, boundary);\n\n        // Restart the error boundary using a forked version of\n        // performUnitOfWork that deletes the boundary's children. The entire\n        // failed subree will be unmounted. During the commit phase, a special\n        // lifecycle method is called on the error boundary, which triggers\n        // a re-render.\n        nextUnitOfWork = performFailedUnitOfWork(boundary);\n\n        // Continue working.\n        workLoop(expirationTime);\n      }\n      function renderRoot(root, expirationTime) {\n        {\n          startWorkLoopTimer();\n        }\n        !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        isWorking = true;\n\n        // We're about to mutate the work-in-progress tree. If the root was pending\n        // commit, it no longer is: we'll need to complete it again.\n        root.isReadyForCommit = false;\n\n        // Check if we're starting from a fresh stack, or if we're resuming from\n        // previously yielded work.\n        if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {\n          // This is a restart. Reset the stack.\n          resetContextStack();\n          nextRoot = root;\n          nextRenderExpirationTime = expirationTime;\n          nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);\n        }\n        var didError = false;\n        var error = null;\n        {\n          invokeGuardedCallback(null, workLoop, null, expirationTime);\n          if (hasCaughtError()) {\n            didError = true;\n            error = clearCaughtError();\n          }\n        }\n\n        // An error was thrown during the render phase.\n        while (didError) {\n          if (didFatal) {\n            // This was a fatal error. Don't attempt to recover from it.\n            firstUncaughtError = error;\n            break;\n          }\n          var failedWork = nextUnitOfWork;\n          if (failedWork === null) {\n            // An error was thrown but there's no current unit of work. This can\n            // happen during the commit phase if there's a bug in the renderer.\n            didFatal = true;\n            continue;\n          }\n\n          // \"Capture\" the error by finding the nearest boundary. If there is no\n          // error boundary, we use the root.\n          var boundary = captureError(failedWork, error);\n          !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          if (didFatal) {\n            // The error we just captured was a fatal error. This happens\n            // when the error propagates to the root more than once.\n            continue;\n          }\n          didError = false;\n          error = null;\n          {\n            invokeGuardedCallback(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);\n            if (hasCaughtError()) {\n              didError = true;\n              error = clearCaughtError();\n              continue;\n            }\n          }\n          // We're finished working. Exit the error loop.\n          break;\n        }\n        var uncaughtError = firstUncaughtError;\n\n        // We're done performing work. Time to clean up.\n        isWorking = false;\n        didFatal = false;\n        firstUncaughtError = null;\n        {\n          stopWorkLoopTimer();\n        }\n        if (uncaughtError !== null) {\n          onUncaughtError(uncaughtError);\n        }\n        return root.isReadyForCommit ? root.current.alternate : null;\n      }\n\n      // Returns the boundary that captured the error, or null if the error is ignored\n      function captureError(failedWork, error) {\n        // It is no longer valid because we exited the user code.\n        ReactCurrentOwner.current = null;\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        // Search for the nearest error boundary.\n        var boundary = null;\n\n        // Passed to logCapturedError()\n        var errorBoundaryFound = false;\n        var willRetry = false;\n        var errorBoundaryName = null;\n\n        // Host containers are a special case. If the failed work itself is a host\n        // container, then it acts as its own boundary. In all other cases, we\n        // ignore the work itself and only search through the parents.\n        if (failedWork.tag === HostRoot) {\n          boundary = failedWork;\n          if (isFailedBoundary(failedWork)) {\n            // If this root already failed, there must have been an error when\n            // attempting to unmount it. This is a worst-case scenario and\n            // should only be possible if there's a bug in the renderer.\n            didFatal = true;\n          }\n        } else {\n          var node = failedWork['return'];\n          while (node !== null && boundary === null) {\n            if (node.tag === ClassComponent) {\n              var instance = node.stateNode;\n              if (typeof instance.componentDidCatch === 'function') {\n                errorBoundaryFound = true;\n                errorBoundaryName = getComponentName(node);\n\n                // Found an error boundary!\n                boundary = node;\n                willRetry = true;\n              }\n            } else if (node.tag === HostRoot) {\n              // Treat the root like a no-op error boundary\n              boundary = node;\n            }\n            if (isFailedBoundary(node)) {\n              // This boundary is already in a failed state.\n\n              // If we're currently unmounting, that means this error was\n              // thrown while unmounting a failed subtree. We should ignore\n              // the error.\n              if (isUnmounting) {\n                return null;\n              }\n\n              // If we're in the commit phase, we should check to see if\n              // this boundary already captured an error during this commit.\n              // This case exists because multiple errors can be thrown during\n              // a single commit without interruption.\n              if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n                // If so, we should ignore this error.\n                return null;\n              }\n\n              // The error should propagate to the next boundary -— we keep looking.\n              boundary = null;\n              willRetry = false;\n            }\n            node = node['return'];\n          }\n        }\n        if (boundary !== null) {\n          // Add to the collection of failed boundaries. This lets us know that\n          // subsequent errors in this subtree should propagate to the next boundary.\n          if (failedBoundaries === null) {\n            failedBoundaries = new Set();\n          }\n          failedBoundaries.add(boundary);\n\n          // This method is unsafe outside of the begin and complete phases.\n          // We might be in the commit phase when an error is captured.\n          // The risk is that the return path from this Fiber may not be accurate.\n          // That risk is acceptable given the benefit of providing users more context.\n          var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n          var _componentName = getComponentName(failedWork);\n\n          // Add to the collection of captured errors. This is stored as a global\n          // map of errors and their component stack location keyed by the boundaries\n          // that capture them. We mostly use this Map as a Set; it's a Map only to\n          // avoid adding a field to Fiber to store the error.\n          if (capturedErrors === null) {\n            capturedErrors = new Map();\n          }\n          var capturedError = {\n            componentName: _componentName,\n            componentStack: _componentStack,\n            error: error,\n            errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n            errorBoundaryFound: errorBoundaryFound,\n            errorBoundaryName: errorBoundaryName,\n            willRetry: willRetry\n          };\n          capturedErrors.set(boundary, capturedError);\n          try {\n            logCapturedError(capturedError);\n          } catch (e) {\n            // Prevent cycle if logCapturedError() throws.\n            // A cycle may still occur if logCapturedError renders a component that throws.\n            console.error(e);\n          }\n\n          // If we're in the commit phase, defer scheduling an update on the\n          // boundary until after the commit is complete\n          if (isCommitting) {\n            if (commitPhaseBoundaries === null) {\n              commitPhaseBoundaries = new Set();\n            }\n            commitPhaseBoundaries.add(boundary);\n          } else {\n            // Otherwise, schedule an update now.\n            // TODO: Is this actually necessary during the render phase? Is it\n            // possible to unwind and continue rendering at the same priority,\n            // without corrupting internal state?\n            scheduleErrorRecovery(boundary);\n          }\n          return boundary;\n        } else if (firstUncaughtError === null) {\n          // If no boundary is found, we'll need to throw the error\n          firstUncaughtError = error;\n        }\n        return null;\n      }\n      function hasCapturedError(fiber) {\n        // TODO: capturedErrors should store the boundary instance, to avoid needing\n        // to check the alternate.\n        return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n      }\n      function isFailedBoundary(fiber) {\n        // TODO: failedBoundaries should store the boundary instance, to avoid\n        // needing to check the alternate.\n        return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n      }\n      function commitErrorHandling(effectfulFiber) {\n        var capturedError = void 0;\n        if (capturedErrors !== null) {\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n          if (capturedError == null) {\n            if (effectfulFiber.alternate !== null) {\n              effectfulFiber = effectfulFiber.alternate;\n              capturedError = capturedErrors.get(effectfulFiber);\n              capturedErrors['delete'](effectfulFiber);\n            }\n          }\n        }\n        !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        switch (effectfulFiber.tag) {\n          case ClassComponent:\n            var instance = effectfulFiber.stateNode;\n            var info = {\n              componentStack: capturedError.componentStack\n            };\n\n            // Allow the boundary to handle the error, usually by scheduling\n            // an update to itself\n            instance.componentDidCatch(capturedError.error, info);\n            return;\n          case HostRoot:\n            if (firstUncaughtError === null) {\n              firstUncaughtError = capturedError.error;\n            }\n            return;\n          default:\n            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n      function unwindContexts(from, to) {\n        var node = from;\n        while (node !== null) {\n          switch (node.tag) {\n            case ClassComponent:\n              popContextProvider(node);\n              break;\n            case HostComponent:\n              popHostContext(node);\n              break;\n            case HostRoot:\n              popHostContainer(node);\n              break;\n            case HostPortal:\n              popHostContainer(node);\n              break;\n          }\n          if (node === to || node.alternate === to) {\n            {\n              stopFailedWorkTimer(node);\n            }\n            break;\n          } else {\n            stopWorkTimer(node);\n          }\n          node = node['return'];\n        }\n      }\n      function computeAsyncExpiration() {\n        // Given the current clock time, returns an expiration time. We use rounding\n        // to batch like updates together.\n        // Should complete within ~1000ms. 1200ms max.\n        var currentTime = recalculateCurrentTime();\n        var expirationMs = 1000;\n        var bucketSizeMs = 200;\n        return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n      }\n      function computeExpirationForFiber(fiber) {\n        var expirationTime = void 0;\n        if (expirationContext !== NoWork) {\n          // An explicit expiration context was set;\n          expirationTime = expirationContext;\n        } else if (isWorking) {\n          if (isCommitting) {\n            // Updates that occur during the commit phase should have sync priority\n            // by default.\n            expirationTime = Sync;\n          } else {\n            // Updates during the render phase should expire at the same time as\n            // the work that is being rendered.\n            expirationTime = nextRenderExpirationTime;\n          }\n        } else {\n          // No explicit expiration context was set, and we're not currently\n          // performing work. Calculate a new expiration time.\n          if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {\n            // This is a sync update\n            expirationTime = Sync;\n          } else {\n            // This is an async update\n            expirationTime = computeAsyncExpiration();\n          }\n        }\n        return expirationTime;\n      }\n      function scheduleWork(fiber, expirationTime) {\n        return scheduleWorkImpl(fiber, expirationTime, false);\n      }\n      function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n        {\n          recordScheduleUpdate();\n        }\n        {\n          if (!isErrorRecovery && fiber.tag === ClassComponent) {\n            var instance = fiber.stateNode;\n            warnAboutInvalidUpdates(instance);\n          }\n        }\n        var node = fiber;\n        while (node !== null) {\n          // Walk the parent path to the root and update each node's\n          // expiration time.\n          if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n            node.expirationTime = expirationTime;\n          }\n          if (node.alternate !== null) {\n            if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n              node.alternate.expirationTime = expirationTime;\n            }\n          }\n          if (node['return'] === null) {\n            if (node.tag === HostRoot) {\n              var root = node.stateNode;\n              if (!isWorking && root === nextRoot && expirationTime <= nextRenderExpirationTime) {\n                // This is an interruption. Restart the root from the top.\n                nextRoot = null;\n                nextUnitOfWork = null;\n                nextRenderExpirationTime = NoWork;\n              }\n              requestWork(root, expirationTime);\n            } else {\n              {\n                if (!isErrorRecovery && fiber.tag === ClassComponent) {\n                  warnAboutUpdateOnUnmounted(fiber);\n                }\n              }\n              return;\n            }\n          }\n          node = node['return'];\n        }\n      }\n      function scheduleErrorRecovery(fiber) {\n        scheduleWorkImpl(fiber, Sync, true);\n      }\n      function recalculateCurrentTime() {\n        // Subtract initial time so it fits inside 32bits\n        var ms = now() - startTime;\n        mostRecentCurrentTime = msToExpirationTime(ms);\n        return mostRecentCurrentTime;\n      }\n      function deferredUpdates(fn) {\n        var previousExpirationContext = expirationContext;\n        expirationContext = computeAsyncExpiration();\n        try {\n          return fn();\n        } finally {\n          expirationContext = previousExpirationContext;\n        }\n      }\n      function syncUpdates(fn) {\n        var previousExpirationContext = expirationContext;\n        expirationContext = Sync;\n        try {\n          return fn();\n        } finally {\n          expirationContext = previousExpirationContext;\n        }\n      }\n\n      // TODO: Everything below this is written as if it has been lifted to the\n      // renderers. I'll do this in a follow-up.\n\n      // Linked-list of roots\n      var firstScheduledRoot = null;\n      var lastScheduledRoot = null;\n      var isCallbackScheduled = false;\n      var isRendering = false;\n      var nextFlushedRoot = null;\n      var nextFlushedExpirationTime = NoWork;\n      var deadlineDidExpire = false;\n      var hasUnhandledError = false;\n      var unhandledError = null;\n      var deadline = null;\n      var isBatchingUpdates = false;\n      var isUnbatchingUpdates = false;\n\n      // Use these to prevent an infinite loop of nested updates\n      var NESTED_UPDATE_LIMIT = 1000;\n      var nestedUpdateCount = 0;\n      var timeHeuristicForUnitOfWork = 1;\n\n      // requestWork is called by the scheduler whenever a root receives an update.\n      // It's up to the renderer to call renderRoot at some point in the future.\n      function requestWork(root, expirationTime) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n          invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n        }\n\n        // Add the root to the schedule.\n        // Check if this root is already part of the schedule.\n        if (root.nextScheduledRoot === null) {\n          // This root is not already scheduled. Add it.\n          root.remainingExpirationTime = expirationTime;\n          if (lastScheduledRoot === null) {\n            firstScheduledRoot = lastScheduledRoot = root;\n            root.nextScheduledRoot = root;\n          } else {\n            lastScheduledRoot.nextScheduledRoot = root;\n            lastScheduledRoot = root;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          }\n        } else {\n          // This root is already scheduled, but its priority may have increased.\n          var remainingExpirationTime = root.remainingExpirationTime;\n          if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n            // Update the priority.\n            root.remainingExpirationTime = expirationTime;\n          }\n        }\n        if (isRendering) {\n          // Prevent reentrancy. Remaining work will be scheduled at the end of\n          // the currently rendering batch.\n          return;\n        }\n        if (isBatchingUpdates) {\n          // Flush work at the end of the batch.\n          if (isUnbatchingUpdates) {\n            // ...unless we're inside unbatchedUpdates, in which case we should\n            // flush it now.\n            performWorkOnRoot(root, Sync);\n          }\n          return;\n        }\n\n        // TODO: Get rid of Sync and use current time?\n        if (expirationTime === Sync) {\n          performWork(Sync, null);\n        } else if (!isCallbackScheduled) {\n          isCallbackScheduled = true;\n          scheduleDeferredCallback(performAsyncWork);\n        }\n      }\n      function findHighestPriorityRoot() {\n        var highestPriorityWork = NoWork;\n        var highestPriorityRoot = null;\n        if (lastScheduledRoot !== null) {\n          var previousScheduledRoot = lastScheduledRoot;\n          var root = firstScheduledRoot;\n          while (root !== null) {\n            var remainingExpirationTime = root.remainingExpirationTime;\n            if (remainingExpirationTime === NoWork) {\n              // This root no longer has work. Remove it from the scheduler.\n\n              // TODO: This check is redudant, but Flow is confused by the branch\n              // below where we set lastScheduledRoot to null, even though we break\n              // from the loop right after.\n              !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              if (root === root.nextScheduledRoot) {\n                // This is the only root in the list.\n                root.nextScheduledRoot = null;\n                firstScheduledRoot = lastScheduledRoot = null;\n                break;\n              } else if (root === firstScheduledRoot) {\n                // This is the first root in the list.\n                var next = root.nextScheduledRoot;\n                firstScheduledRoot = next;\n                lastScheduledRoot.nextScheduledRoot = next;\n                root.nextScheduledRoot = null;\n              } else if (root === lastScheduledRoot) {\n                // This is the last root in the list.\n                lastScheduledRoot = previousScheduledRoot;\n                lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n                root.nextScheduledRoot = null;\n                break;\n              } else {\n                previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n                root.nextScheduledRoot = null;\n              }\n              root = previousScheduledRoot.nextScheduledRoot;\n            } else {\n              if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n                // Update the priority, if it's higher\n                highestPriorityWork = remainingExpirationTime;\n                highestPriorityRoot = root;\n              }\n              if (root === lastScheduledRoot) {\n                break;\n              }\n              previousScheduledRoot = root;\n              root = root.nextScheduledRoot;\n            }\n          }\n        }\n\n        // If the next root is the same as the previous root, this is a nested\n        // update. To prevent an infinite loop, increment the nested update count.\n        var previousFlushedRoot = nextFlushedRoot;\n        if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {\n          nestedUpdateCount++;\n        } else {\n          // Reset whenever we switch roots.\n          nestedUpdateCount = 0;\n        }\n        nextFlushedRoot = highestPriorityRoot;\n        nextFlushedExpirationTime = highestPriorityWork;\n      }\n      function performAsyncWork(dl) {\n        performWork(NoWork, dl);\n      }\n      function performWork(minExpirationTime, dl) {\n        deadline = dl;\n\n        // Keep working on roots until there's no more work, or until the we reach\n        // the deadlne.\n        findHighestPriorityRoot();\n        while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {\n          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n          // Find the next highest priority work.\n          findHighestPriorityRoot();\n        }\n\n        // We're done flushing work. Either we ran out of time in this callback,\n        // or there's no more work left with sufficient priority.\n\n        // If we're inside a callback, set this to false since we just completed it.\n        if (deadline !== null) {\n          isCallbackScheduled = false;\n        }\n        // If there's work left over, schedule a new callback.\n        if (nextFlushedRoot !== null && !isCallbackScheduled) {\n          isCallbackScheduled = true;\n          scheduleDeferredCallback(performAsyncWork);\n        }\n\n        // Clean-up.\n        deadline = null;\n        deadlineDidExpire = false;\n        nestedUpdateCount = 0;\n        if (hasUnhandledError) {\n          var _error4 = unhandledError;\n          unhandledError = null;\n          hasUnhandledError = false;\n          throw _error4;\n        }\n      }\n      function performWorkOnRoot(root, expirationTime) {\n        !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        isRendering = true;\n\n        // Check if this is async work or sync/expired work.\n        // TODO: Pass current time as argument to renderRoot, commitRoot\n        if (expirationTime <= recalculateCurrentTime()) {\n          // Flush sync work.\n          var finishedWork = root.finishedWork;\n          if (finishedWork !== null) {\n            // This root is already complete. We can commit it.\n            root.finishedWork = null;\n            root.remainingExpirationTime = commitRoot(finishedWork);\n          } else {\n            root.finishedWork = null;\n            finishedWork = renderRoot(root, expirationTime);\n            if (finishedWork !== null) {\n              // We've completed the root. Commit it.\n              root.remainingExpirationTime = commitRoot(finishedWork);\n            }\n          }\n        } else {\n          // Flush async work.\n          var _finishedWork = root.finishedWork;\n          if (_finishedWork !== null) {\n            // This root is already complete. We can commit it.\n            root.finishedWork = null;\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } else {\n            root.finishedWork = null;\n            _finishedWork = renderRoot(root, expirationTime);\n            if (_finishedWork !== null) {\n              // We've completed the root. Check the deadline one more time\n              // before committing.\n              if (!shouldYield()) {\n                // Still time left. Commit the root.\n                root.remainingExpirationTime = commitRoot(_finishedWork);\n              } else {\n                // There's no time left. Mark this root as complete. We'll come\n                // back and commit it later.\n                root.finishedWork = _finishedWork;\n              }\n            }\n          }\n        }\n        isRendering = false;\n      }\n\n      // When working on async work, the reconciler asks the renderer if it should\n      // yield execution. For DOM, we implement this with requestIdleCallback.\n      function shouldYield() {\n        if (deadline === null) {\n          return false;\n        }\n        if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n          return false;\n        }\n        deadlineDidExpire = true;\n        return true;\n      }\n\n      // TODO: Not happy about this hook. Conceptually, renderRoot should return a\n      // tuple of (isReadyForCommit, didError, error)\n      function onUncaughtError(error) {\n        !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        // Unschedule this root so we don't work on it again until there's\n        // another update.\n        nextFlushedRoot.remainingExpirationTime = NoWork;\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      }\n\n      // TODO: Batching should be implemented at the renderer level, not inside\n      // the reconciler.\n      function batchedUpdates(fn, a) {\n        var previousIsBatchingUpdates = isBatchingUpdates;\n        isBatchingUpdates = true;\n        try {\n          return fn(a);\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates;\n          if (!isBatchingUpdates && !isRendering) {\n            performWork(Sync, null);\n          }\n        }\n      }\n\n      // TODO: Batching should be implemented at the renderer level, not inside\n      // the reconciler.\n      function unbatchedUpdates(fn) {\n        if (isBatchingUpdates && !isUnbatchingUpdates) {\n          isUnbatchingUpdates = true;\n          try {\n            return fn();\n          } finally {\n            isUnbatchingUpdates = false;\n          }\n        }\n        return fn();\n      }\n\n      // TODO: Batching should be implemented at the renderer level, not within\n      // the reconciler.\n      function flushSync(fn) {\n        var previousIsBatchingUpdates = isBatchingUpdates;\n        isBatchingUpdates = true;\n        try {\n          return syncUpdates(fn);\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates;\n          !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n          performWork(Sync, null);\n        }\n      }\n      return {\n        computeAsyncExpiration: computeAsyncExpiration,\n        computeExpirationForFiber: computeExpirationForFiber,\n        scheduleWork: scheduleWork,\n        batchedUpdates: batchedUpdates,\n        unbatchedUpdates: unbatchedUpdates,\n        flushSync: flushSync,\n        deferredUpdates: deferredUpdates\n      };\n    };\n    {\n      var didWarnAboutNestedUpdates = false;\n    }\n    function getContextForSubtree(parentComponent) {\n      if (!parentComponent) {\n        return emptyObject;\n      }\n      var fiber = get(parentComponent);\n      var parentContext = findCurrentUnmaskedContext(fiber);\n      return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n    }\n    var ReactFiberReconciler = function (config) {\n      var getPublicInstance = config.getPublicInstance;\n      var _ReactFiberScheduler = ReactFiberScheduler(config),\n        computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,\n        computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n        scheduleWork = _ReactFiberScheduler.scheduleWork,\n        batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n        unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n        flushSync = _ReactFiberScheduler.flushSync,\n        deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n      function scheduleTopLevelUpdate(current, element, callback) {\n        {\n          if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n            didWarnAboutNestedUpdates = true;\n            warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n          }\n        }\n        callback = callback === undefined ? null : callback;\n        {\n          warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n        }\n        var expirationTime = void 0;\n        // Check if the top-level element is an async wrapper component. If so,\n        // treat updates to the root as async. This is a bit weird but lets us\n        // avoid a separate `renderAsync` API.\n        if (ReactFeatureFlags.enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {\n          expirationTime = computeAsyncExpiration();\n        } else {\n          expirationTime = computeExpirationForFiber(current);\n        }\n        var update = {\n          expirationTime: expirationTime,\n          partialState: {\n            element: element\n          },\n          callback: callback,\n          isReplace: false,\n          isForced: false,\n          nextCallback: null,\n          next: null\n        };\n        insertUpdateIntoFiber(current, update);\n        scheduleWork(current, expirationTime);\n      }\n      return {\n        createContainer: function (containerInfo, hydrate) {\n          return createFiberRoot(containerInfo, hydrate);\n        },\n        updateContainer: function (element, container, parentComponent, callback) {\n          // TODO: If this is a nested container, this won't be the root.\n          var current = container.current;\n          {\n            if (ReactFiberInstrumentation_1.debugTool) {\n              if (current.alternate === null) {\n                ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n              } else if (element === null) {\n                ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n              } else {\n                ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n              }\n            }\n          }\n          var context = getContextForSubtree(parentComponent);\n          if (container.context === null) {\n            container.context = context;\n          } else {\n            container.pendingContext = context;\n          }\n          scheduleTopLevelUpdate(current, element, callback);\n        },\n        batchedUpdates: batchedUpdates,\n        unbatchedUpdates: unbatchedUpdates,\n        deferredUpdates: deferredUpdates,\n        flushSync: flushSync,\n        getPublicRootInstance: function (container) {\n          var containerFiber = container.current;\n          if (!containerFiber.child) {\n            return null;\n          }\n          switch (containerFiber.child.tag) {\n            case HostComponent:\n              return getPublicInstance(containerFiber.child.stateNode);\n            default:\n              return containerFiber.child.stateNode;\n          }\n        },\n        findHostInstance: function (fiber) {\n          var hostFiber = findCurrentHostFiber(fiber);\n          if (hostFiber === null) {\n            return null;\n          }\n          return hostFiber.stateNode;\n        },\n        findHostInstanceWithNoPortals: function (fiber) {\n          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n          if (hostFiber === null) {\n            return null;\n          }\n          return hostFiber.stateNode;\n        }\n      };\n    };\n    var ReactFiberReconciler$1 = Object.freeze({\n      default: ReactFiberReconciler\n    });\n    var ReactFiberReconciler$2 = ReactFiberReconciler$1 && ReactFiberReconciler || ReactFiberReconciler$1;\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    // TODO: bundle Flow types with the package.\n\n    // TODO: decide on the top-level export form.\n    // This is hacky but makes it work with both Rollup and Jest.\n    var reactReconciler = ReactFiberReconciler$2['default'] ? ReactFiberReconciler$2['default'] : ReactFiberReconciler$2;\n    module.exports = reactReconciler;\n    return ($$$reconciler || ($$$reconciler = module.exports))(config);\n  };\n}","map":{"version":3,"names":["process","env","NODE_ENV","$$$reconciler","module","exports","config","invariant","require","warning","React","emptyObject","_assign","checkPropTypes","shallowEqual","ReactFeatureFlags","enableAsyncSubtreeAPI","enableAsyncSchedulingByDefaultInReactDOM","enableMutatingReconciler","enableNoopReconciler","enablePersistentReconciler","enableReactFragment","enableCreateRoot","Object","freeze","get","key","_reactInternalFiber","set","value","ReactInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","ReactDebugCurrentFrame","getComponentName","fiber","type","displayName","name","IndeterminateComponent","FunctionalComponent","ClassComponent","HostRoot","HostPortal","HostComponent","HostText","CallComponent","CallHandlerPhase","ReturnComponent","Fragment","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","Err","Ref","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","node","alternate","effectTag","tag","isFiberMounted","isMounted","component","owner","current","ownerFiber","instance","stateNode","_warnedAboutRefsInRender","assertIsMounted","findCurrentFiberUsingSlowPath","state","a","b","parentA","parentB","child","sibling","didFindChild","_child","findCurrentHostFiber","parent","currentParent","findCurrentHostFiberWithNoPortals","valueStack","fiberStack","index","createCursor","defaultValue","pop","cursor","push","reset","describeComponentFrame","source","ownerName","fileName","replace","lineNumber","describeFiber","_debugOwner","_debugSource","getStackAddendumByWorkInProgressFiber","workInProgress","info","getCurrentFiberOwnerName","ReactDebugCurrentFiber","getCurrentFiberStackAddendum","resetCurrentFiber","getCurrentStack","phase","setCurrentFiber","setCurrentPhase","ReactDebugFiberPerf","reactEmoji","warningEmoji","supportsUserTiming","performance","mark","clearMarks","measure","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","labelsInCurrentCommit","Set","formatMarkName","markName","formatLabel","label","warning$$1","prefix","suffix","beginMark","clearMark","endMark","formattedMarkName","formattedLabel","err","getFiberMarkName","debugID","getFiberLabel","componentName","beginFiberMark","_debugID","has","add","clearFiberMark","endFiberMark","shouldIgnoreFiber","clearPendingPhaseMeasurement","pauseTimers","_debugIsCurrentlyTiming","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startWorkLoopTimer","stopWorkLoopTimer","startCommitTimer","clear","stopCommitTimer","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","count","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","ReactDebugFiberPerf$1","warnedAboutMissingGetChildContext","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","hasOwnContext","isContextProvider","cacheContext","unmaskedContext","maskedContext","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","contextTypes","context","hasContextChanged","isContextConsumer","childContextTypes","popContextProvider","popTopLevelContextObject","pushTopLevelContextObject","didChange","processChildContext","parentContext","getChildContext","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","resetContext","findCurrentUnmaskedContext","NoWork","Sync","Never","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","ceiling","num","precision","computeExpirationBucket","currentTime","expirationInMs","bucketSizeMs","NoContext","AsyncUpdates","hasBadMapPolyfill","nonExtensibleObject","preventExtensions","Map","e","debugCounter","FiberNode","internalContextTag","ref","pendingProps","memoizedProps","updateQueue","memoizedState","nextEffect","firstEffect","lastEffect","expirationTime","createFiber","shouldConstruct","Component","prototype","isReactComponent","createWorkInProgress","createHostRootFiber","createFiberFromElement","element","_owner","props","undefined","keys","length","_source","createFiberFromFragment","elements","createFiberFromText","content","createFiberFromHostInstanceForDeletion","createFiberFromCall","call","handler","createFiberFromReturn","returnNode","createFiberFromPortal","portal","children","containerInfo","pendingChildren","implementation","createFiberRoot","hydrate","uninitializedFiber","root","remainingExpirationTime","isReadyForCommit","finishedWork","pendingContext","nextScheduledRoot","ReactErrorUtils","_caughtError","_hasCaughtError","_rethrowError","_hasRethrowError","injection","injectErrorUtils","injectedErrorUtils","invokeGuardedCallback","invokeGuardedCallback$1","func","c","d","f","apply","arguments","invokeGuardedCallbackAndCatchFirstError","hasCaughtError","error","clearCaughtError","rethrowCaughtError","funcArgs","Array","slice","window","dispatchEvent","document","createEvent","fakeNode","createElement","invokeGuardedCallbackDev","didError","callCallback","removeEventListener","evtType","didSetError","isCrossOriginError","onError","event","colno","lineno","addEventListener","evt","initEvent","Error","didWarnUpdateInsideUpdate","createUpdateQueue","baseState","queue","first","last","callbackList","hasForceUpdate","isInitialized","isProcessing","insertUpdateIntoQueue","update","next","insertUpdateIntoFiber","alternateFiber","queue1","queue2","getUpdateExpirationTime","getStateFromUpdate","prevState","partialState","updateFn","processUpdateQueue","renderExpirationTime","currentQueue","dontMutatePrevState","didSkip","updateExpirationTime","_partialState","isReplace","isForced","callback","_callbackList","commitCallbacks","i","_callback","startPhaseTimer$1","stopPhaseTimer$1","fakeInternalInstance","isArray","didWarnAboutStateAssignmentForComponent","warnOnInvalidCallback","callerName","defineProperty","enumerable","ReactFiberClassComponent","scheduleWork","computeExpirationForFiber","memoizeProps","memoizeState","updater","enqueueSetState","nextCallback","enqueueReplaceState","enqueueForceUpdate","checkShouldComponentUpdate","oldProps","newProps","oldState","newState","newContext","shouldComponentUpdate","shouldUpdate","isPureReactComponent","checkClassInstance","renderPresent","render","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentWillRecieveProps","componentWillRecieveProps","hasMutatedProps","noInstanceDefaultProps","defaultProps","resetInputPointers","adoptClassInstance","_reactInternalInstance","constructClassInstance","ctor","needsContext","callComponentWillMount","componentWillMount","callComponentWillReceiveProps","componentWillReceiveProps","mountClassInstance","refs","unstable_isAsyncReactComponent","componentDidMount","updateClassInstance","oldContext","newUnmaskedContext","componentDidUpdate","componentWillUpdate","REACT_PORTAL_TYPE","Symbol","getCurrentFiberStackAddendum$1","didWarnAboutMaps","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","_store","validated","currentComponentErrorInfo","isArray$1","ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","REACT_ELEMENT_TYPE","REACT_CALL_TYPE","REACT_RETURN_TYPE","REACT_FRAGMENT_TYPE","getIteratorFn","maybeIterable","iteratorFn","coerceRef","mixedRef","inst","stringRef","_stringRef","throwOnInvalidObjectType","returnFiber","newChild","addendum","toString","join","warnOnFunctionType","ChildReconciler","shouldClone","shouldTrackSideEffects","deleteChild","childToDelete","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","existingChild","useFiber","clone","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","textContent","created","existing","updateElement","updateCall","updateReturn","updatePortal","updateFragment","fragment","createChild","$$typeof","_created","_created2","_created3","_created4","_created5","_created6","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","_matchedFiber","_matchedFiber2","_matchedFiber3","_matchedFiber4","_matchedFiber5","warnOnInvalidKey","knownKeys","reconcileChildrenArray","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_newFiber2","forEach","reconcileChildrenIterator","newChildrenIterable","entries","possibleMap","_newChildren","_step","done","step","_newFiber3","_newFiber4","reconcileSingleTextNode","reconcileSingleElement","_created7","reconcileSingleCall","reconcileSingleReturn","reconcileSinglePortal","reconcileChildFibers","isObject","_isMockFunction","reconcileChildFibersInPlace","mountChildFibersInPlace","cloneChildFibers","currentChild","warnedAboutStatelessRefs","ReactFiberBeginWork","hostContext","hydrationContext","shouldSetTextContent","useSyncScheduling","shouldDeprioritizeSubtree","pushHostContext","pushHostContainer","enterHydrationState","resetHydrationState","tryToClaimNextHydratableInstance","_ReactFiberClassCompo","reconcileChildren","nextChildren","reconcileChildrenAtExpirationTime","bailoutOnAlreadyFinishedWork","markRef","updateFunctionalComponent","fn","nextProps","updateClassComponent","hasContext","finishClassComponent","pushHostRootContext","updateHostRoot","updateHostComponent","prevProps","isDirectTextChild","updateHostText","mountIndeterminateComponent","warningKey","debugSource","updateCallComponent","nextCall","updatePortalComponent","bailoutOnLowPriority","nextState","beginWork","beginFailedWork","ReactFiberCompleteWork","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","mutation","persistence","getRootHostContainer","popHostContext","getHostContext","popHostContainer","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","popHydrationState","markUpdate","appendAllReturns","returns","moveCallToHandlerPhase","appendAllChildren","updateHostContainer","updatePayload","rootContainerInstance","oldText","newText","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","newChildSet","currentInstance","recyclableInstance","newInstance","currentHostContext","completeWork","fiberRoot","_currentHostContext","wasHydrated","_instance","_rootContainerInstance","_currentHostContext2","_wasHydrated","onCommitFiberRoot","onCommitFiberUnmount","onCommitRoot","onCommitUnmount","invokeGuardedCallback$2","hasCaughtError$1","clearCaughtError$1","startPhaseTimer$2","stopPhaseTimer$2","ReactFiberCommitWork","captureError","getPublicInstance","callComponentWillUnmountWithTimerInDev","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","safelyDetachRef","refError","commitLifeCycles","_updateQueue","_instance2","commitMount","commitAttachRef","commitDetachRef","currentRef","commitUnmount","commitNestedUnmounts","unmountHostComponents","emptyPortalContainer","detachFiber","commitContainer","replaceContainerChildren","emptyChildSet","_pendingChildren","commitResetTextContent","commitPlacement","commitDeletion","commitWork","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","getHostParentFiber","isHostParent","getHostSibling","siblings","parentFiber","isContainer","before","currentParentIsValid","currentParentIsContainer","findParent","textInstance","NO_CONTEXT","ReactFiberHostContext","getChildHostContext","getRootHostContext","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","rootInstance","nextRootInstance","nextRootContext","nextContext","resetHostContainer","ReactFiberHydrationContext","hydration","canHydrateInstance","canHydrateTextInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","hydrationParentFiber","nextHydratableInstance","isHydrating","parentInstance","deleteHydratableInstance","insertNonHydratedInstance","parentContainer","text","parentType","parentProps","_type","_props","_text","canHydrate","nextInstance","popToNextHostParent","ReactFiberInstrumentation","debugTool","ReactFiberInstrumentation_1","defaultShowDialog","capturedError","showDialog","logCapturedError","logError","componentStack","errorBoundaryName","errorBoundaryFound","willRetry","componentNameMessage","errorBoundaryMessage","combinedMessage","console","didWarnAboutStateTransition","didWarnSetStateChildContext","didWarnStateUpdateForUnmountedComponent","warnAboutUpdateOnUnmounted","warnAboutInvalidUpdates","ReactFiberScheduler","_ReactFiberBeginWork","_ReactFiberCompleteWo","_ReactFiberCommitWork","now","scheduleDeferredCallback","prepareForCommit","resetAfterCommit","startTime","mostRecentCurrentTime","expirationContext","isWorking","nextUnitOfWork","nextRoot","nextRenderExpirationTime","capturedErrors","failedBoundaries","commitPhaseBoundaries","firstUncaughtError","didFatal","isUnmounting","resetContextStack","commitAllHostEffects","primaryEffectTag","_current","_current2","commitAllLifeCycles","commitErrorHandling","commitRoot","_error","_didError","_error2","onCommitWork","scheduleErrorRecovery","_error3","onUncaughtError","remainingTime","resetExpirationTime","renderTime","newExpirationTime","completeUnitOfWork","siblingFiber","onCompleteWork","performUnitOfWork","onBeginWork","performFailedUnitOfWork","workLoop","slowWorkLoopThatChecksForFailedWork","shouldYield","hasCapturedError","renderRootCatchBlock","failedWork","boundary","unwindContexts","renderRoot","uncaughtError","isFailedBoundary","componentDidCatch","_componentStack","_componentName","errorBoundary","effectfulFiber","from","to","computeAsyncExpiration","recalculateCurrentTime","expirationMs","scheduleWorkImpl","isErrorRecovery","requestWork","deferredUpdates","previousExpirationContext","syncUpdates","firstScheduledRoot","lastScheduledRoot","isCallbackScheduled","isRendering","nextFlushedRoot","nextFlushedExpirationTime","deadlineDidExpire","hasUnhandledError","unhandledError","deadline","isBatchingUpdates","isUnbatchingUpdates","NESTED_UPDATE_LIMIT","nestedUpdateCount","timeHeuristicForUnitOfWork","performWorkOnRoot","performWork","performAsyncWork","findHighestPriorityRoot","highestPriorityWork","highestPriorityRoot","previousScheduledRoot","previousFlushedRoot","dl","minExpirationTime","_error4","_finishedWork","timeRemaining","batchedUpdates","previousIsBatchingUpdates","unbatchedUpdates","flushSync","didWarnAboutNestedUpdates","getContextForSubtree","parentComponent","ReactFiberReconciler","_ReactFiberScheduler","scheduleTopLevelUpdate","createContainer","updateContainer","onMountContainer","onUnmountContainer","onUpdateContainer","getPublicRootInstance","containerFiber","findHostInstance","hostFiber","findHostInstanceWithNoPortals","ReactFiberReconciler$1","default","ReactFiberReconciler$2","reactReconciler"],"sources":["/Users/abc/Downloads/Workspace/c2i/image-text/c2i-convert/node_modules/redocx/node_modules/react-reconciler/cjs/react-reconciler.development.js"],"sourcesContent":["/** @license React v16.1.0-beta\n * react-reconciler.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n'use strict';\n\n\nif (process.env.NODE_ENV !== \"production\") {\nvar $$$reconciler;\nmodule.exports = function(config) {\n\n'use strict';\n\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\nvar React = require('react');\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar _assign = require('object-assign');\nvar checkPropTypes = require('prop-types/checkPropTypes');\nvar shallowEqual = require('fbjs/lib/shallowEqual');\n\nvar ReactFeatureFlags = {\n  enableAsyncSubtreeAPI: true,\n  enableAsyncSchedulingByDefaultInReactDOM: false,\n  // Mutating mode (React DOM, React ART, React Native):\n  enableMutatingReconciler: true,\n  // Experimental noop mode (currently unused):\n  enableNoopReconciler: false,\n  // Experimental persistent mode (CS):\n  enablePersistentReconciler: false,\n  // Exports React.Fragment\n  enableReactFragment: false,\n  // Exports ReactDOM.createRoot\n  enableCreateRoot: false\n}; /**\n    * Copyright (c) 2013-present, Facebook, Inc.\n    *\n    * This source code is licensed under the MIT license found in the\n    * LICENSE file in the root directory of this source tree.\n    *\n    * \n    */\n\n{\n  if (Object.freeze) {\n    Object.freeze(ReactFeatureFlags);\n  }\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * WARNING: DO NOT manually require this module.\n * This is a replacement for `invariant(...)` used by the error code system\n * and will _only_ be required by the corresponding babel pass.\n * It always throws.\n */\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n   * This API should be called `delete` but we'd have to make sure to always\n   * transform these to strings for IE support. When this transform is fully\n   * supported we can rename it.\n   */\n\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\n\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  return null;\n} /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * \n   */\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\nvar CallComponent = 7;\nvar CallHandlerPhase = 8;\nvar ReturnComponent = 9;\nvar Fragment = 10;\n\n// Don't change these two values:\nvar NoEffect = 0; //           0b00000000\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar PerformedWork = 1; //      0b00000001\n\n// You can change the rest (and add more).\nvar Placement = 2; //          0b00000010\nvar Update = 4; //             0b00000100\nvar PlacementAndUpdate = 6; // 0b00000110\nvar Deletion = 8; //           0b00001000\nvar ContentReset = 16; //      0b00010000\nvar Callback = 32; //          0b00100000\nvar Err = 64; //               0b01000000\nvar Ref = 128; //              0b10000000\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node['return']) {\n      node = node['return'];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node['return']) {\n      node = node['return'];\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a['return'];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a['return'] !== b['return']) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nvar valueStack = [];\n\n{\n  var fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\n\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warning(false, 'Unexpected pop.');\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warning(false, 'Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction reset() {\n  while (index > -1) {\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n}\n\n/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node['return'];\n  } while (node);\n  return info;\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction getCurrentFiberOwnerName() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n};\n\n// Trust the developer to only use this with a true check\nvar ReactDebugFiberPerf = {};\n\n{\n  // Prefix measurements so that it's possible to filter them.\n  // Longer prefixes are hard to read in DevTools.\n  var reactEmoji = '\\u269B';\n  var warningEmoji = '\\u26D4';\n  var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n  // Keep track of current fiber so that we know the path to unwind on pause.\n  // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\n  var currentFiber = null;\n  // If we're in the middle of user code, which fiber and method is it?\n  // Reusing `currentFiber` would be confusing for this because user code fiber\n  // can change during commit phase too, but we don't need to unwind it (since\n  // lifecycles in the commit phase don't resemble a tree).\n  var currentPhase = null;\n  var currentPhaseFiber = null;\n  // Did lifecycle hook schedule an update? This is often a performance problem,\n  // so we will keep track of it, and include it in the report.\n  // Track commits caused by cascading updates.\n  var isCommitting = false;\n  var hasScheduledUpdateInCurrentCommit = false;\n  var hasScheduledUpdateInCurrentPhase = false;\n  var commitCountInCurrentWorkLoop = 0;\n  var effectCountInCurrentCommit = 0;\n  // During commits, we only show a measurement once per method name\n  // to avoid stretch the commit phase with measurement overhead.\n  var labelsInCurrentCommit = new Set();\n\n  var formatMarkName = function (markName) {\n    return reactEmoji + ' ' + markName;\n  };\n\n  var formatLabel = function (label, warning$$1) {\n    var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n    var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n    return '' + prefix + label + suffix;\n  };\n\n  var beginMark = function (markName) {\n    performance.mark(formatMarkName(markName));\n  };\n\n  var clearMark = function (markName) {\n    performance.clearMarks(formatMarkName(markName));\n  };\n\n  var endMark = function (label, markName, warning$$1) {\n    var formattedMarkName = formatMarkName(markName);\n    var formattedLabel = formatLabel(label, warning$$1);\n    try {\n      performance.measure(formattedLabel, formattedMarkName);\n    } catch (err) {}\n    // If previous mark was missing for some reason, this will throw.\n    // This could only happen if React crashed in an unexpected place earlier.\n    // Don't pile on with more errors.\n\n    // Clear marks immediately to avoid growing buffer.\n    performance.clearMarks(formattedMarkName);\n    performance.clearMeasures(formattedLabel);\n  };\n\n  var getFiberMarkName = function (label, debugID) {\n    return label + ' (#' + debugID + ')';\n  };\n\n  var getFiberLabel = function (componentName, isMounted, phase) {\n    if (phase === null) {\n      // These are composite component total time measurements.\n      return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n    } else {\n      // Composite component methods.\n      return componentName + '.' + phase;\n    }\n  };\n\n  var beginFiberMark = function (fiber, phase) {\n    var componentName = getComponentName(fiber) || 'Unknown';\n    var debugID = fiber._debugID;\n    var isMounted = fiber.alternate !== null;\n    var label = getFiberLabel(componentName, isMounted, phase);\n\n    if (isCommitting && labelsInCurrentCommit.has(label)) {\n      // During the commit phase, we don't show duplicate labels because\n      // there is a fixed overhead for every measurement, and we don't\n      // want to stretch the commit phase beyond necessary.\n      return false;\n    }\n    labelsInCurrentCommit.add(label);\n\n    var markName = getFiberMarkName(label, debugID);\n    beginMark(markName);\n    return true;\n  };\n\n  var clearFiberMark = function (fiber, phase) {\n    var componentName = getComponentName(fiber) || 'Unknown';\n    var debugID = fiber._debugID;\n    var isMounted = fiber.alternate !== null;\n    var label = getFiberLabel(componentName, isMounted, phase);\n    var markName = getFiberMarkName(label, debugID);\n    clearMark(markName);\n  };\n\n  var endFiberMark = function (fiber, phase, warning$$1) {\n    var componentName = getComponentName(fiber) || 'Unknown';\n    var debugID = fiber._debugID;\n    var isMounted = fiber.alternate !== null;\n    var label = getFiberLabel(componentName, isMounted, phase);\n    var markName = getFiberMarkName(label, debugID);\n    endMark(label, markName, warning$$1);\n  };\n\n  var shouldIgnoreFiber = function (fiber) {\n    // Host components should be skipped in the timeline.\n    // We could check typeof fiber.type, but does this work with RN?\n    switch (fiber.tag) {\n      case HostRoot:\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n      case ReturnComponent:\n      case Fragment:\n        return true;\n      default:\n        return false;\n    }\n  };\n\n  var clearPendingPhaseMeasurement = function () {\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      clearFiberMark(currentPhaseFiber, currentPhase);\n    }\n    currentPhaseFiber = null;\n    currentPhase = null;\n    hasScheduledUpdateInCurrentPhase = false;\n  };\n\n  var pauseTimers = function () {\n    // Stops all currently active measurements so that they can be resumed\n    // if we continue in a later deferred loop from the same unit of work.\n    var fiber = currentFiber;\n    while (fiber) {\n      if (fiber._debugIsCurrentlyTiming) {\n        endFiberMark(fiber, null, null);\n      }\n      fiber = fiber['return'];\n    }\n  };\n\n  var resumeTimersRecursively = function (fiber) {\n    if (fiber['return'] !== null) {\n      resumeTimersRecursively(fiber['return']);\n    }\n    if (fiber._debugIsCurrentlyTiming) {\n      beginFiberMark(fiber, null);\n    }\n  };\n\n  var resumeTimers = function () {\n    // Resumes all measurements that were active during the last deferred loop.\n    if (currentFiber !== null) {\n      resumeTimersRecursively(currentFiber);\n    }\n  };\n\n  ReactDebugFiberPerf = {\n    recordEffect: function () {\n      effectCountInCurrentCommit++;\n    },\n    recordScheduleUpdate: function () {\n      if (isCommitting) {\n        hasScheduledUpdateInCurrentCommit = true;\n      }\n      if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n        hasScheduledUpdateInCurrentPhase = true;\n      }\n    },\n    startWorkTimer: function (fiber) {\n      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n        return;\n      }\n      // If we pause, this is the fiber to unwind from.\n      currentFiber = fiber;\n      if (!beginFiberMark(fiber, null)) {\n        return;\n      }\n      fiber._debugIsCurrentlyTiming = true;\n    },\n    cancelWorkTimer: function (fiber) {\n      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n        return;\n      }\n      // Remember we shouldn't complete measurement for this fiber.\n      // Otherwise flamechart will be deep even for small updates.\n      fiber._debugIsCurrentlyTiming = false;\n      clearFiberMark(fiber, null);\n    },\n    stopWorkTimer: function (fiber) {\n      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n        return;\n      }\n      // If we pause, its parent is the fiber to unwind from.\n      currentFiber = fiber['return'];\n      if (!fiber._debugIsCurrentlyTiming) {\n        return;\n      }\n      fiber._debugIsCurrentlyTiming = false;\n      endFiberMark(fiber, null, null);\n    },\n    stopFailedWorkTimer: function (fiber) {\n      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n        return;\n      }\n      // If we pause, its parent is the fiber to unwind from.\n      currentFiber = fiber['return'];\n      if (!fiber._debugIsCurrentlyTiming) {\n        return;\n      }\n      fiber._debugIsCurrentlyTiming = false;\n      var warning$$1 = 'An error was thrown inside this error boundary';\n      endFiberMark(fiber, null, warning$$1);\n    },\n    startPhaseTimer: function (fiber, phase) {\n      if (!supportsUserTiming) {\n        return;\n      }\n      clearPendingPhaseMeasurement();\n      if (!beginFiberMark(fiber, phase)) {\n        return;\n      }\n      currentPhaseFiber = fiber;\n      currentPhase = phase;\n    },\n    stopPhaseTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      if (currentPhase !== null && currentPhaseFiber !== null) {\n        var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n        endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n      }\n      currentPhase = null;\n      currentPhaseFiber = null;\n    },\n    startWorkLoopTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      commitCountInCurrentWorkLoop = 0;\n      // This is top level call.\n      // Any other measurements are performed within.\n      beginMark('(React Tree Reconciliation)');\n      // Resume any measurements that were in progress during the last loop.\n      resumeTimers();\n    },\n    stopWorkLoopTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      var warning$$1 = commitCountInCurrentWorkLoop > 1 ? 'There were cascading updates' : null;\n      commitCountInCurrentWorkLoop = 0;\n      // Pause any measurements until the next loop.\n      pauseTimers();\n      endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);\n    },\n    startCommitTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      isCommitting = true;\n      hasScheduledUpdateInCurrentCommit = false;\n      labelsInCurrentCommit.clear();\n      beginMark('(Committing Changes)');\n    },\n    stopCommitTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n\n      var warning$$1 = null;\n      if (hasScheduledUpdateInCurrentCommit) {\n        warning$$1 = 'Lifecycle hook scheduled a cascading update';\n      } else if (commitCountInCurrentWorkLoop > 0) {\n        warning$$1 = 'Caused by a cascading update in earlier commit';\n      }\n      hasScheduledUpdateInCurrentCommit = false;\n      commitCountInCurrentWorkLoop++;\n      isCommitting = false;\n      labelsInCurrentCommit.clear();\n\n      endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n    },\n    startCommitHostEffectsTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      effectCountInCurrentCommit = 0;\n      beginMark('(Committing Host Effects)');\n    },\n    stopCommitHostEffectsTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      var count = effectCountInCurrentCommit;\n      effectCountInCurrentCommit = 0;\n      endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n    },\n    startCommitLifeCyclesTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      effectCountInCurrentCommit = 0;\n      beginMark('(Calling Lifecycle Methods)');\n    },\n    stopCommitLifeCyclesTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      var count = effectCountInCurrentCommit;\n      effectCountInCurrentCommit = 0;\n      endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n    }\n  };\n}\n\n// TODO: convert to named exports\n// if this doesn't inflate the bundle.\nvar ReactDebugFiberPerf$1 = ReactDebugFiberPerf;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar startPhaseTimer = ReactDebugFiberPerf$1.startPhaseTimer;\nvar stopPhaseTimer = ReactDebugFiberPerf$1.stopPhaseTimer;\n\n\n{\n  var warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyObject;\n\nfunction getUnmaskedContext(workInProgress) {\n  var hasOwnContext = isContextProvider(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(workInProgress) || 'Unknown';\n    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n}\n\nfunction isContextProvider(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n}\n\nfunction popContextProvider(fiber) {\n  if (!isContextProvider(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== 'function') {\n    {\n      var componentName = getComponentName(fiber) || 'Unknown';\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n    startPhaseTimer(fiber, 'getChildContext');\n    childContext = instance.getChildContext();\n    stopPhaseTimer();\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n  }\n  {\n    var name = getComponentName(fiber) || 'Unknown';\n    checkPropTypes(childContextTypes, childContext, 'child context', name,\n    // In practice, there is one case in which we won't get a stack. It's when\n    // somebody calls unstable_renderSubtreeIntoContainer() and we process\n    // context from the parent component instance. The stack will be missing\n    // because it's outside of the reconciliation, and so the pointer has not\n    // been set. This is rare and doesn't matter. We'll also remove that API.\n    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  return _assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (!isContextProvider(workInProgress)) {\n    return false;\n  }\n\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, didChange) {\n  var instance = workInProgress.stateNode;\n  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction resetContext() {\n  previousContext = emptyObject;\n  contextStackCursor.current = emptyObject;\n  didPerformWorkStackCursor.current = false;\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var node = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node['return'];\n    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    node = parent;\n  }\n  return node.stateNode.context;\n}\n\nvar NoWork = 0; /**\n                        * Copyright (c) 2013-present, Facebook, Inc.\n                        *\n                        * This source code is licensed under the MIT license found in the\n                        * LICENSE file in the root directory of this source tree.\n                        *\n                        * \n                        */\n\n// TODO: Use an opaque type once ESLint et al support the syntax\n\nvar Sync = 1;\nvar Never = 2147483647; // Max int32: Math.pow(2, 31) - 1\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n}\n\nvar NoContext = 0; /**\n                           * Copyright (c) 2013-present, Facebook, Inc.\n                           *\n                           * This source code is licensed under the MIT license found in the\n                           * LICENSE file in the root directory of this source tree.\n                           *\n                           * \n                           */\n\nvar AsyncUpdates = 1;\n\n{\n  var hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    /* eslint-disable no-new */\n    new Map([[nonExtensibleObject, null]]);\n    new Set([nonExtensibleObject]);\n    /* eslint-enable no-new */\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\n{\n  var debugCounter = 1;\n}\n\nfunction FiberNode(tag, key, internalContextTag) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this['return'] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = null;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.internalContextTag = internalContextTag;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, key, internalContextTag) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, key, internalContextTag);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.expirationTime = expirationTime;\n  workInProgress.pendingProps = pendingProps;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber() {\n  var fiber = createFiber(HostRoot, null, NoContext);\n  return fiber;\n}\n\nfunction createFiberFromElement(element, internalContextTag, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type,\n      key = element.key;\n\n  if (typeof type === 'function') {\n    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);\n    fiber.type = type;\n    fiber.pendingProps = element.props;\n  } else if (typeof type === 'string') {\n    fiber = createFiber(HostComponent, key, internalContextTag);\n    fiber.type = type;\n    fiber.pendingProps = element.props;\n  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n    // Currently assumed to be a continuation and therefore is a fiber already.\n    // TODO: The yield system is currently broken for updates in some cases.\n    // The reified yield stores a fiber, but we don't know which fiber that is;\n    // the current or a workInProgress? When the continuation gets rendered here\n    // we don't know if we can reuse that fiber or if we need to clone it.\n    // There is probably a clever way to restructure this.\n    fiber = type;\n    fiber.pendingProps = element.props;\n  } else {\n    var info = '';\n    {\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in.\";\n      }\n      var ownerName = owner ? getComponentName(owner) : null;\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n    }\n    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n  }\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromFragment(elements, internalContextTag, expirationTime, key) {\n  var fiber = createFiber(Fragment, key, internalContextTag);\n  fiber.pendingProps = elements;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromText(content, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostText, null, internalContextTag);\n  fiber.pendingProps = content;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nfunction createFiberFromCall(call, internalContextTag, expirationTime) {\n  var fiber = createFiber(CallComponent, call.key, internalContextTag);\n  fiber.type = call.handler;\n  fiber.pendingProps = call;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromReturn(returnNode, internalContextTag, expirationTime) {\n  var fiber = createFiber(ReturnComponent, null, internalContextTag);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostPortal, portal.key, internalContextTag);\n  fiber.pendingProps = portal.children || [];\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction createFiberRoot(containerInfo, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber();\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    remainingExpirationTime: NoWork,\n    isReadyForCommit: false,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  injection: {\n    injectErrorUtils: function (injectedErrorUtils) {\n      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n      invokeGuardedCallback$1 = injectedErrorUtils.invokeGuardedCallback;\n    }\n  },\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function () {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function () {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function () {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n};\n\nvar invokeGuardedCallback$1 = function (name, func, context, a, b, c, d, e, f) {\n  ReactErrorUtils._hasCaughtError = false;\n  ReactErrorUtils._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    ReactErrorUtils._caughtError = error;\n    ReactErrorUtils._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      var evt = document.createEvent('Event');\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        ReactErrorUtils._hasCaughtError = true;\n        ReactErrorUtils._caughtError = error;\n      } else {\n        ReactErrorUtils._hasCaughtError = false;\n        ReactErrorUtils._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', onError);\n    };\n\n    invokeGuardedCallback$1 = invokeGuardedCallbackDev;\n  }\n}\n\nvar rethrowCaughtError = function () {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n{\n  var didWarnUpdateInsideUpdate = false;\n}\n\n// Callbacks are not validated until invocation\n\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    expirationTime: NoWork,\n    first: null,\n    last: null,\n    callbackList: null,\n    hasForceUpdate: false,\n    isInitialized: false\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.last === null) {\n    // Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  // We'll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    // TODO: We don't know what the base state will be until we begin work.\n    // It depends on which fiber is the next current. Initialize with an empty\n    // base state, then set to the memoizedState when rendering. Not super\n    // happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction getUpdateExpirationTime(fiber) {\n  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {\n    return NoWork;\n  }\n  var updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    return NoWork;\n  }\n  return updateQueue.expirationTime;\n}\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === 'function') {\n    var updateFn = partialState;\n    return updateFn.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      baseState: currentQueue.baseState,\n      expirationTime: currentQueue.expirationTime,\n      first: currentQueue.first,\n      last: currentQueue.last,\n      isInitialized: currentQueue.isInitialized,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Reset the remaining expiration time. If we skip over any updates, we'll\n  // increase this accordingly.\n  queue.expirationTime = NoWork;\n\n  // TODO: We don't know what the base state will be until we begin work.\n  // It depends on which fiber is the next current. Initialize with an empty\n  // base state, then set to the memoizedState when rendering. Not super\n  // happy with this approach.\n  var state = void 0;\n  if (queue.isInitialized) {\n    state = queue.baseState;\n  } else {\n    state = queue.baseState = workInProgress.memoizedState;\n    queue.isInitialized = true;\n  }\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  var didSkip = false;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      var remainingExpirationTime = queue.expirationTime;\n      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n        // Update the remaining expiration time.\n        queue.expirationTime = updateExpirationTime;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      // Continue to the next update.\n      update = update.next;\n      continue;\n    }\n\n    // This update does have sufficient priority.\n\n    // If no previous updates were skipped, drop this update from the queue by\n    // advancing the head of the list.\n    if (!didSkip) {\n      queue.first = update.next;\n      if (queue.first === null) {\n        queue.last = null;\n      }\n    }\n\n    // Process the update\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          // $FlowFixMe: Idk how to type this properly.\n          state = _assign({}, state, _partialState);\n        } else {\n          state = _assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    if (update.callback !== null) {\n      // Append to list of callbacks.\n      var _callbackList = queue.callbackList;\n      if (_callbackList === null) {\n        _callbackList = queue.callbackList = [];\n      }\n      _callbackList.push(update);\n    }\n    update = update.next;\n  }\n\n  if (queue.callbackList !== null) {\n    workInProgress.effectTag |= Callback;\n  } else if (queue.first === null && !queue.hasForceUpdate) {\n    // The queue is empty. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (!didSkip) {\n    didSkip = true;\n    queue.baseState = state;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\n\nfunction commitCallbacks(queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n  for (var i = 0; i < callbackList.length; i++) {\n    var update = callbackList[i];\n    var _callback = update.callback;\n    // This update might be processed again. Clear the callback so it's only\n    // called once.\n    update.callback = null;\n    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n    _callback.call(context);\n  }\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar startPhaseTimer$1 = ReactDebugFiberPerf$1.startPhaseTimer;\nvar stopPhaseTimer$1 = ReactDebugFiberPerf$1.stopPhaseTimer;\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\n{\n  var didWarnAboutStateAssignmentForComponent = {};\n\n  var warnOnInvalidCallback = function (callback, callerName) {\n    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nvar ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n  // Class component state updater\n  var updater = {\n    isMounted: isMounted,\n    enqueueSetState: function (instance, partialState, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueReplaceState: function (instance, state, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueForceUpdate: function (instance, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    }\n  };\n\n  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === 'function') {\n      {\n        startPhaseTimer$1(workInProgress, 'shouldComponentUpdate');\n      }\n      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n      {\n        stopPhaseTimer$1();\n      }\n\n      {\n        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');\n      }\n\n      return shouldUpdate;\n    }\n\n    if (type.prototype && type.prototype.isPureReactComponent) {\n      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName(workInProgress);\n      var renderPresent = instance.render;\n\n      if (!renderPresent) {\n        if (type.prototype && typeof type.prototype.render === 'function') {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n        } else {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n        }\n      }\n\n      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n      var noInstancePropTypes = !instance.propTypes;\n      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n      var noInstanceContextTypes = !instance.contextTypes;\n      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n      }\n      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n      var noInstanceDefaultProps = !instance.defaultProps;\n      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    var state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      invariant(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));\n    }\n    if (typeof instance.getChildContext === 'function') {\n      !(typeof workInProgress.type.childContextTypes === 'object') ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', getComponentName(workInProgress)) : void 0;\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var needsContext = isContextConsumer(workInProgress);\n    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n    var instance = new ctor(props, context);\n    adoptClassInstance(workInProgress, instance);\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    {\n      startPhaseTimer$1(workInProgress, 'componentWillMount');\n    }\n    var oldState = instance.state;\n    instance.componentWillMount();\n    {\n      stopPhaseTimer$1();\n    }\n\n    if (oldState !== instance.state) {\n      {\n        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress));\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n    {\n      startPhaseTimer$1(workInProgress, 'componentWillReceiveProps');\n    }\n    var oldState = instance.state;\n    instance.componentWillReceiveProps(newProps, newContext);\n    {\n      stopPhaseTimer$1();\n    }\n\n    if (instance.state !== oldState) {\n      {\n        var componentName = getComponentName(workInProgress) || 'Component';\n        if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n          didWarnAboutStateAssignmentForComponent[componentName] = true;\n        }\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, renderExpirationTime) {\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var state = instance.state || null;\n\n    var props = workInProgress.pendingProps;\n    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState = state;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    if (ReactFeatureFlags.enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n      workInProgress.internalContextTag |= AsyncUpdates;\n    }\n\n    if (typeof instance.componentWillMount === 'function') {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  // Called on a preexisting class instance. Returns false if a resumed render\n  // could be reused.\n  // function resumeMountClassInstance(\n  //   workInProgress: Fiber,\n  //   priorityLevel: PriorityLevel,\n  // ): boolean {\n  //   const instance = workInProgress.stateNode;\n  //   resetInputPointers(workInProgress, instance);\n\n  //   let newState = workInProgress.memoizedState;\n  //   let newProps = workInProgress.pendingProps;\n  //   if (!newProps) {\n  //     // If there isn't any new props, then we'll reuse the memoized props.\n  //     // This could be from already completed work.\n  //     newProps = workInProgress.memoizedProps;\n  //     invariant(\n  //       newProps != null,\n  //       'There should always be pending or memoized props. This error is ' +\n  //         'likely caused by a bug in React. Please file an issue.',\n  //     );\n  //   }\n  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  //   const oldContext = instance.context;\n  //   const oldProps = workInProgress.memoizedProps;\n\n  //   if (\n  //     typeof instance.componentWillReceiveProps === 'function' &&\n  //     (oldProps !== newProps || oldContext !== newContext)\n  //   ) {\n  //     callComponentWillReceiveProps(\n  //       workInProgress,\n  //       instance,\n  //       newProps,\n  //       newContext,\n  //     );\n  //   }\n\n  //   // Process the update queue before calling shouldComponentUpdate\n  //   const updateQueue = workInProgress.updateQueue;\n  //   if (updateQueue !== null) {\n  //     newState = processUpdateQueue(\n  //       workInProgress,\n  //       updateQueue,\n  //       instance,\n  //       newState,\n  //       newProps,\n  //       priorityLevel,\n  //     );\n  //   }\n\n  //   // TODO: Should we deal with a setState that happened after the last\n  //   // componentWillMount and before this componentWillMount? Probably\n  //   // unsupported anyway.\n\n  //   if (\n  //     !checkShouldComponentUpdate(\n  //       workInProgress,\n  //       workInProgress.memoizedProps,\n  //       newProps,\n  //       workInProgress.memoizedState,\n  //       newState,\n  //       newContext,\n  //     )\n  //   ) {\n  //     // Update the existing instance's state, props, and context pointers even\n  //     // though we're bailing out.\n  //     instance.props = newProps;\n  //     instance.state = newState;\n  //     instance.context = newContext;\n  //     return false;\n  //   }\n\n  //   // Update the input pointers now so that they are correct when we call\n  //   // componentWillMount\n  //   instance.props = newProps;\n  //   instance.state = newState;\n  //   instance.context = newContext;\n\n  //   if (typeof instance.componentWillMount === 'function') {\n  //     callComponentWillMount(workInProgress, instance);\n  //     // componentWillMount may have called setState. Process the update queue.\n  //     const newUpdateQueue = workInProgress.updateQueue;\n  //     if (newUpdateQueue !== null) {\n  //       newState = processUpdateQueue(\n  //         workInProgress,\n  //         newUpdateQueue,\n  //         instance,\n  //         newState,\n  //         newProps,\n  //         priorityLevel,\n  //       );\n  //     }\n  //   }\n\n  //   if (typeof instance.componentDidMount === 'function') {\n  //     workInProgress.effectTag |= Update;\n  //   }\n\n  //   instance.state = newState;\n\n  //   return true;\n  // }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, renderExpirationTime) {\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    if (!newProps) {\n      // If there aren't any new props, then we'll reuse the memoized props.\n      // This could be from already completed work.\n      newProps = oldProps;\n      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n    } else {\n      newState = oldState;\n    }\n\n    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n    if (shouldUpdate) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        {\n          startPhaseTimer$1(workInProgress, 'componentWillUpdate');\n        }\n        instance.componentWillUpdate(newProps, newState, newContext);\n        {\n          stopPhaseTimer$1();\n        }\n      }\n      if (typeof instance.componentDidUpdate === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    // resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\n// The Symbol used to tag the special React types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_PORTAL_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca; /**\n                                                                                                                          * Copyright (c) 2014-present, Facebook, Inc.\n                                                                                                                          *\n                                                                                                                          * This source code is licensed under the MIT license found in the\n                                                                                                                          * LICENSE file in the root directory of this source tree.\n                                                                                                                          *\n                                                                                                                          * \n                                                                                                                          */\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\n{\n  var didWarnAboutMaps = false;\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  var ownerHasKeyUseWarning = {};\n  var ownerHasFunctionTypeWarning = {};\n\n  var warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nvar ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE;\nvar REACT_CALL_TYPE;\nvar REACT_RETURN_TYPE;\nvar REACT_FRAGMENT_TYPE;\nif (typeof Symbol === 'function' && Symbol['for']) {\n  REACT_ELEMENT_TYPE = Symbol['for']('react.element');\n  REACT_CALL_TYPE = Symbol['for']('react.call');\n  REACT_RETURN_TYPE = Symbol['for']('react.return');\n  REACT_FRAGMENT_TYPE = Symbol['for']('react.fragment');\n} else {\n  REACT_ELEMENT_TYPE = 0xeac7;\n  REACT_CALL_TYPE = 0xeac8;\n  REACT_RETURN_TYPE = 0xeac9;\n  REACT_FRAGMENT_TYPE = 0xeacb;\n}\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var iteratorFn = ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n  return null;\n}\n\nfunction coerceRef(current, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function') {\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n        inst = ownerFiber.stateNode;\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldClone, shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    if (!shouldClone) {\n      // When we're reconciling in place we have a work in progress copy. We\n      // actually want the current copy. If there is no current copy, then we\n      // don't need to track deletion side-effects.\n      if (childToDelete.alternate === null) {\n        return;\n      }\n      childToDelete = childToDelete.alternate;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    if (shouldClone) {\n      var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n      clone.index = 0;\n      clone.sibling = null;\n      return clone;\n    } else {\n      // We override the expiration time even if it is earlier, because if\n      // we're reconciling at a later time that means that this was\n      // down-prioritized.\n      fiber.expirationTime = expirationTime;\n      fiber.effectTag = NoEffect;\n      fiber.index = 0;\n      fiber.sibling = null;\n      fiber.pendingProps = pendingProps;\n      return fiber;\n    }\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(current, element);\n      existing['return'] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n      created.ref = coerceRef(current, element);\n      created['return'] = returnFiber;\n      return created;\n    }\n  }\n\n  function updateCall(returnFiber, current, call, expirationTime) {\n    // TODO: Should this also compare handler to determine whether to reuse?\n    if (current === null || current.tag !== CallComponent) {\n      // Insert\n      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, call, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateReturn(returnFiber, current, returnNode, expirationTime) {\n    if (current === null || current.tag !== ReturnComponent) {\n      // Insert\n      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n      created.type = returnNode.value;\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, null, expirationTime);\n      existing.type = returnNode.value;\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);\n              _created['return'] = returnFiber;\n              return _created;\n            } else {\n              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);\n              _created2.ref = coerceRef(null, newChild);\n              _created2['return'] = returnFiber;\n              return _created2;\n            }\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);\n            _created3['return'] = returnFiber;\n            return _created3;\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);\n            _created4.type = newChild.value;\n            _created4['return'] = returnFiber;\n            return _created4;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);\n            _created5['return'] = returnFiber;\n            return _created5;\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);\n        _created6['return'] = returnFiber;\n        return _created6;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateCall(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            // Returns don't have keys. If the previous node is implicitly keyed\n            // we can continue to replace it without aborting even if it is not a\n            // yield.\n            if (key === null) {\n              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            // Returns don't have keys, so we neither have to check the old nor\n            // new node for the key. If both are returns, they match.\n            var _matchedFiber3 = existingChildren.get(newIdx) || null;\n            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber5 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_CALL_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === 'function') {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(child, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n      _created7.ref = coerceRef(currentFirstChild, element);\n      _created7['return'] = returnFiber;\n      return _created7;\n    }\n  }\n\n  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {\n    var key = call.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === CallComponent) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, call, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {\n    // There's no need to check for keys on yields since they're stateless.\n    var child = currentFirstChild;\n    if (child !== null) {\n      if (child.tag === ReturnComponent) {\n        deleteRemainingChildren(returnFiber, child.sibling);\n        var existing = useFiber(child, null, expirationTime);\n        existing.type = returnNode.value;\n        existing['return'] = returnFiber;\n        return existing;\n      } else {\n        deleteRemainingChildren(returnFiber, child);\n      }\n    }\n\n    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n    created.type = returnNode.value;\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (ReactFeatureFlags.enableReactFragment && typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n        case REACT_CALL_TYPE:\n          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_RETURN_TYPE:\n          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined') {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true, true);\n\nvar reconcileChildFibersInPlace = ChildReconciler(false, true);\n\nvar mountChildFibersInPlace = ChildReconciler(false, false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n\n  newChild['return'] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild['return'] = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\nvar cancelWorkTimer = ReactDebugFiberPerf$1.cancelWorkTimer;\n\n{\n  var warnedAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      useSyncScheduling = config.useSyncScheduling,\n      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n      pushHostContainer = hostContext.pushHostContainer;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n      resetHydrationState = hydrationContext.resetHydrationState,\n      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n  }\n\n  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n    } else if (current.child === workInProgress.child) {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n    } else {\n      // If, on the other hand, it is already using a clone, that means we've\n      // already begun some work on this tree and we can continue where we left\n      // off by reconciling against the existing children.\n      workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n    }\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = workInProgress.memoizedProps;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (ref !== null && (!current || current.ref !== ref)) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    var memoizedProps = workInProgress.memoizedProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextProps === null) {\n        nextProps = memoizedProps;\n      }\n    } else {\n      if (nextProps === null || memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren;\n\n    {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, renderExpirationTime) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushContextProvider(workInProgress);\n\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (!workInProgress.stateNode) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n        shouldUpdate = true;\n      } else {\n        invariant(false, 'Resuming work not yet implemented.');\n        // In a resume, we'll already have an instance we can reuse.\n        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n    }\n    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n  }\n\n  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    var nextChildren = void 0;\n    {\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = instance.render();\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, renderExpirationTime) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n      if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work that expires at this time.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      var element = state.element;\n      var root = workInProgress.stateNode;\n      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, element, renderExpirationTime);\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = memoizedProps;\n      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (nextProps === null || memoizedProps === nextProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n      // Down-prioritize the children.\n      workInProgress.expirationTime = Never;\n      // Bailout and come back to this fiber later.\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = workInProgress.memoizedProps;\n    }\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value;\n\n    {\n      if (fn.prototype && typeof fn.prototype.render === 'function') {\n        var componentName = getComponentName(workInProgress);\n        warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n      }\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, renderExpirationTime);\n      return finishClassComponent(current, workInProgress, true, hasContext);\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      {\n        var Component = workInProgress.type;\n\n        if (Component) {\n          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n        }\n        if (workInProgress.ref !== null) {\n          var info = '';\n          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || '';\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n          }\n          if (!warnedAboutStatelessRefs[warningKey]) {\n            warnedAboutStatelessRefs[warningKey] = true;\n            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCallComponent(current, workInProgress, renderExpirationTime) {\n    var nextCall = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextCall === null) {\n        nextCall = current && current.memoizedProps;\n        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {\n      nextCall = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextCall.children;\n\n    // The following is a fork of reconcileChildrenAtExpirationTime but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    } else if (current.child === workInProgress.child) {\n      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    } else {\n      workInProgress.stateNode = reconcileChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    }\n\n    memoizeProps(workInProgress, nextCall);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = current && current.memoizedProps;\n        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    {\n      cancelWorkTimer(workInProgress);\n    }\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    {\n      cancelWorkTimer(workInProgress);\n    }\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by processUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, renderExpirationTime) {\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(current, workInProgress, renderExpirationTime);\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(current, workInProgress, renderExpirationTime);\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(current, workInProgress, renderExpirationTime);\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(current, workInProgress, renderExpirationTime);\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function beginFailedWork(current, workInProgress, renderExpirationTime) {\n    // Push context providers here to avoid a push/pop context mismatch.\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    // Add an error effect so we can handle the error during the commit phase\n    workInProgress.effectTag |= Err;\n\n    // This is a weird case where we do \"resume\" work — work that failed on\n    // our first attempt. Because we no longer have a notion of \"progressed\n    // deletions,\" reset the child to the current child to make sure we delete\n    // it again. TODO: Find a better way to handle this, perhaps during a more\n    // general overhaul of error handling.\n    if (current === null) {\n      workInProgress.child = null;\n    } else if (workInProgress.child !== current.child) {\n      workInProgress.child = current.child;\n    }\n\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    // If we don't bail out, we're going be recomputing our children so we need\n    // to drop our effect list.\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    // Unmount the current children as if the component rendered null\n    var nextChildren = null;\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n\n    if (workInProgress.tag === ClassComponent) {\n      var instance = workInProgress.stateNode;\n      workInProgress.memoizedProps = instance.props;\n      workInProgress.memoizedState = instance.state;\n    }\n\n    return workInProgress.child;\n  }\n\n  return {\n    beginWork: beginWork,\n    beginFailedWork: beginFailedWork\n  };\n};\n\nvar ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {\n  var createInstance = config.createInstance,\n      createTextInstance = config.createTextInstance,\n      appendInitialChild = config.appendInitialChild,\n      finalizeInitialChildren = config.finalizeInitialChildren,\n      prepareUpdate = config.prepareUpdate,\n      mutation = config.mutation,\n      persistence = config.persistence;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n      popHostContext = hostContext.popHostContext,\n      getHostContext = hostContext.getHostContext,\n      popHostContainer = hostContext.popHostContainer;\n  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n      popHydrationState = hydrationContext.popHydrationState;\n\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // an UpdateAndPlacement.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllReturns(returns, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node['return'] = workInProgress;\n    }\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n        invariant(false, 'A call cannot have host component children.');\n      } else if (node.tag === ReturnComponent) {\n        returns.push(node.type);\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n    var call = workInProgress.memoizedProps;\n    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    // First step of the call has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage call represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CallHandlerPhase;\n\n    // Build up the returns.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var returns = [];\n    appendAllReturns(returns, workInProgress);\n    var fn = call.handler;\n    var props = call.props;\n    var nextChildren = fn(props, returns);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  var updateHostContainer = void 0;\n  var updateHostComponent = void 0;\n  var updateHostText = void 0;\n  if (mutation) {\n    if (ReactFeatureFlags.enableMutatingReconciler) {\n      // Mutation mode\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // TODO: Type this specific to this type of component.\n        workInProgress.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update. All the work is done in commitWork.\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // If the text differs, mark it as an update. All the work in done in commitWork.\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Mutating reconciler is disabled.');\n    }\n  } else if (persistence) {\n    if (ReactFeatureFlags.enablePersistentReconciler) {\n      // Persistent host tree mode\n      var cloneInstance = persistence.cloneInstance,\n          createContainerChildSet = persistence.createContainerChildSet,\n          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n          finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n      // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      };\n      updateHostContainer = function (workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        if (childrenUnchanged) {\n          // No changes, just reuse the existing instance.\n        } else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          if (finalizeContainerChildren(container, newChildSet)) {\n            markUpdate(workInProgress);\n          }\n          portalOrRoot.pendingChildren = newChildSet;\n          // If children might have changed, we have to add them all to the set.\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          // Schedule an update on the container to swap out the container.\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        var currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          var recyclableInstance = workInProgress.stateNode;\n          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          // If the text content differs, we'll create a new text instance for it.\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n          // This lets the parents know that at least one of their children has changed.\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Persistent reconciler is disabled.');\n    }\n  } else {\n    if (ReactFeatureFlags.enableNoopReconciler) {\n      // No host operations\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // Noop\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // Noop\n      };\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n\n  function completeWork(current, workInProgress, renderExpirationTime) {\n    // Get the latest props.\n    var newProps = workInProgress.pendingProps;\n    if (newProps === null) {\n      newProps = workInProgress.memoizedProps;\n    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {\n      // Reset the pending props, unless this was a down-prioritization.\n      workInProgress.pendingProps = null;\n    }\n\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent:\n        {\n          // We are leaving this subtree, so pop context if any.\n          popContextProvider(workInProgress);\n          return null;\n        }\n      case HostRoot:\n        {\n          popHostContainer(workInProgress);\n          popTopLevelContextObject(workInProgress);\n          var fiberRoot = workInProgress.stateNode;\n          if (fiberRoot.pendingContext) {\n            fiberRoot.context = fiberRoot.pendingContext;\n            fiberRoot.pendingContext = null;\n          }\n\n          if (current === null || current.child === null) {\n            // If we hydrated, pop so that we can delete any remaining children\n            // that weren't hydrated.\n            popHydrationState(workInProgress);\n            // This resets the hacky state to fix isMounted before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag &= ~Placement;\n          }\n          updateHostContainer(workInProgress);\n          return null;\n        }\n      case HostComponent:\n        {\n          popHostContext(workInProgress);\n          var rootContainerInstance = getRootHostContainer();\n          var type = workInProgress.type;\n          if (current !== null && workInProgress.stateNode != null) {\n            // If we have an alternate, that means this is an update and we need to\n            // schedule a side-effect to do the updates.\n            var oldProps = current.memoizedProps;\n            // If we get updated because one of our children updated, we don't\n            // have newProps so we'll have to reuse them.\n            // TODO: Split the update API as separate for the props vs. children.\n            // Even better would be if children weren't special cased at all tho.\n            var instance = workInProgress.stateNode;\n            var currentHostContext = getHostContext();\n            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          } else {\n            if (!newProps) {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n\n            var _currentHostContext = getHostContext();\n            // TODO: Move createInstance to beginWork and keep it on a context\n            // \"stack\" as the parent. Then append children as we go in beginWork\n            // or completeWork depending on we want to add then top->down or\n            // bottom->up. Top->down is faster in IE11.\n            var wasHydrated = popHydrationState(workInProgress);\n            if (wasHydrated) {\n              // TODO: Move this and createInstance step into the beginPhase\n              // to consolidate.\n              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                // If changes to the hydrated node needs to be applied at the\n                // commit-phase we mark this as such.\n                markUpdate(workInProgress);\n              }\n            } else {\n              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n              appendAllChildren(_instance, workInProgress);\n\n              // Certain renderers require commit-time effects for initial mount.\n              // (eg DOM renderer supports auto-focus for certain elements).\n              // Make sure such renderers get scheduled for later work.\n              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                markUpdate(workInProgress);\n              }\n              workInProgress.stateNode = _instance;\n            }\n\n            if (workInProgress.ref !== null) {\n              // If there is a ref on a host node we need to schedule a callback\n              markRef(workInProgress);\n            }\n          }\n          return null;\n        }\n      case HostText:\n        {\n          var newText = newProps;\n          if (current && workInProgress.stateNode != null) {\n            var oldText = current.memoizedProps;\n            // If we have an alternate, that means this is an update and we need\n            // to schedule a side-effect to do the updates.\n            updateHostText(current, workInProgress, oldText, newText);\n          } else {\n            if (typeof newText !== 'string') {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n            var _rootContainerInstance = getRootHostContainer();\n            var _currentHostContext2 = getHostContext();\n            var _wasHydrated = popHydrationState(workInProgress);\n            if (_wasHydrated) {\n              if (prepareToHydrateHostTextInstance(workInProgress)) {\n                markUpdate(workInProgress);\n              }\n            } else {\n              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n            }\n          }\n          return null;\n        }\n      case CallComponent:\n        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case Fragment:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\n\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\nvar startPhaseTimer$2 = ReactDebugFiberPerf$1.startPhaseTimer;\nvar stopPhaseTimer$2 = ReactDebugFiberPerf$1.stopPhaseTimer;\n\n\nvar ReactFiberCommitWork = function (config, captureError) {\n  var getPublicInstance = config.getPublicInstance,\n      mutation = config.mutation,\n      persistence = config.persistence;\n\n\n  {\n    var callComponentWillUnmountWithTimerInDev = function (current, instance) {\n      startPhaseTimer$2(current, 'componentWillUnmount');\n      instance.props = current.memoizedProps;\n      instance.state = current.memoizedState;\n      instance.componentWillUnmount();\n      stopPhaseTimer$2();\n    };\n  }\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimerInDev, null, current, instance);\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      {\n        invokeGuardedCallback$2(null, ref, null, null);\n        if (hasCaughtError$1()) {\n          var refError = clearCaughtError$1();\n          captureError(current, refError);\n        }\n      }\n    }\n  }\n\n  function commitLifeCycles(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var instance = finishedWork.stateNode;\n          if (finishedWork.effectTag & Update) {\n            if (current === null) {\n              {\n                startPhaseTimer$2(finishedWork, 'componentDidMount');\n              }\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidMount();\n              {\n                stopPhaseTimer$2();\n              }\n            } else {\n              var prevProps = current.memoizedProps;\n              var prevState = current.memoizedState;\n              {\n                startPhaseTimer$2(finishedWork, 'componentDidUpdate');\n              }\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidUpdate(prevProps, prevState);\n              {\n                stopPhaseTimer$2();\n              }\n            }\n          }\n          var updateQueue = finishedWork.updateQueue;\n          if (updateQueue !== null) {\n            commitCallbacks(updateQueue, instance);\n          }\n          return;\n        }\n      case HostRoot:\n        {\n          var _updateQueue = finishedWork.updateQueue;\n          if (_updateQueue !== null) {\n            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;\n            commitCallbacks(_updateQueue, _instance);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          var _instance2 = finishedWork.stateNode;\n\n          // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n          if (current === null && finishedWork.effectTag & Update) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance2, type, props, finishedWork);\n          }\n\n          return;\n        }\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          return;\n        }\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var instance = finishedWork.stateNode;\n      switch (finishedWork.tag) {\n        case HostComponent:\n          ref(getPublicInstance(instance));\n          break;\n        default:\n          ref(instance);\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      currentRef(null);\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === 'function') {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent:\n        {\n          safelyDetachRef(current);\n          var instance = current.stateNode;\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(current, instance);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          safelyDetachRef(current);\n          return;\n        }\n      case CallComponent:\n        {\n          commitNestedUnmounts(current.stateNode);\n          return;\n        }\n      case HostPortal:\n        {\n          // TODO: this is recursive.\n          // We are also not using this parent because\n          // the portal will get pushed immediately.\n          if (ReactFeatureFlags.enableMutatingReconciler && mutation) {\n            unmountHostComponents(current);\n          } else if (ReactFeatureFlags.enablePersistentReconciler && persistence) {\n            emptyPortalContainer(current);\n          }\n          return;\n        }\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (node.child !== null && (\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      !mutation || node.tag !== HostPortal)) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === root) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function detachFiber(current) {\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current['return'] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate['return'] = null;\n    }\n  }\n\n  if (!mutation) {\n    var commitContainer = void 0;\n    if (persistence) {\n      var replaceContainerChildren = persistence.replaceContainerChildren,\n          createContainerChildSet = persistence.createContainerChildSet;\n\n      var emptyPortalContainer = function (current) {\n        var portal = current.stateNode;\n        var containerInfo = portal.containerInfo;\n\n        var emptyChildSet = createContainerChildSet(containerInfo);\n        replaceContainerChildren(containerInfo, emptyChildSet);\n      };\n      commitContainer = function (finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n          case HostComponent:\n            {\n              return;\n            }\n          case HostText:\n            {\n              return;\n            }\n          case HostRoot:\n          case HostPortal:\n            {\n              var portalOrRoot = finishedWork.stateNode;\n              var containerInfo = portalOrRoot.containerInfo,\n                  _pendingChildren = portalOrRoot.pendingChildren;\n\n              replaceContainerChildren(containerInfo, _pendingChildren);\n              return;\n            }\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      };\n    } else {\n      commitContainer = function (finishedWork) {\n        // Noop\n      };\n    }\n    if (ReactFeatureFlags.enablePersistentReconciler || ReactFeatureFlags.enableNoopReconciler) {\n      return {\n        commitResetTextContent: function (finishedWork) {},\n        commitPlacement: function (finishedWork) {},\n        commitDeletion: function (current) {\n          // Detach refs and call componentWillUnmount() on the whole subtree.\n          commitNestedUnmounts(current);\n          detachFiber(current);\n        },\n        commitWork: function (current, finishedWork) {\n          commitContainer(finishedWork);\n        },\n\n        commitLifeCycles: commitLifeCycles,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    } else if (persistence) {\n      invariant(false, 'Persistent reconciler is disabled.');\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n  var commitMount = mutation.commitMount,\n      commitUpdate = mutation.commitUpdate,\n      resetTextContent = mutation.resetTextContent,\n      commitTextUpdate = mutation.commitTextUpdate,\n      appendChild = mutation.appendChild,\n      appendChildToContainer = mutation.appendChildToContainer,\n      insertBefore = mutation.insertBefore,\n      insertInContainerBefore = mutation.insertInContainerBefore,\n      removeChild = mutation.removeChild,\n      removeChildFromContainer = mutation.removeChildFromContainer;\n\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent['return'];\n    }\n    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  function isHostParent(fiber) {\n    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node['return'] === null || isHostParent(node['return'])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child['return'] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === finishedWork) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node['return'];\n        findParent: while (true) {\n          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          switch (parent.tag) {\n            case HostComponent:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent['return'];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === current) {\n          return;\n        }\n        node = node['return'];\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n    detachFiber(current);\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          return;\n        }\n      case HostComponent:\n        {\n          var instance = finishedWork.stateNode;\n          if (instance != null) {\n            // Commit the work prepared earlier.\n            var newProps = finishedWork.memoizedProps;\n            // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n            var oldProps = current !== null ? current.memoizedProps : newProps;\n            var type = finishedWork.type;\n            // TODO: Type the updateQueue to be specific to host components.\n            var updatePayload = finishedWork.updateQueue;\n            finishedWork.updateQueue = null;\n            if (updatePayload !== null) {\n              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n            }\n          }\n          return;\n        }\n      case HostText:\n        {\n          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var textInstance = finishedWork.stateNode;\n          var newText = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldText = current !== null ? current.memoizedProps : newText;\n          commitTextUpdate(textInstance, oldText, newText);\n          return;\n        }\n      case HostRoot:\n        {\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitResetTextContent(current) {\n    resetTextContent(current.stateNode);\n  }\n\n  if (ReactFeatureFlags.enableMutatingReconciler) {\n    return {\n      commitResetTextContent: commitResetTextContent,\n      commitPlacement: commitPlacement,\n      commitDeletion: commitDeletion,\n      commitWork: commitWork,\n      commitLifeCycles: commitLifeCycles,\n      commitAttachRef: commitAttachRef,\n      commitDetachRef: commitDetachRef\n    };\n  } else {\n    invariant(false, 'Mutating reconciler is disabled.');\n  }\n};\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function (config) {\n  var getChildHostContext = config.getChildHostContext,\n      getRootHostContext = config.getRootHostContext;\n\n\n  var contextStackCursor = createCursor(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n  function requiredContext(c) {\n    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push(rootInstanceStackCursor, nextRootInstance, fiber);\n\n    var nextRootContext = getRootHostContext(nextRootInstance);\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n    pop(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n  }\n\n  function resetHostContainer() {\n    contextStackCursor.current = NO_CONTEXT;\n    rootInstanceStackCursor.current = NO_CONTEXT;\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext,\n    resetHostContainer: resetHostContainer\n  };\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar ReactFiberHydrationContext = function (config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      hydration = config.hydration;\n\n  // If this doesn't have hydration mode.\n\n  if (!hydration) {\n    return {\n      enterHydrationState: function () {\n        return false;\n      },\n      resetHydrationState: function () {},\n      tryToClaimNextHydratableInstance: function () {},\n      prepareToHydrateHostInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      prepareToHydrateHostTextInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      popHydrationState: function (fiber) {\n        return false;\n      }\n    };\n  }\n\n  var canHydrateInstance = hydration.canHydrateInstance,\n      canHydrateTextInstance = hydration.canHydrateTextInstance,\n      getNextHydratableSibling = hydration.getNextHydratableSibling,\n      getFirstHydratableChild = hydration.getFirstHydratableChild,\n      hydrateInstance = hydration.hydrateInstance,\n      hydrateTextInstance = hydration.hydrateTextInstance,\n      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n      didNotHydrateInstance = hydration.didNotHydrateInstance,\n      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n          break;\n        case HostComponent:\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion();\n    childToDelete.stateNode = instance;\n    childToDelete['return'] = returnFiber;\n    childToDelete.effectTag = Deletion;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement;\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            switch (fiber.tag) {\n              case HostComponent:\n                var type = fiber.type;\n                var props = fiber.pendingProps;\n                didNotFindHydratableContainerInstance(parentContainer, type, props);\n                break;\n              case HostText:\n                var text = fiber.pendingProps;\n                didNotFindHydratableContainerTextInstance(parentContainer, text);\n                break;\n            }\n            break;\n          }\n        case HostComponent:\n          {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            switch (fiber.tag) {\n              case HostComponent:\n                var _type = fiber.type;\n                var _props = fiber.pendingProps;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                break;\n              case HostText:\n                var _text = fiber.pendingProps;\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                break;\n            }\n            break;\n          }\n        default:\n          return;\n      }\n    }\n  }\n\n  function canHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent:\n        {\n          var type = fiber.type;\n          var props = fiber.pendingProps;\n          return canHydrateInstance(nextInstance, type, props);\n        }\n      case HostText:\n        {\n          var text = fiber.pendingProps;\n          return canHydrateTextInstance(nextInstance, text);\n        }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!canHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !canHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    fiber.stateNode = nextInstance;\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var textContent = fiber.memoizedProps;\n    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n    {\n      if (shouldUpdate) {\n        // We assume that prepareToHydrateHostTextInstance is called in a context where the\n        // hydration parent is the parent host component of this host text.\n        var returnFiber = hydrationParentFiber;\n        if (returnFiber !== null) {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                break;\n              }\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                break;\n              }\n          }\n        }\n      }\n    }\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n      parent = parent['return'];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\nvar defaultShowDialog = function (capturedError) {\n  return true;\n};\n\nvar showDialog = defaultShowDialog;\n\nfunction logCapturedError(capturedError) {\n  var logError = showDialog(capturedError);\n\n  // Allow injected showDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\nvar recordEffect = ReactDebugFiberPerf$1.recordEffect;\nvar recordScheduleUpdate = ReactDebugFiberPerf$1.recordScheduleUpdate;\nvar startWorkTimer = ReactDebugFiberPerf$1.startWorkTimer;\nvar stopWorkTimer = ReactDebugFiberPerf$1.stopWorkTimer;\nvar stopFailedWorkTimer = ReactDebugFiberPerf$1.stopFailedWorkTimer;\nvar startWorkLoopTimer = ReactDebugFiberPerf$1.startWorkLoopTimer;\nvar stopWorkLoopTimer = ReactDebugFiberPerf$1.stopWorkLoopTimer;\nvar startCommitTimer = ReactDebugFiberPerf$1.startCommitTimer;\nvar stopCommitTimer = ReactDebugFiberPerf$1.stopCommitTimer;\nvar startCommitHostEffectsTimer = ReactDebugFiberPerf$1.startCommitHostEffectsTimer;\nvar stopCommitHostEffectsTimer = ReactDebugFiberPerf$1.stopCommitHostEffectsTimer;\nvar startCommitLifeCyclesTimer = ReactDebugFiberPerf$1.startCommitLifeCyclesTimer;\nvar stopCommitLifeCyclesTimer = ReactDebugFiberPerf$1.stopCommitLifeCyclesTimer;\n\n\n{\n  var didWarnAboutStateTransition = false;\n  var didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  var warnAboutUpdateOnUnmounted = function (fiber) {\n    var componentName = getComponentName(fiber) || 'ReactClass';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease ' + 'check the code for the %s component.', componentName);\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  var warnAboutInvalidUpdates = function (instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\nvar ReactFiberScheduler = function (config) {\n  var hostContext = ReactFiberHostContext(config);\n  var hydrationContext = ReactFiberHydrationContext(config);\n  var popHostContainer = hostContext.popHostContainer,\n      popHostContext = hostContext.popHostContext,\n      resetHostContainer = hostContext.resetHostContainer;\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n      beginWork = _ReactFiberBeginWork.beginWork,\n      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n      completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n      commitPlacement = _ReactFiberCommitWork.commitPlacement,\n      commitDeletion = _ReactFiberCommitWork.commitDeletion,\n      commitWork = _ReactFiberCommitWork.commitWork,\n      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var now = config.now,\n      scheduleDeferredCallback = config.scheduleDeferredCallback,\n      useSyncScheduling = config.useSyncScheduling,\n      prepareForCommit = config.prepareForCommit,\n      resetAfterCommit = config.resetAfterCommit;\n\n  // Represents the current time in ms.\n\n  var startTime = now();\n  var mostRecentCurrentTime = msToExpirationTime(0);\n\n  // Represents the expiration time that incoming updates should use. (If this\n  // is NoWork, use the default strategy: async updates in async mode, sync\n  // updates in sync mode.)\n  var expirationContext = NoWork;\n\n  var isWorking = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextRoot = null;\n  // The time at which we're currently rendering work.\n  var nextRenderExpirationTime = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  // Keep track of which fibers have captured an error that need to be handled.\n  // Work is removed from this collection after componentDidCatch is called.\n  var capturedErrors = null;\n  // Keep track of which fibers have failed during the current batch of work.\n  // This is a different set than capturedErrors, because it is not reset until\n  // the end of the batch. This is needed to propagate errors correctly if a\n  // subtree fails more than once.\n  var failedBoundaries = null;\n  // Error boundaries that captured an error during the current commit.\n  var commitPhaseBoundaries = null;\n  var firstUncaughtError = null;\n  var didFatal = false;\n\n  var isCommitting = false;\n  var isUnmounting = false;\n\n  function resetContextStack() {\n    // Reset the stack\n    reset();\n    // Reset the cursors\n    resetContext();\n    resetHostContainer();\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n        recordEffect();\n      }\n\n      var effectTag = nextEffect.effectTag;\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n      switch (primaryEffectTag) {\n        case Placement:\n          {\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            // TODO: findDOMNode doesn't rely on this any more but isMounted\n            // does and isMounted is deprecated anyway so we should be able\n            // to kill this.\n            nextEffect.effectTag &= ~Placement;\n            break;\n          }\n        case PlacementAndUpdate:\n          {\n            // Placement\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            nextEffect.effectTag &= ~Placement;\n\n            // Update\n            var _current = nextEffect.alternate;\n            commitWork(_current, nextEffect);\n            break;\n          }\n        case Update:\n          {\n            var _current2 = nextEffect.alternate;\n            commitWork(_current2, nextEffect);\n            break;\n          }\n        case Deletion:\n          {\n            isUnmounting = true;\n            commitDeletion(nextEffect);\n            isUnmounting = false;\n            break;\n          }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n  }\n\n  function commitAllLifeCycles() {\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        {\n          recordEffect();\n        }\n        var current = nextEffect.alternate;\n        commitLifeCycles(current, nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        {\n          recordEffect();\n        }\n        commitAttachRef(nextEffect);\n      }\n\n      if (effectTag & Err) {\n        {\n          recordEffect();\n        }\n        commitErrorHandling(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function commitRoot(finishedWork) {\n    // We keep track of this so that captureError can collect any boundaries\n    // that capture an error during the commit phase. The reason these aren't\n    // local to this function is because errors that occur during cWU are\n    // captured elsewhere, to prevent the unmount from being interrupted.\n    isWorking = true;\n    isCommitting = true;\n    {\n      startCommitTimer();\n    }\n\n    var root = finishedWork.stateNode;\n    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    root.isReadyForCommit = false;\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    {\n      startCommitHostEffectsTimer();\n    }\n    while (nextEffect !== null) {\n      var didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    {\n      stopCommitHostEffectsTimer();\n    }\n\n    resetAfterCommit();\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    {\n      startCommitLifeCyclesTimer();\n    }\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error2 = void 0;\n      {\n        invokeGuardedCallback(null, commitAllLifeCycles, null);\n        if (hasCaughtError()) {\n          _didError = true;\n          _error2 = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error2);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    {\n      stopCommitLifeCyclesTimer();\n      stopCommitTimer();\n    }\n    if (typeof onCommitRoot === 'function') {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n    }\n\n    // If we caught any errors during this commit, schedule their boundaries\n    // to update.\n    if (commitPhaseBoundaries) {\n      commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n      commitPhaseBoundaries = null;\n    }\n\n    if (firstUncaughtError !== null) {\n      var _error3 = firstUncaughtError;\n      firstUncaughtError = null;\n      onUncaughtError(_error3);\n    }\n\n    var remainingTime = root.current.expirationTime;\n\n    if (remainingTime === NoWork) {\n      capturedErrors = null;\n      failedBoundaries = null;\n    }\n\n    return remainingTime;\n  }\n\n  function resetExpirationTime(workInProgress, renderTime) {\n    if (renderTime !== Never && workInProgress.expirationTime === Never) {\n      // The children of this component are hidden. Don't bubble their\n      // expiration times.\n      return;\n    }\n\n    // Check for pending updates.\n    var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n    // TODO: Calls need to visit stateNode\n\n    // Bubble up the earliest expiration time.\n    var child = workInProgress.child;\n    while (child !== null) {\n      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n      }\n      var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n      {\n        ReactDebugCurrentFiber.resetCurrentFiber();\n      }\n\n      var returnFiber = workInProgress['return'];\n      var siblingFiber = workInProgress.sibling;\n\n      resetExpirationTime(workInProgress, nextRenderExpirationTime);\n\n      if (next !== null) {\n        {\n          stopWorkTimer(workInProgress);\n        }\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      {\n        stopWorkTimer(workInProgress);\n      }\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        var root = workInProgress.stateNode;\n        root.isReadyForCommit = true;\n        return null;\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    {\n      startWorkTimer(workInProgress);\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n    var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function performFailedUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    {\n      startWorkTimer(workInProgress);\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function workLoop(expirationTime) {\n    if (capturedErrors !== null) {\n      // If there are unhandled errors, switch to the slow work loop.\n      // TODO: How to avoid this check in the fast path? Maybe the renderer\n      // could keep track of which roots have unhandled errors and call a\n      // forked version of renderRoot.\n      slowWorkLoopThatChecksForFailedWork(expirationTime);\n      return;\n    }\n    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n  function slowWorkLoopThatChecksForFailedWork(expirationTime) {\n    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    }\n  }\n\n  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {\n    // We're going to restart the error boundary that captured the error.\n    // Conceptually, we're unwinding the stack. We need to unwind the\n    // context stack, too.\n    unwindContexts(failedWork, boundary);\n\n    // Restart the error boundary using a forked version of\n    // performUnitOfWork that deletes the boundary's children. The entire\n    // failed subree will be unmounted. During the commit phase, a special\n    // lifecycle method is called on the error boundary, which triggers\n    // a re-render.\n    nextUnitOfWork = performFailedUnitOfWork(boundary);\n\n    // Continue working.\n    workLoop(expirationTime);\n  }\n\n  function renderRoot(root, expirationTime) {\n    {\n      startWorkLoopTimer();\n    }\n\n    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    isWorking = true;\n\n    // We're about to mutate the work-in-progress tree. If the root was pending\n    // commit, it no longer is: we'll need to complete it again.\n    root.isReadyForCommit = false;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {\n      // This is a restart. Reset the stack.\n      resetContextStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);\n    }\n\n    var didError = false;\n    var error = null;\n    {\n      invokeGuardedCallback(null, workLoop, null, expirationTime);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n\n    // An error was thrown during the render phase.\n    while (didError) {\n      if (didFatal) {\n        // This was a fatal error. Don't attempt to recover from it.\n        firstUncaughtError = error;\n        break;\n      }\n\n      var failedWork = nextUnitOfWork;\n      if (failedWork === null) {\n        // An error was thrown but there's no current unit of work. This can\n        // happen during the commit phase if there's a bug in the renderer.\n        didFatal = true;\n        continue;\n      }\n\n      // \"Capture\" the error by finding the nearest boundary. If there is no\n      // error boundary, we use the root.\n      var boundary = captureError(failedWork, error);\n      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n      if (didFatal) {\n        // The error we just captured was a fatal error. This happens\n        // when the error propagates to the root more than once.\n        continue;\n      }\n\n      didError = false;\n      error = null;\n      {\n        invokeGuardedCallback(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n          continue;\n        }\n      }\n      // We're finished working. Exit the error loop.\n      break;\n    }\n\n    var uncaughtError = firstUncaughtError;\n\n    // We're done performing work. Time to clean up.\n    isWorking = false;\n    didFatal = false;\n    firstUncaughtError = null;\n\n    {\n      stopWorkLoopTimer();\n    }\n\n    if (uncaughtError !== null) {\n      onUncaughtError(uncaughtError);\n    }\n\n    return root.isReadyForCommit ? root.current.alternate : null;\n  }\n\n  // Returns the boundary that captured the error, or null if the error is ignored\n  function captureError(failedWork, error) {\n    // It is no longer valid because we exited the user code.\n    ReactCurrentOwner.current = null;\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n\n    // Search for the nearest error boundary.\n    var boundary = null;\n\n    // Passed to logCapturedError()\n    var errorBoundaryFound = false;\n    var willRetry = false;\n    var errorBoundaryName = null;\n\n    // Host containers are a special case. If the failed work itself is a host\n    // container, then it acts as its own boundary. In all other cases, we\n    // ignore the work itself and only search through the parents.\n    if (failedWork.tag === HostRoot) {\n      boundary = failedWork;\n\n      if (isFailedBoundary(failedWork)) {\n        // If this root already failed, there must have been an error when\n        // attempting to unmount it. This is a worst-case scenario and\n        // should only be possible if there's a bug in the renderer.\n        didFatal = true;\n      }\n    } else {\n      var node = failedWork['return'];\n      while (node !== null && boundary === null) {\n        if (node.tag === ClassComponent) {\n          var instance = node.stateNode;\n          if (typeof instance.componentDidCatch === 'function') {\n            errorBoundaryFound = true;\n            errorBoundaryName = getComponentName(node);\n\n            // Found an error boundary!\n            boundary = node;\n            willRetry = true;\n          }\n        } else if (node.tag === HostRoot) {\n          // Treat the root like a no-op error boundary\n          boundary = node;\n        }\n\n        if (isFailedBoundary(node)) {\n          // This boundary is already in a failed state.\n\n          // If we're currently unmounting, that means this error was\n          // thrown while unmounting a failed subtree. We should ignore\n          // the error.\n          if (isUnmounting) {\n            return null;\n          }\n\n          // If we're in the commit phase, we should check to see if\n          // this boundary already captured an error during this commit.\n          // This case exists because multiple errors can be thrown during\n          // a single commit without interruption.\n          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n            // If so, we should ignore this error.\n            return null;\n          }\n\n          // The error should propagate to the next boundary -— we keep looking.\n          boundary = null;\n          willRetry = false;\n        }\n\n        node = node['return'];\n      }\n    }\n\n    if (boundary !== null) {\n      // Add to the collection of failed boundaries. This lets us know that\n      // subsequent errors in this subtree should propagate to the next boundary.\n      if (failedBoundaries === null) {\n        failedBoundaries = new Set();\n      }\n      failedBoundaries.add(boundary);\n\n      // This method is unsafe outside of the begin and complete phases.\n      // We might be in the commit phase when an error is captured.\n      // The risk is that the return path from this Fiber may not be accurate.\n      // That risk is acceptable given the benefit of providing users more context.\n      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n      var _componentName = getComponentName(failedWork);\n\n      // Add to the collection of captured errors. This is stored as a global\n      // map of errors and their component stack location keyed by the boundaries\n      // that capture them. We mostly use this Map as a Set; it's a Map only to\n      // avoid adding a field to Fiber to store the error.\n      if (capturedErrors === null) {\n        capturedErrors = new Map();\n      }\n\n      var capturedError = {\n        componentName: _componentName,\n        componentStack: _componentStack,\n        error: error,\n        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n        errorBoundaryFound: errorBoundaryFound,\n        errorBoundaryName: errorBoundaryName,\n        willRetry: willRetry\n      };\n\n      capturedErrors.set(boundary, capturedError);\n\n      try {\n        logCapturedError(capturedError);\n      } catch (e) {\n        // Prevent cycle if logCapturedError() throws.\n        // A cycle may still occur if logCapturedError renders a component that throws.\n        console.error(e);\n      }\n\n      // If we're in the commit phase, defer scheduling an update on the\n      // boundary until after the commit is complete\n      if (isCommitting) {\n        if (commitPhaseBoundaries === null) {\n          commitPhaseBoundaries = new Set();\n        }\n        commitPhaseBoundaries.add(boundary);\n      } else {\n        // Otherwise, schedule an update now.\n        // TODO: Is this actually necessary during the render phase? Is it\n        // possible to unwind and continue rendering at the same priority,\n        // without corrupting internal state?\n        scheduleErrorRecovery(boundary);\n      }\n      return boundary;\n    } else if (firstUncaughtError === null) {\n      // If no boundary is found, we'll need to throw the error\n      firstUncaughtError = error;\n    }\n    return null;\n  }\n\n  function hasCapturedError(fiber) {\n    // TODO: capturedErrors should store the boundary instance, to avoid needing\n    // to check the alternate.\n    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n  }\n\n  function isFailedBoundary(fiber) {\n    // TODO: failedBoundaries should store the boundary instance, to avoid\n    // needing to check the alternate.\n    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n  }\n\n  function commitErrorHandling(effectfulFiber) {\n    var capturedError = void 0;\n    if (capturedErrors !== null) {\n      capturedError = capturedErrors.get(effectfulFiber);\n      capturedErrors['delete'](effectfulFiber);\n      if (capturedError == null) {\n        if (effectfulFiber.alternate !== null) {\n          effectfulFiber = effectfulFiber.alternate;\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n        }\n      }\n    }\n\n    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    switch (effectfulFiber.tag) {\n      case ClassComponent:\n        var instance = effectfulFiber.stateNode;\n\n        var info = {\n          componentStack: capturedError.componentStack\n        };\n\n        // Allow the boundary to handle the error, usually by scheduling\n        // an update to itself\n        instance.componentDidCatch(capturedError.error, info);\n        return;\n      case HostRoot:\n        if (firstUncaughtError === null) {\n          firstUncaughtError = capturedError.error;\n        }\n        return;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function unwindContexts(from, to) {\n    var node = from;\n    while (node !== null) {\n      switch (node.tag) {\n        case ClassComponent:\n          popContextProvider(node);\n          break;\n        case HostComponent:\n          popHostContext(node);\n          break;\n        case HostRoot:\n          popHostContainer(node);\n          break;\n        case HostPortal:\n          popHostContainer(node);\n          break;\n      }\n      if (node === to || node.alternate === to) {\n        {\n          stopFailedWorkTimer(node);\n        }\n        break;\n      } else {\n        stopWorkTimer(node);\n      }\n      node = node['return'];\n    }\n  }\n\n  function computeAsyncExpiration() {\n    // Given the current clock time, returns an expiration time. We use rounding\n    // to batch like updates together.\n    // Should complete within ~1000ms. 1200ms max.\n    var currentTime = recalculateCurrentTime();\n    var expirationMs = 1000;\n    var bucketSizeMs = 200;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  function computeExpirationForFiber(fiber) {\n    var expirationTime = void 0;\n    if (expirationContext !== NoWork) {\n      // An explicit expiration context was set;\n      expirationTime = expirationContext;\n    } else if (isWorking) {\n      if (isCommitting) {\n        // Updates that occur during the commit phase should have sync priority\n        // by default.\n        expirationTime = Sync;\n      } else {\n        // Updates during the render phase should expire at the same time as\n        // the work that is being rendered.\n        expirationTime = nextRenderExpirationTime;\n      }\n    } else {\n      // No explicit expiration context was set, and we're not currently\n      // performing work. Calculate a new expiration time.\n      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {\n        // This is a sync update\n        expirationTime = Sync;\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration();\n      }\n    }\n    return expirationTime;\n  }\n\n  function scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    {\n      recordScheduleUpdate();\n    }\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node['return'] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n          if (!isWorking && root === nextRoot && expirationTime <= nextRenderExpirationTime) {\n            // This is an interruption. Restart the root from the top.\n            nextRoot = null;\n            nextUnitOfWork = null;\n            nextRenderExpirationTime = NoWork;\n          }\n          requestWork(root, expirationTime);\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber);\n            }\n          }\n          return;\n        }\n      }\n      node = node['return'];\n    }\n  }\n\n  function scheduleErrorRecovery(fiber) {\n    scheduleWorkImpl(fiber, Sync, true);\n  }\n\n  function recalculateCurrentTime() {\n    // Subtract initial time so it fits inside 32bits\n    var ms = now() - startTime;\n    mostRecentCurrentTime = msToExpirationTime(ms);\n    return mostRecentCurrentTime;\n  }\n\n  function deferredUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = computeAsyncExpiration();\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  function syncUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = Sync;\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  // TODO: Everything below this is written as if it has been lifted to the\n  // renderers. I'll do this in a follow-up.\n\n  // Linked-list of roots\n  var firstScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  var isCallbackScheduled = false;\n  var isRendering = false;\n  var nextFlushedRoot = null;\n  var nextFlushedExpirationTime = NoWork;\n  var deadlineDidExpire = false;\n  var hasUnhandledError = false;\n  var unhandledError = null;\n  var deadline = null;\n\n  var isBatchingUpdates = false;\n  var isUnbatchingUpdates = false;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n\n  var timeHeuristicForUnitOfWork = 1;\n\n  // requestWork is called by the scheduler whenever a root receives an update.\n  // It's up to the renderer to call renderRoot at some point in the future.\n  function requestWork(root, expirationTime) {\n    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n    }\n\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        performWorkOnRoot(root, Sync);\n      }\n      return;\n    }\n\n    // TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performWork(Sync, null);\n    } else if (!isCallbackScheduled) {\n      isCallbackScheduled = true;\n      scheduleDeferredCallback(performAsyncWork);\n    }\n  }\n\n  function findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          // This root no longer has work. Remove it from the scheduler.\n\n          // TODO: This check is redudant, but Flow is confused by the branch\n          // below where we set lastScheduledRoot to null, even though we break\n          // from the loop right after.\n          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          if (root === root.nextScheduledRoot) {\n            // This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            // This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            // This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n            // Update the priority, if it's higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {\n      nestedUpdateCount++;\n    } else {\n      // Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\n\n  function performAsyncWork(dl) {\n    performWork(NoWork, dl);\n  }\n\n  function performWork(minExpirationTime, dl) {\n    deadline = dl;\n\n    // Keep working on roots until there's no more work, or until the we reach\n    // the deadlne.\n    findHighestPriorityRoot();\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      // Find the next highest priority work.\n      findHighestPriorityRoot();\n    }\n\n    // We're done flushing work. Either we ran out of time in this callback,\n    // or there's no more work left with sufficient priority.\n\n    // If we're inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      isCallbackScheduled = false;\n    }\n    // If there's work left over, schedule a new callback.\n    if (nextFlushedRoot !== null && !isCallbackScheduled) {\n      isCallbackScheduled = true;\n      scheduleDeferredCallback(performAsyncWork);\n    }\n\n    // Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n    nestedUpdateCount = 0;\n\n    if (hasUnhandledError) {\n      var _error4 = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw _error4;\n    }\n  }\n\n  function performWorkOnRoot(root, expirationTime) {\n    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    isRendering = true;\n\n    // Check if this is async work or sync/expired work.\n    // TODO: Pass current time as argument to renderRoot, commitRoot\n    if (expirationTime <= recalculateCurrentTime()) {\n      // Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(finishedWork);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime);\n        if (finishedWork !== null) {\n          // We've completed the root. Commit it.\n          root.remainingExpirationTime = commitRoot(finishedWork);\n        }\n      }\n    } else {\n      // Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(_finishedWork);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime);\n        if (_finishedWork !== null) {\n          // We've completed the root. Check the deadline one more time\n          // before committing.\n          if (!shouldYield()) {\n            // Still time left. Commit the root.\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } else {\n            // There's no time left. Mark this root as complete. We'll come\n            // back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n    isRendering = false;\n  }\n\n  // When working on async work, the reconciler asks the renderer if it should\n  // yield execution. For DOM, we implement this with requestIdleCallback.\n  function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }\n\n  // TODO: Not happy about this hook. Conceptually, renderRoot should return a\n  // tuple of (isReadyForCommit, didError, error)\n  function onUncaughtError(error) {\n    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    // Unschedule this root so we don't work on it again until there's\n    // another update.\n    nextFlushedRoot.remainingExpirationTime = NoWork;\n    if (!hasUnhandledError) {\n      hasUnhandledError = true;\n      unhandledError = error;\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performWork(Sync, null);\n      }\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function unbatchedUpdates(fn) {\n    if (isBatchingUpdates && !isUnbatchingUpdates) {\n      isUnbatchingUpdates = true;\n      try {\n        return fn();\n      } finally {\n        isUnbatchingUpdates = false;\n      }\n    }\n    return fn();\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not within\n  // the reconciler.\n  function flushSync(fn) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return syncUpdates(fn);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n      performWork(Sync, null);\n    }\n  }\n\n  return {\n    computeAsyncExpiration: computeAsyncExpiration,\n    computeExpirationForFiber: computeExpirationForFiber,\n    scheduleWork: scheduleWork,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    deferredUpdates: deferredUpdates\n  };\n};\n\n{\n  var didWarnAboutNestedUpdates = false;\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n}\n\nvar ReactFiberReconciler = function (config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,\n      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n      scheduleWork = _ReactFiberScheduler.scheduleWork,\n      batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n      flushSync = _ReactFiberScheduler.flushSync,\n      deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n  function scheduleTopLevelUpdate(current, element, callback) {\n    {\n      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n        didWarnAboutNestedUpdates = true;\n        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n      }\n    }\n\n    callback = callback === undefined ? null : callback;\n    {\n      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n    }\n\n    var expirationTime = void 0;\n    // Check if the top-level element is an async wrapper component. If so,\n    // treat updates to the root as async. This is a bit weird but lets us\n    // avoid a separate `renderAsync` API.\n    if (ReactFeatureFlags.enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {\n      expirationTime = computeAsyncExpiration();\n    } else {\n      expirationTime = computeExpirationForFiber(current);\n    }\n\n    var update = {\n      expirationTime: expirationTime,\n      partialState: { element: element },\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      nextCallback: null,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n  }\n\n  return {\n    createContainer: function (containerInfo, hydrate) {\n      return createFiberRoot(containerInfo, hydrate);\n    },\n    updateContainer: function (element, container, parentComponent, callback) {\n      // TODO: If this is a nested container, this won't be the root.\n      var current = container.current;\n\n      {\n        if (ReactFiberInstrumentation_1.debugTool) {\n          if (current.alternate === null) {\n            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n          } else if (element === null) {\n            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n          } else {\n            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n          }\n        }\n      }\n\n      var context = getContextForSubtree(parentComponent);\n      if (container.context === null) {\n        container.context = context;\n      } else {\n        container.pendingContext = context;\n      }\n\n      scheduleTopLevelUpdate(current, element, callback);\n    },\n\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function (container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n    findHostInstance: function (fiber) {\n      var hostFiber = findCurrentHostFiber(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    findHostInstanceWithNoPortals: function (fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    }\n  };\n};\n\nvar ReactFiberReconciler$1 = Object.freeze({\n\tdefault: ReactFiberReconciler\n});\n\nvar ReactFiberReconciler$2 = ( ReactFiberReconciler$1 && ReactFiberReconciler ) || ReactFiberReconciler$1;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n// TODO: bundle Flow types with the package.\n\n\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactReconciler = ReactFiberReconciler$2['default'] ? ReactFiberReconciler$2['default'] : ReactFiberReconciler$2;\n\nmodule.exports = reactReconciler;\n\nreturn ($$$reconciler || ($$$reconciler = module.exports))(config);\n};\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}