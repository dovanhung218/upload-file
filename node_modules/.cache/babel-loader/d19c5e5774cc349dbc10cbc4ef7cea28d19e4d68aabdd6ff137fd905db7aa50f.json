{"ast":null,"code":"/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\r\n */\nvar fs = require('graceful-fs');\nvar path = require('path');\nvar flatten = require('lodash.flatten');\nvar difference = require('lodash.difference');\nvar union = require('lodash.union');\nvar isPlainObject = require('lodash.isplainobject');\nvar glob = require('glob');\nvar file = module.exports = {};\nvar pathSeparatorRe = /[\\/\\\\]/g;\n\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nvar processPatterns = function (patterns, fn) {\n  // Filepaths to return.\n  var result = [];\n  // Iterate over flattened patterns array.\n  flatten(patterns).forEach(function (pattern) {\n    // If the first character is ! it should be omitted\n    var exclusion = pattern.indexOf('!') === 0;\n    // If the pattern is an exclusion, remove the !\n    if (exclusion) {\n      pattern = pattern.slice(1);\n    }\n    // Find all matching files for this pattern.\n    var matches = fn(pattern);\n    if (exclusion) {\n      // If an exclusion, remove matching files.\n      result = difference(result, matches);\n    } else {\n      // Otherwise add matching files.\n      result = union(result, matches);\n    }\n  });\n  return result;\n};\n\n// True if the file path exists.\nfile.exists = function () {\n  var filepath = path.join.apply(path, arguments);\n  return fs.existsSync(filepath);\n};\n\n// Return an array of all file paths that match the given wildcard patterns.\nfile.expand = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  // If the first argument is an options object, save those options to pass\n  // into the File.prototype.glob.sync method.\n  var options = isPlainObject(args[0]) ? args.shift() : {};\n  // Use the first argument if it's an Array, otherwise convert the arguments\n  // object to an array and use that.\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0) {\n    return [];\n  }\n  // Return all matching filepaths.\n  var matches = processPatterns(patterns, function (pattern) {\n    // Find all matching files for this pattern.\n    return glob.sync(pattern, options);\n  });\n  // Filter result set?\n  if (options.filter) {\n    matches = matches.filter(function (filepath) {\n      filepath = path.join(options.cwd || '', filepath);\n      try {\n        if (typeof options.filter === 'function') {\n          return options.filter(filepath);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch (e) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n  return matches;\n};\n\n// Build a multi task \"files\" object dynamically.\nfile.expandMapping = function (patterns, destBase, options) {\n  options = Object.assign({\n    rename: function (destBase, destPath) {\n      return path.join(destBase || '', destPath);\n    }\n  }, options);\n  var files = [];\n  var fileByDest = {};\n  // Find all files matching pattern, using passed-in options.\n  file.expand(options, patterns).forEach(function (src) {\n    var destPath = src;\n    // Flatten?\n    if (options.flatten) {\n      destPath = path.basename(destPath);\n    }\n    // Change the extension?\n    if (options.ext) {\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\n    }\n    // Generate destination filename.\n    var dest = options.rename(destBase, destPath, options);\n    // Prepend cwd to src path if necessary.\n    if (options.cwd) {\n      src = path.join(options.cwd, src);\n    }\n    // Normalize filepaths to be unix-style.\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/');\n    // Map correct src path to dest path.\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest\n      });\n      // And store a reference for later use.\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n};\n\n// reusing bits of grunt's multi-task source normalization\nfile.normalizeFilesArray = function (data) {\n  var files = [];\n  data.forEach(function (obj) {\n    var prop;\n    if ('src' in obj || 'dest' in obj) {\n      files.push(obj);\n    }\n  });\n  if (files.length === 0) {\n    return [];\n  }\n  files = _(files).chain().forEach(function (obj) {\n    if (!('src' in obj) || !obj.src) {\n      return;\n    }\n    // Normalize .src properties to flattened array.\n    if (Array.isArray(obj.src)) {\n      obj.src = flatten(obj.src);\n    } else {\n      obj.src = [obj.src];\n    }\n  }).map(function (obj) {\n    // Build options object, removing unwanted properties.\n    var expandOptions = Object.assign({}, obj);\n    delete expandOptions.src;\n    delete expandOptions.dest;\n\n    // Expand file mappings.\n    if (obj.expand) {\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function (mapObj) {\n        // Copy obj properties to result.\n        var result = Object.assign({}, obj);\n        // Make a clone of the orig obj available.\n        result.orig = Object.assign({}, obj);\n        // Set .src and .dest, processing both as templates.\n        result.src = mapObj.src;\n        result.dest = mapObj.dest;\n        // Remove unwanted properties.\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function (prop) {\n          delete result[prop];\n        });\n        return result;\n      });\n    }\n\n    // Copy obj properties to result, adding an .orig property.\n    var result = Object.assign({}, obj);\n    // Make a clone of the orig obj available.\n    result.orig = Object.assign({}, obj);\n    if ('src' in result) {\n      // Expose an expand-on-demand getter method as .src.\n      Object.defineProperty(result, 'src', {\n        enumerable: true,\n        get: function fn() {\n          var src;\n          if (!('result' in fn)) {\n            src = obj.src;\n            // If src is an array, flatten it. Otherwise, make it into an array.\n            src = Array.isArray(src) ? flatten(src) : [src];\n            // Expand src files, memoizing result.\n            fn.result = file.expand(expandOptions, src);\n          }\n          return fn.result;\n        }\n      });\n    }\n    if ('dest' in result) {\n      result.dest = obj.dest;\n    }\n    return result;\n  }).flatten().value();\n  return files;\n};","map":{"version":3,"names":["fs","require","path","flatten","difference","union","isPlainObject","glob","file","module","exports","pathSeparatorRe","processPatterns","patterns","fn","result","forEach","pattern","exclusion","indexOf","slice","matches","exists","filepath","join","apply","arguments","existsSync","expand","args","options","shift","Array","isArray","length","sync","filter","cwd","statSync","e","expandMapping","destBase","Object","assign","rename","destPath","files","fileByDest","src","basename","ext","replace","dest","push","normalizeFilesArray","data","obj","prop","_","chain","map","expandOptions","mapObj","orig","defineProperty","enumerable","get","value"],"sources":["/Users/abc/Downloads/Workspace/c2i/image-text/c2i-convert/node_modules/archiver-utils/file.js"],"sourcesContent":["/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\r\n */\r\nvar fs = require('graceful-fs');\r\nvar path = require('path');\r\n\r\nvar flatten = require('lodash.flatten');\r\nvar difference = require('lodash.difference');\r\nvar union = require('lodash.union');\r\nvar isPlainObject = require('lodash.isplainobject');\r\n\r\nvar glob = require('glob');\r\n\r\nvar file = module.exports = {};\r\n\r\nvar pathSeparatorRe = /[\\/\\\\]/g;\r\n\r\n// Process specified wildcard glob patterns or filenames against a\r\n// callback, excluding and uniquing files in the result set.\r\nvar processPatterns = function(patterns, fn) {\r\n  // Filepaths to return.\r\n  var result = [];\r\n  // Iterate over flattened patterns array.\r\n  flatten(patterns).forEach(function(pattern) {\r\n    // If the first character is ! it should be omitted\r\n    var exclusion = pattern.indexOf('!') === 0;\r\n    // If the pattern is an exclusion, remove the !\r\n    if (exclusion) { pattern = pattern.slice(1); }\r\n    // Find all matching files for this pattern.\r\n    var matches = fn(pattern);\r\n    if (exclusion) {\r\n      // If an exclusion, remove matching files.\r\n      result = difference(result, matches);\r\n    } else {\r\n      // Otherwise add matching files.\r\n      result = union(result, matches);\r\n    }\r\n  });\r\n  return result;\r\n};\r\n\r\n// True if the file path exists.\r\nfile.exists = function() {\r\n  var filepath = path.join.apply(path, arguments);\r\n  return fs.existsSync(filepath);\r\n};\r\n\r\n// Return an array of all file paths that match the given wildcard patterns.\r\nfile.expand = function(...args) {\r\n  // If the first argument is an options object, save those options to pass\r\n  // into the File.prototype.glob.sync method.\r\n  var options = isPlainObject(args[0]) ? args.shift() : {};\r\n  // Use the first argument if it's an Array, otherwise convert the arguments\r\n  // object to an array and use that.\r\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\r\n  // Return empty set if there are no patterns or filepaths.\r\n  if (patterns.length === 0) { return []; }\r\n  // Return all matching filepaths.\r\n  var matches = processPatterns(patterns, function(pattern) {\r\n    // Find all matching files for this pattern.\r\n    return glob.sync(pattern, options);\r\n  });\r\n  // Filter result set?\r\n  if (options.filter) {\r\n    matches = matches.filter(function(filepath) {\r\n      filepath = path.join(options.cwd || '', filepath);\r\n      try {\r\n        if (typeof options.filter === 'function') {\r\n          return options.filter(filepath);\r\n        } else {\r\n          // If the file is of the right type and exists, this should work.\r\n          return fs.statSync(filepath)[options.filter]();\r\n        }\r\n      } catch(e) {\r\n        // Otherwise, it's probably not the right type.\r\n        return false;\r\n      }\r\n    });\r\n  }\r\n  return matches;\r\n};\r\n\r\n// Build a multi task \"files\" object dynamically.\r\nfile.expandMapping = function(patterns, destBase, options) {\r\n  options = Object.assign({\r\n    rename: function(destBase, destPath) {\r\n      return path.join(destBase || '', destPath);\r\n    }\r\n  }, options);\r\n  var files = [];\r\n  var fileByDest = {};\r\n  // Find all files matching pattern, using passed-in options.\r\n  file.expand(options, patterns).forEach(function(src) {\r\n    var destPath = src;\r\n    // Flatten?\r\n    if (options.flatten) {\r\n      destPath = path.basename(destPath);\r\n    }\r\n    // Change the extension?\r\n    if (options.ext) {\r\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\r\n    }\r\n    // Generate destination filename.\r\n    var dest = options.rename(destBase, destPath, options);\r\n    // Prepend cwd to src path if necessary.\r\n    if (options.cwd) { src = path.join(options.cwd, src); }\r\n    // Normalize filepaths to be unix-style.\r\n    dest = dest.replace(pathSeparatorRe, '/');\r\n    src = src.replace(pathSeparatorRe, '/');\r\n    // Map correct src path to dest path.\r\n    if (fileByDest[dest]) {\r\n      // If dest already exists, push this src onto that dest's src array.\r\n      fileByDest[dest].src.push(src);\r\n    } else {\r\n      // Otherwise create a new src-dest file mapping object.\r\n      files.push({\r\n        src: [src],\r\n        dest: dest,\r\n      });\r\n      // And store a reference for later use.\r\n      fileByDest[dest] = files[files.length - 1];\r\n    }\r\n  });\r\n  return files;\r\n};\r\n\r\n// reusing bits of grunt's multi-task source normalization\r\nfile.normalizeFilesArray = function(data) {\r\n  var files = [];\r\n\r\n  data.forEach(function(obj) {\r\n    var prop;\r\n    if ('src' in obj || 'dest' in obj) {\r\n      files.push(obj);\r\n    }\r\n  });\r\n\r\n  if (files.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  files = _(files).chain().forEach(function(obj) {\r\n    if (!('src' in obj) || !obj.src) { return; }\r\n    // Normalize .src properties to flattened array.\r\n    if (Array.isArray(obj.src)) {\r\n      obj.src = flatten(obj.src);\r\n    } else {\r\n      obj.src = [obj.src];\r\n    }\r\n  }).map(function(obj) {\r\n    // Build options object, removing unwanted properties.\r\n    var expandOptions = Object.assign({}, obj);\r\n    delete expandOptions.src;\r\n    delete expandOptions.dest;\r\n\r\n    // Expand file mappings.\r\n    if (obj.expand) {\r\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {\r\n        // Copy obj properties to result.\r\n        var result = Object.assign({}, obj);\r\n        // Make a clone of the orig obj available.\r\n        result.orig = Object.assign({}, obj);\r\n        // Set .src and .dest, processing both as templates.\r\n        result.src = mapObj.src;\r\n        result.dest = mapObj.dest;\r\n        // Remove unwanted properties.\r\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) {\r\n          delete result[prop];\r\n        });\r\n        return result;\r\n      });\r\n    }\r\n\r\n    // Copy obj properties to result, adding an .orig property.\r\n    var result = Object.assign({}, obj);\r\n    // Make a clone of the orig obj available.\r\n    result.orig = Object.assign({}, obj);\r\n\r\n    if ('src' in result) {\r\n      // Expose an expand-on-demand getter method as .src.\r\n      Object.defineProperty(result, 'src', {\r\n        enumerable: true,\r\n        get: function fn() {\r\n          var src;\r\n          if (!('result' in fn)) {\r\n            src = obj.src;\r\n            // If src is an array, flatten it. Otherwise, make it into an array.\r\n            src = Array.isArray(src) ? flatten(src) : [src];\r\n            // Expand src files, memoizing result.\r\n            fn.result = file.expand(expandOptions, src);\r\n          }\r\n          return fn.result;\r\n        }\r\n      });\r\n    }\r\n\r\n    if ('dest' in result) {\r\n      result.dest = obj.dest;\r\n    }\r\n\r\n    return result;\r\n  }).flatten().value();\r\n\r\n  return files;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}