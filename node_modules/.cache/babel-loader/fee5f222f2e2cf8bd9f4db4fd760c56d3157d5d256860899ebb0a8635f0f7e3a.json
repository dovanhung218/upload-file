{"ast":null,"code":"'use strict';\n\nvar resolveCommand = require('./util/resolveCommand');\nvar hasEmptyArgumentBug = require('./util/hasEmptyArgumentBug');\nvar escapeArgument = require('./util/escapeArgument');\nvar escapeCommand = require('./util/escapeCommand');\nvar readShebang = require('./util/readShebang');\nvar isWin = process.platform === 'win32';\nvar skipShellRegExp = /\\.(?:com|exe)$/i;\n\n// Supported in Node >= 6 and >= 4.8\nvar supportsShellOption = parseInt(process.version.substr(1).split('.')[0], 10) >= 6 || parseInt(process.version.substr(1).split('.')[0], 10) === 4 && parseInt(process.version.substr(1).split('.')[1], 10) >= 8;\nfunction parseNonShell(parsed) {\n  var shebang;\n  var needsShell;\n  var applyQuotes;\n  if (!isWin) {\n    return parsed;\n  }\n\n  // Detect & add support for shebangs\n  parsed.file = resolveCommand(parsed.command);\n  parsed.file = parsed.file || resolveCommand(parsed.command, true);\n  shebang = parsed.file && readShebang(parsed.file);\n  if (shebang) {\n    parsed.args.unshift(parsed.file);\n    parsed.command = shebang;\n    needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(resolveCommand(shebang) || resolveCommand(shebang, true));\n  } else {\n    needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(parsed.file);\n  }\n\n  // If a shell is required, use cmd.exe and take care of escaping everything correctly\n  if (needsShell) {\n    // Escape command & arguments\n    applyQuotes = parsed.command !== 'echo'; // Do not quote arguments for the special \"echo\" command\n    parsed.command = escapeCommand(parsed.command);\n    parsed.args = parsed.args.map(function (arg) {\n      return escapeArgument(arg, applyQuotes);\n    });\n\n    // Make use of cmd.exe\n    parsed.args = ['/d', '/s', '/c', '\"' + parsed.command + (parsed.args.length ? ' ' + parsed.args.join(' ') : '') + '\"'];\n    parsed.command = process.env.comspec || 'cmd.exe';\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  }\n\n  return parsed;\n}\nfunction parseShell(parsed) {\n  var shellCommand;\n\n  // If node supports the shell option, there's no need to mimic its behavior\n  if (supportsShellOption) {\n    return parsed;\n  }\n\n  // Mimic node shell option, see: https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n  shellCommand = [parsed.command].concat(parsed.args).join(' ');\n  if (isWin) {\n    parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n    parsed.args = ['/d', '/s', '/c', '\"' + shellCommand + '\"'];\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  } else {\n    if (typeof parsed.options.shell === 'string') {\n      parsed.command = parsed.options.shell;\n    } else if (process.platform === 'android') {\n      parsed.command = '/system/bin/sh';\n    } else {\n      parsed.command = '/bin/sh';\n    }\n    parsed.args = ['-c', shellCommand];\n  }\n  return parsed;\n}\n\n// ------------------------------------------------\n\nfunction parse(command, args, options) {\n  var parsed;\n\n  // Normalize arguments, similar to nodejs\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n  options = options || {};\n\n  // Build our parsed object\n  parsed = {\n    command: command,\n    args: args,\n    options: options,\n    file: undefined,\n    original: command\n  };\n\n  // Delegate further parsing to shell or non-shell\n  return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\nmodule.exports = parse;","map":{"version":3,"names":["resolveCommand","require","hasEmptyArgumentBug","escapeArgument","escapeCommand","readShebang","isWin","process","platform","skipShellRegExp","supportsShellOption","parseInt","version","substr","split","parseNonShell","parsed","shebang","needsShell","applyQuotes","file","command","args","unshift","test","map","arg","length","join","env","comspec","options","windowsVerbatimArguments","parseShell","shellCommand","concat","shell","parse","Array","isArray","slice","undefined","original","module","exports"],"sources":["/Users/abc/Downloads/Workspace/c2i/image-text/c2i-convert/node_modules/redocx/node_modules/cross-spawn/lib/parse.js"],"sourcesContent":["'use strict';\n\nvar resolveCommand = require('./util/resolveCommand');\nvar hasEmptyArgumentBug = require('./util/hasEmptyArgumentBug');\nvar escapeArgument = require('./util/escapeArgument');\nvar escapeCommand = require('./util/escapeCommand');\nvar readShebang = require('./util/readShebang');\n\nvar isWin = process.platform === 'win32';\nvar skipShellRegExp = /\\.(?:com|exe)$/i;\n\n// Supported in Node >= 6 and >= 4.8\nvar supportsShellOption = parseInt(process.version.substr(1).split('.')[0], 10) >= 6 ||\n parseInt(process.version.substr(1).split('.')[0], 10) === 4 && parseInt(process.version.substr(1).split('.')[1], 10) >= 8;\n\nfunction parseNonShell(parsed) {\n    var shebang;\n    var needsShell;\n    var applyQuotes;\n\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    parsed.file = resolveCommand(parsed.command);\n    parsed.file = parsed.file || resolveCommand(parsed.command, true);\n    shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n        needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(resolveCommand(shebang) || resolveCommand(shebang, true));\n    } else {\n        needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(parsed.file);\n    }\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    if (needsShell) {\n        // Escape command & arguments\n        applyQuotes = (parsed.command !== 'echo');  // Do not quote arguments for the special \"echo\" command\n        parsed.command = escapeCommand(parsed.command);\n        parsed.args = parsed.args.map(function (arg) {\n            return escapeArgument(arg, applyQuotes);\n        });\n\n        // Make use of cmd.exe\n        parsed.args = ['/d', '/s', '/c', '\"' + parsed.command + (parsed.args.length ? ' ' + parsed.args.join(' ') : '') + '\"'];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true;  // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parseShell(parsed) {\n    var shellCommand;\n\n    // If node supports the shell option, there's no need to mimic its behavior\n    if (supportsShellOption) {\n        return parsed;\n    }\n\n    // Mimic node shell option, see: https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n    shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n    if (isWin) {\n        parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n        parsed.args = ['/d', '/s', '/c', '\"' + shellCommand + '\"'];\n        parsed.options.windowsVerbatimArguments = true;  // Tell node's spawn that the arguments are already escaped\n    } else {\n        if (typeof parsed.options.shell === 'string') {\n            parsed.command = parsed.options.shell;\n        } else if (process.platform === 'android') {\n            parsed.command = '/system/bin/sh';\n        } else {\n            parsed.command = '/bin/sh';\n        }\n\n        parsed.args = ['-c', shellCommand];\n    }\n\n    return parsed;\n}\n\n// ------------------------------------------------\n\nfunction parse(command, args, options) {\n    var parsed;\n\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : [];  // Clone array to avoid changing the original\n    options = options || {};\n\n    // Build our parsed object\n    parsed = {\n        command: command,\n        args: args,\n        options: options,\n        file: undefined,\n        original: command,\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}