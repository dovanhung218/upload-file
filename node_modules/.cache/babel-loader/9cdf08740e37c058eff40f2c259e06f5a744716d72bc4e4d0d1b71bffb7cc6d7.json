{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            step(\"next\", value);\n          }, function (err) {\n            step(\"throw\", err);\n          });\n        }\n      }\n      return step(\"next\");\n    });\n  };\n}\n\n/**\n * Render the component (passed to docx generator instance)\n * This is similar to react-pdf https://github.com/diegomura/react-pdf/blob/master/packages/react-pdf/src/index.js\n * @param {Object} input Root component\n */\nvar parse = function parse(input) {\n  var parseComponent = function () {\n    var _ref = _asyncToGenerator(function* (inputComponent) {\n      // This property is accessed due to https://github.com/nitin42/redocx/blob/master/src/renderer/renderer.js#L32  \n      var document = inputComponent.document;\n      yield document.render();\n      // Return the input component again because we rendered the children\n      // which weren't wrapped inside a parent.\n      // We async called the render method on all of the children.\n      return inputComponent;\n    });\n    return function parseComponent(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  var toBuffer = function () {\n    var _ref2 = _asyncToGenerator(function* () {\n      return yield parseComponent(input);\n    });\n    return function toBuffer() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  return {\n    toBuffer: toBuffer\n  };\n};\nexports.default = parse;","map":{"version":3,"names":["Object","defineProperty","exports","value","_asyncToGenerator","fn","gen","apply","arguments","Promise","resolve","reject","step","key","arg","info","error","done","then","err","parse","input","parseComponent","_ref","inputComponent","document","render","_x","toBuffer","_ref2","default"],"sources":["/Users/abc/Downloads/Workspace/c2i/image-text/c2i-convert/node_modules/redocx/lib/renderer/parse.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n/**\n * Render the component (passed to docx generator instance)\n * This is similar to react-pdf https://github.com/diegomura/react-pdf/blob/master/packages/react-pdf/src/index.js\n * @param {Object} input Root component\n */\nvar parse = function parse(input) {\n  var parseComponent = function () {\n    var _ref = _asyncToGenerator(function* (inputComponent) {\n      // This property is accessed due to https://github.com/nitin42/redocx/blob/master/src/renderer/renderer.js#L32  \n      var document = inputComponent.document;\n\n      yield document.render();\n      // Return the input component again because we rendered the children\n      // which weren't wrapped inside a parent.\n      // We async called the render method on all of the children.\n      return inputComponent;\n    });\n\n    return function parseComponent(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  var toBuffer = function () {\n    var _ref2 = _asyncToGenerator(function* () {\n      return yield parseComponent(input);\n    });\n\n    return function toBuffer() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  return {\n    toBuffer: toBuffer\n  };\n};\n\nexports.default = parse;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AAEF,SAASC,iBAAiB,CAACC,EAAE,EAAE;EAAE,OAAO,YAAY;IAAE,IAAIC,GAAG,GAAGD,EAAE,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IAAE,OAAO,IAAIC,OAAO,CAAC,UAAUC,OAAO,EAAEC,MAAM,EAAE;MAAE,SAASC,IAAI,CAACC,GAAG,EAAEC,GAAG,EAAE;QAAE,IAAI;UAAE,IAAIC,IAAI,GAAGT,GAAG,CAACO,GAAG,CAAC,CAACC,GAAG,CAAC;UAAE,IAAIX,KAAK,GAAGY,IAAI,CAACZ,KAAK;QAAE,CAAC,CAAC,OAAOa,KAAK,EAAE;UAAEL,MAAM,CAACK,KAAK,CAAC;UAAE;QAAQ;QAAE,IAAID,IAAI,CAACE,IAAI,EAAE;UAAEP,OAAO,CAACP,KAAK,CAAC;QAAE,CAAC,MAAM;UAAE,OAAOM,OAAO,CAACC,OAAO,CAACP,KAAK,CAAC,CAACe,IAAI,CAAC,UAAUf,KAAK,EAAE;YAAES,IAAI,CAAC,MAAM,EAAET,KAAK,CAAC;UAAE,CAAC,EAAE,UAAUgB,GAAG,EAAE;YAAEP,IAAI,CAAC,OAAO,EAAEO,GAAG,CAAC;UAAE,CAAC,CAAC;QAAE;MAAE;MAAE,OAAOP,IAAI,CAAC,MAAM,CAAC;IAAE,CAAC,CAAC;EAAE,CAAC;AAAE;;AAEzc;AACA;AACA;AACA;AACA;AACA,IAAIQ,KAAK,GAAG,SAASA,KAAK,CAACC,KAAK,EAAE;EAChC,IAAIC,cAAc,GAAG,YAAY;IAC/B,IAAIC,IAAI,GAAGnB,iBAAiB,CAAC,WAAWoB,cAAc,EAAE;MACtD;MACA,IAAIC,QAAQ,GAAGD,cAAc,CAACC,QAAQ;MAEtC,MAAMA,QAAQ,CAACC,MAAM,EAAE;MACvB;MACA;MACA;MACA,OAAOF,cAAc;IACvB,CAAC,CAAC;IAEF,OAAO,SAASF,cAAc,CAACK,EAAE,EAAE;MACjC,OAAOJ,IAAI,CAAChB,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IACpC,CAAC;EACH,CAAC,EAAE;EAEH,IAAIoB,QAAQ,GAAG,YAAY;IACzB,IAAIC,KAAK,GAAGzB,iBAAiB,CAAC,aAAa;MACzC,OAAO,MAAMkB,cAAc,CAACD,KAAK,CAAC;IACpC,CAAC,CAAC;IAEF,OAAO,SAASO,QAAQ,GAAG;MACzB,OAAOC,KAAK,CAACtB,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IACrC,CAAC;EACH,CAAC,EAAE;EAEH,OAAO;IACLoB,QAAQ,EAAEA;EACZ,CAAC;AACH,CAAC;AAED1B,OAAO,CAAC4B,OAAO,GAAGV,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}