{"ast":null,"code":"/**\r\n * Archiver Core\r\n *\r\n * @ignore\r\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\r\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\r\n */\nvar fs = require('fs');\nvar glob = require('glob');\nvar async = require('async');\nvar path = require('path');\nvar util = require('archiver-utils');\nvar inherits = require('util').inherits;\nvar ArchiverError = require('./error');\nvar Transform = require('readable-stream').Transform;\nvar win32 = process.platform === 'win32';\n\n/**\r\n * @constructor\r\n * @param {String} format The archive format to use.\r\n * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.\r\n */\nvar Archiver = function (format, options) {\n  if (!(this instanceof Archiver)) {\n    return new Archiver(format, options);\n  }\n  if (typeof format !== 'string') {\n    options = format;\n    format = 'zip';\n  }\n  options = this.options = util.defaults(options, {\n    highWaterMark: 1024 * 1024,\n    statConcurrency: 4\n  });\n  Transform.call(this, options);\n  this._format = false;\n  this._module = false;\n  this._pending = 0;\n  this._pointer = 0;\n  this._entriesCount = 0;\n  this._entriesProcessedCount = 0;\n  this._fsEntriesTotalBytes = 0;\n  this._fsEntriesProcessedBytes = 0;\n  this._queue = async.queue(this._onQueueTask.bind(this), 1);\n  this._queue.drain = this._onQueueDrain.bind(this);\n  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);\n  this._state = {\n    aborted: false,\n    finalize: false,\n    finalizing: false,\n    finalized: false,\n    modulePiped: false\n  };\n  this._streams = [];\n};\ninherits(Archiver, Transform);\n\n/**\r\n * Internal logic for `abort`.\r\n *\r\n * @private\r\n * @return void\r\n */\nArchiver.prototype._abort = function () {\n  this._state.aborted = true;\n  this._queue.kill();\n  this._statQueue.kill();\n  if (this._queue.idle()) {\n    this._shutdown();\n  }\n};\n\n/**\r\n * Internal helper for appending files.\r\n *\r\n * @private\r\n * @param  {String} filepath The source filepath.\r\n * @param  {EntryData} data The entry data.\r\n * @return void\r\n */\nArchiver.prototype._append = function (filepath, data) {\n  data = data || {};\n  var task = {\n    source: null,\n    filepath: filepath\n  };\n  if (!data.name) {\n    data.name = filepath;\n  }\n  data.sourcePath = filepath;\n  task.data = data;\n  this._entriesCount++;\n  if (data.stats && data.stats instanceof fs.Stats) {\n    task = this._updateQueueTaskWithStats(task, data.stats);\n    if (task) {\n      if (data.stats.size) {\n        this._fsEntriesTotalBytes += data.stats.size;\n      }\n      this._queue.push(task);\n    }\n  } else {\n    this._statQueue.push(task);\n  }\n};\n\n/**\r\n * Internal logic for `finalize`.\r\n *\r\n * @private\r\n * @return void\r\n */\nArchiver.prototype._finalize = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n  this._state.finalizing = true;\n  this._moduleFinalize();\n  this._state.finalizing = false;\n  this._state.finalized = true;\n};\n\n/**\r\n * Checks the various state variables to determine if we can `finalize`.\r\n *\r\n * @private\r\n * @return {Boolean}\r\n */\nArchiver.prototype._maybeFinalize = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return false;\n  }\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Appends an entry to the module.\r\n *\r\n * @private\r\n * @fires  Archiver#entry\r\n * @param  {(Buffer|Stream)} source\r\n * @param  {EntryData} data\r\n * @param  {Function} callback\r\n * @return void\r\n */\nArchiver.prototype._moduleAppend = function (source, data, callback) {\n  if (this._state.aborted) {\n    callback();\n    return;\n  }\n  this._module.append(source, data, function (err) {\n    this._task = null;\n    if (this._state.aborted) {\n      this._shutdown();\n      return;\n    }\n    if (err) {\n      this.emit('error', err);\n      setImmediate(callback);\n      return;\n    }\n\n    /**\r\n     * Fires when the entry's input has been processed and appended to the archive.\r\n     *\r\n     * @event Archiver#entry\r\n     * @type {EntryData}\r\n     */\n    this.emit('entry', data);\n    this._entriesProcessedCount++;\n    if (data.stats && data.stats.size) {\n      this._fsEntriesProcessedBytes += data.stats.size;\n    }\n\n    /**\r\n     * @event Archiver#progress\r\n     * @type {ProgressData}\r\n     */\n    this.emit('progress', {\n      entries: {\n        total: this._entriesCount,\n        processed: this._entriesProcessedCount\n      },\n      fs: {\n        totalBytes: this._fsEntriesTotalBytes,\n        processedBytes: this._fsEntriesProcessedBytes\n      }\n    });\n    setImmediate(callback);\n  }.bind(this));\n};\n\n/**\r\n * Finalizes the module.\r\n *\r\n * @private\r\n * @return void\r\n */\nArchiver.prototype._moduleFinalize = function () {\n  if (typeof this._module.finalize === 'function') {\n    this._module.finalize();\n  } else if (typeof this._module.end === 'function') {\n    this._module.end();\n  } else {\n    this.emit('error', new ArchiverError('NOENDMETHOD'));\n  }\n};\n\n/**\r\n * Pipes the module to our internal stream with error bubbling.\r\n *\r\n * @private\r\n * @return void\r\n */\nArchiver.prototype._modulePipe = function () {\n  this._module.on('error', this._onModuleError.bind(this));\n  this._module.pipe(this);\n  this._state.modulePiped = true;\n};\n\n/**\r\n * Determines if the current module supports a defined feature.\r\n *\r\n * @private\r\n * @param  {String} key\r\n * @return {Boolean}\r\n */\nArchiver.prototype._moduleSupports = function (key) {\n  if (!this._module.supports || !this._module.supports[key]) {\n    return false;\n  }\n  return this._module.supports[key];\n};\n\n/**\r\n * Unpipes the module from our internal stream.\r\n *\r\n * @private\r\n * @return void\r\n */\nArchiver.prototype._moduleUnpipe = function () {\n  this._module.unpipe(this);\n  this._state.modulePiped = false;\n};\n\n/**\r\n * Normalizes entry data with fallbacks for key properties.\r\n *\r\n * @private\r\n * @param  {Object} data\r\n * @param  {fs.Stats} stats\r\n * @return {Object}\r\n */\nArchiver.prototype._normalizeEntryData = function (data, stats) {\n  data = util.defaults(data, {\n    type: 'file',\n    name: null,\n    date: null,\n    mode: null,\n    prefix: null,\n    sourcePath: null,\n    stats: false\n  });\n  if (stats && data.stats === false) {\n    data.stats = stats;\n  }\n  var isDir = data.type === 'directory';\n  if (data.name) {\n    if (typeof data.prefix === 'string' && '' !== data.prefix) {\n      data.name = data.prefix + '/' + data.name;\n      data.prefix = null;\n    }\n    data.name = util.sanitizePath(data.name);\n    if (data.type !== 'symlink' && data.name.slice(-1) === '/') {\n      isDir = true;\n      data.type = 'directory';\n    } else if (isDir) {\n      data.name += '/';\n    }\n  }\n\n  // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644\n  if (typeof data.mode === 'number') {\n    if (win32) {\n      data.mode &= 511;\n    } else {\n      data.mode &= 4095;\n    }\n  } else if (data.stats && data.mode === null) {\n    if (win32) {\n      data.mode = data.stats.mode & 511;\n    } else {\n      data.mode = data.stats.mode & 4095;\n    }\n\n    // stat isn't reliable on windows; force 0755 for dir\n    if (win32 && isDir) {\n      data.mode = 493;\n    }\n  } else if (data.mode === null) {\n    data.mode = isDir ? 493 : 420;\n  }\n  if (data.stats && data.date === null) {\n    data.date = data.stats.mtime;\n  } else {\n    data.date = util.dateify(data.date);\n  }\n  return data;\n};\n\n/**\r\n * Error listener that re-emits error on to our internal stream.\r\n *\r\n * @private\r\n * @param  {Error} err\r\n * @return void\r\n */\nArchiver.prototype._onModuleError = function (err) {\n  /**\r\n   * @event Archiver#error\r\n   * @type {ErrorData}\r\n   */\n  this.emit('error', err);\n};\n\n/**\r\n * Checks the various state variables after queue has drained to determine if\r\n * we need to `finalize`.\r\n *\r\n * @private\r\n * @return void\r\n */\nArchiver.prototype._onQueueDrain = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n};\n\n/**\r\n * Appends each queue task to the module.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {Function} callback\r\n * @return void\r\n */\nArchiver.prototype._onQueueTask = function (task, callback) {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    callback();\n    return;\n  }\n  this._task = task;\n  this._moduleAppend(task.source, task.data, callback);\n};\n\n/**\r\n * Performs a file stat and reinjects the task back into the queue.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {Function} callback\r\n * @return void\r\n */\nArchiver.prototype._onStatQueueTask = function (task, callback) {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    callback();\n    return;\n  }\n  fs.lstat(task.filepath, function (err, stats) {\n    if (this._state.aborted) {\n      setImmediate(callback);\n      return;\n    }\n    if (err) {\n      this._entriesCount--;\n\n      /**\r\n       * @event Archiver#warning\r\n       * @type {ErrorData}\r\n       */\n      this.emit('warning', err);\n      setImmediate(callback);\n      return;\n    }\n    task = this._updateQueueTaskWithStats(task, stats);\n    if (task) {\n      if (stats.size) {\n        this._fsEntriesTotalBytes += stats.size;\n      }\n      this._queue.push(task);\n    }\n    setImmediate(callback);\n  }.bind(this));\n};\n\n/**\r\n * Unpipes the module and ends our internal stream.\r\n *\r\n * @private\r\n * @return void\r\n */\nArchiver.prototype._shutdown = function () {\n  this._moduleUnpipe();\n  this.end();\n};\n\n/**\r\n * Tracks the bytes emitted by our internal stream.\r\n *\r\n * @private\r\n * @param  {Buffer} chunk\r\n * @param  {String} encoding\r\n * @param  {Function} callback\r\n * @return void\r\n */\nArchiver.prototype._transform = function (chunk, encoding, callback) {\n  if (chunk) {\n    this._pointer += chunk.length;\n  }\n  callback(null, chunk);\n};\n\n/**\r\n * Updates and normalizes a queue task using stats data.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {fs.Stats} stats\r\n * @return {Object}\r\n */\nArchiver.prototype._updateQueueTaskWithStats = function (task, stats) {\n  if (stats.isFile()) {\n    task.data.type = 'file';\n    task.data.sourceType = 'stream';\n    task.source = util.lazyReadStream(task.filepath);\n  } else if (stats.isDirectory() && this._moduleSupports('directory')) {\n    task.data.name = util.trailingSlashIt(task.data.name);\n    task.data.type = 'directory';\n    task.data.sourcePath = util.trailingSlashIt(task.filepath);\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else if (stats.isSymbolicLink() && this._moduleSupports('symlink')) {\n    var linkPath = fs.readlinkSync(task.filepath);\n    var dirName = path.dirname(task.filepath);\n    task.data.type = 'symlink';\n    task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else {\n    if (stats.isDirectory()) {\n      this.emit('warning', new ArchiverError('DIRECTORYNOTSUPPORTED', task.data));\n    } else if (stats.isSymbolicLink()) {\n      this.emit('warning', new ArchiverError('SYMLINKNOTSUPPORTED', task.data));\n    } else {\n      this.emit('warning', new ArchiverError('ENTRYNOTSUPPORTED', task.data));\n    }\n    return null;\n  }\n  task.data = this._normalizeEntryData(task.data, stats);\n  return task;\n};\n\n/**\r\n * Aborts the archiving process, taking a best-effort approach, by:\r\n *\r\n * - removing any pending queue tasks\r\n * - allowing any active queue workers to finish\r\n * - detaching internal module pipes\r\n * - ending both sides of the Transform stream\r\n *\r\n * It will NOT drain any remaining sources.\r\n *\r\n * @return {this}\r\n */\nArchiver.prototype.abort = function () {\n  if (this._state.aborted || this._state.finalized) {\n    return this;\n  }\n  this._abort();\n  return this;\n};\n\n/**\r\n * Appends an input source (text string, buffer, or stream) to the instance.\r\n *\r\n * When the instance has received, processed, and emitted the input, the `entry`\r\n * event is fired.\r\n *\r\n * @fires  Archiver#entry\r\n * @param  {(Buffer|Stream|String)} source The input source.\r\n * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.\r\n * @return {this}\r\n */\nArchiver.prototype.append = function (source, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n  data = this._normalizeEntryData(data);\n  if (typeof data.name !== 'string' || data.name.length === 0) {\n    this.emit('error', new ArchiverError('ENTRYNAMEREQUIRED'));\n    return this;\n  }\n  if (data.type === 'directory' && !this._moduleSupports('directory')) {\n    this.emit('error', new ArchiverError('DIRECTORYNOTSUPPORTED', {\n      name: data.name\n    }));\n    return this;\n  }\n  source = util.normalizeInputSource(source);\n  if (Buffer.isBuffer(source)) {\n    data.sourceType = 'buffer';\n  } else if (util.isStream(source)) {\n    data.sourceType = 'stream';\n  } else {\n    this.emit('error', new ArchiverError('INPUTSTEAMBUFFERREQUIRED', {\n      name: data.name\n    }));\n    return this;\n  }\n  this._entriesCount++;\n  this._queue.push({\n    data: data,\n    source: source\n  });\n  return this;\n};\n\n/**\r\n * Appends a directory and its files, recursively, given its dirpath.\r\n *\r\n * @param  {String} dirpath The source directory path.\r\n * @param  {String} destpath The destination path within the archive.\r\n * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\nArchiver.prototype.directory = function (dirpath, destpath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n  if (typeof dirpath !== 'string' || dirpath.length === 0) {\n    this.emit('error', new ArchiverError('DIRECTORYDIRPATHREQUIRED'));\n    return this;\n  }\n  this._pending++;\n  if (destpath === false) {\n    destpath = '';\n  } else if (typeof destpath !== 'string') {\n    destpath = dirpath;\n  }\n  var dataFunction = false;\n  if (typeof data === 'function') {\n    dataFunction = data;\n    data = {};\n  } else if (typeof data !== 'object') {\n    data = {};\n  }\n  var globOptions = {\n    stat: false,\n    dot: true,\n    cwd: dirpath\n  };\n  function onGlobEnd() {\n    this._pending--;\n    this._maybeFinalize();\n  }\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n  function onGlobMatch(match) {\n    var ignoreMatch = false;\n    var entryData = Object.assign({}, data);\n    entryData.name = match;\n    entryData.prefix = destpath;\n    match = globber._makeAbs(match);\n    try {\n      if (dataFunction) {\n        entryData = dataFunction(entryData);\n        if (entryData === false) {\n          ignoreMatch = true;\n        } else if (typeof entryData !== 'object') {\n          throw new ArchiverError('DIRECTORYFUNCTIONINVALIDDATA', {\n            dirpath: dirpath\n          });\n        }\n      }\n    } catch (e) {\n      this.emit('error', e);\n      return;\n    }\n    if (ignoreMatch) {\n      return;\n    }\n    this._append(match, entryData);\n  }\n  var globber = glob('**', globOptions);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n  return this;\n};\n\n/**\r\n * Appends a file given its filepath using a\r\n * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to\r\n * prevent issues with open file limits.\r\n *\r\n * When the instance has received, processed, and emitted the file, the `entry`\r\n * event is fired.\r\n *\r\n * @param  {String} filepath The source filepath.\r\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\nArchiver.prototype.file = function (filepath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('FILEFILEPATHREQUIRED'));\n    return this;\n  }\n  this._append(filepath, data);\n  return this;\n};\n\n/**\r\n * Appends multiple files that match a glob pattern.\r\n *\r\n * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/node-glob#glob-primer} to match.\r\n * @param  {Object} options See [node-glob]{@link https://github.com/isaacs/node-glob#options}.\r\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\nArchiver.prototype.glob = function (pattern, options, data) {\n  this._pending++;\n  options = util.defaults(options, {\n    stat: false\n  });\n  function onGlobEnd() {\n    this._pending--;\n    this._maybeFinalize();\n  }\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n  function onGlobMatch(match) {\n    var entryData = Object.assign({}, data);\n    if (options.cwd) {\n      entryData.name = match;\n      match = globber._makeAbs(match);\n    }\n    this._append(match, entryData);\n  }\n  var globber = glob(pattern, options);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n  return this;\n};\n\n/**\r\n * Finalizes the instance and prevents further appending to the archive\r\n * structure (queue will continue til drained).\r\n *\r\n * The `end`, `close` or `finish` events on the destination stream may fire\r\n * right after calling this method so you should set listeners beforehand to\r\n * properly detect stream completion.\r\n *\r\n * @return {this}\r\n */\nArchiver.prototype.finalize = function () {\n  if (this._state.aborted) {\n    this.emit('error', new ArchiverError('ABORTED'));\n    return this;\n  }\n  if (this._state.finalize) {\n    this.emit('error', new ArchiverError('FINALIZING'));\n    return this;\n  }\n  this._state.finalize = true;\n  if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    var errored;\n    self._module.on('end', function () {\n      if (!errored) {\n        resolve();\n      }\n    });\n    self._module.on('error', function (err) {\n      errored = true;\n      reject(err);\n    });\n  });\n};\n\n/**\r\n * Sets the module format name used for archiving.\r\n *\r\n * @param {String} format The name of the format.\r\n * @return {this}\r\n */\nArchiver.prototype.setFormat = function (format) {\n  if (this._format) {\n    this.emit('error', new ArchiverError('FORMATSET'));\n    return this;\n  }\n  this._format = format;\n  return this;\n};\n\n/**\r\n * Sets the module used for archiving.\r\n *\r\n * @param {Function} module The function for archiver to interact with.\r\n * @return {this}\r\n */\nArchiver.prototype.setModule = function (module) {\n  if (this._state.aborted) {\n    this.emit('error', new ArchiverError('ABORTED'));\n    return this;\n  }\n  if (this._state.module) {\n    this.emit('error', new ArchiverError('MODULESET'));\n    return this;\n  }\n  this._module = module;\n  this._modulePipe();\n  return this;\n};\n\n/**\r\n * Appends a symlink to the instance.\r\n *\r\n * This does NOT interact with filesystem and is used for programmatically creating symlinks.\r\n *\r\n * @param  {String} filepath The symlink path (within archive).\r\n * @param  {String} target The target path (within archive).\r\n * @return {this}\r\n */\nArchiver.prototype.symlink = function (filepath, target) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKFILEPATHREQUIRED'));\n    return this;\n  }\n  if (typeof target !== 'string' || target.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKTARGETREQUIRED', {\n      filepath: filepath\n    }));\n    return this;\n  }\n  if (!this._moduleSupports('symlink')) {\n    this.emit('error', new ArchiverError('SYMLINKNOTSUPPORTED', {\n      filepath: filepath\n    }));\n    return this;\n  }\n  var data = {};\n  data.type = 'symlink';\n  data.name = filepath.replace(/\\\\/g, '/');\n  data.linkname = target.replace(/\\\\/g, '/');\n  data.sourceType = 'buffer';\n  this._entriesCount++;\n  this._queue.push({\n    data: data,\n    source: Buffer.concat([])\n  });\n  return this;\n};\n\n/**\r\n * Returns the current length (in bytes) that has been emitted.\r\n *\r\n * @return {Number}\r\n */\nArchiver.prototype.pointer = function () {\n  return this._pointer;\n};\n\n/**\r\n * Middleware-like helper that has yet to be fully implemented.\r\n *\r\n * @private\r\n * @param  {Function} plugin\r\n * @return {this}\r\n */\nArchiver.prototype.use = function (plugin) {\n  this._streams.push(plugin);\n  return this;\n};\nmodule.exports = Archiver;\n\n/**\r\n * @typedef {Object} CoreOptions\r\n * @global\r\n * @property {Number} [statConcurrency=4] Sets the number of workers used to\r\n * process the internal fs stat queue.\r\n */\n\n/**\r\n * @typedef {Object} TransformOptions\r\n * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream\r\n * will automatically end the readable side when the writable side ends and vice\r\n * versa.\r\n * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable\r\n * side of the stream. Has no effect if objectMode is true.\r\n * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable\r\n * side of the stream. Has no effect if objectMode is true.\r\n * @property {Boolean} [decodeStrings=true] Whether or not to decode strings\r\n * into Buffers before passing them to _write(). `Writable`\r\n * @property {String} [encoding=NULL] If specified, then buffers will be decoded\r\n * to strings using the specified encoding. `Readable`\r\n * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store\r\n * in the internal buffer before ceasing to read from the underlying resource.\r\n * `Readable` `Writable`\r\n * @property {Boolean} [objectMode=false] Whether this stream should behave as a\r\n * stream of objects. Meaning that stream.read(n) returns a single value instead\r\n * of a Buffer of size n. `Readable` `Writable`\r\n */\n\n/**\r\n * @typedef {Object} EntryData\r\n * @property {String} name Sets the entry name including internal path.\r\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\r\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\r\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\r\n * when working with methods like `directory` or `glob`.\r\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\r\n * for reduction of fs stat calls when stat data is already known.\r\n */\n\n/**\r\n * @typedef {Object} ErrorData\r\n * @property {String} message The message of the error.\r\n * @property {String} code The error code assigned to this error.\r\n * @property {String} data Additional data provided for reporting or debugging (where available).\r\n */\n\n/**\r\n * @typedef {Object} ProgressData\r\n * @property {Object} entries\r\n * @property {Number} entries.total Number of entries that have been appended.\r\n * @property {Number} entries.processed Number of entries that have been processed.\r\n * @property {Object} fs\r\n * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)\r\n * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)\r\n */","map":{"version":3,"names":["fs","require","glob","async","path","util","inherits","ArchiverError","Transform","win32","process","platform","Archiver","format","options","defaults","highWaterMark","statConcurrency","call","_format","_module","_pending","_pointer","_entriesCount","_entriesProcessedCount","_fsEntriesTotalBytes","_fsEntriesProcessedBytes","_queue","queue","_onQueueTask","bind","drain","_onQueueDrain","_statQueue","_onStatQueueTask","_state","aborted","finalize","finalizing","finalized","modulePiped","_streams","prototype","_abort","kill","idle","_shutdown","_append","filepath","data","task","source","name","sourcePath","stats","Stats","_updateQueueTaskWithStats","size","push","_finalize","_moduleFinalize","_maybeFinalize","_moduleAppend","callback","append","err","_task","emit","setImmediate","entries","total","processed","totalBytes","processedBytes","end","_modulePipe","on","_onModuleError","pipe","_moduleSupports","key","supports","_moduleUnpipe","unpipe","_normalizeEntryData","type","date","mode","prefix","isDir","sanitizePath","slice","mtime","dateify","lstat","_transform","chunk","encoding","length","isFile","sourceType","lazyReadStream","isDirectory","trailingSlashIt","Buffer","concat","isSymbolicLink","linkPath","readlinkSync","dirName","dirname","linkname","relative","resolve","abort","normalizeInputSource","isBuffer","isStream","directory","dirpath","destpath","dataFunction","globOptions","stat","dot","cwd","onGlobEnd","onGlobError","onGlobMatch","match","ignoreMatch","entryData","Object","assign","globber","_makeAbs","e","file","pattern","self","Promise","reject","errored","setFormat","setModule","module","symlink","target","replace","pointer","use","plugin","exports"],"sources":["/Users/abc/Downloads/Workspace/c2i/image-text/c2i-convert/node_modules/archiver/lib/core.js"],"sourcesContent":["/**\r\n * Archiver Core\r\n *\r\n * @ignore\r\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\r\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\r\n */\r\nvar fs = require('fs');\r\nvar glob = require('glob');\r\nvar async = require('async');\r\nvar path = require('path');\r\nvar util = require('archiver-utils');\r\n\r\nvar inherits = require('util').inherits;\r\nvar ArchiverError = require('./error');\r\nvar Transform = require('readable-stream').Transform;\r\n\r\nvar win32 = process.platform === 'win32';\r\n\r\n/**\r\n * @constructor\r\n * @param {String} format The archive format to use.\r\n * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.\r\n */\r\nvar Archiver = function(format, options) {\r\n  if (!(this instanceof Archiver)) {\r\n    return new Archiver(format, options);\r\n  }\r\n\r\n  if (typeof format !== 'string') {\r\n    options = format;\r\n    format = 'zip';\r\n  }\r\n\r\n  options = this.options = util.defaults(options, {\r\n    highWaterMark: 1024 * 1024,\r\n    statConcurrency: 4\r\n  });\r\n\r\n  Transform.call(this, options);\r\n\r\n  this._format = false;\r\n  this._module = false;\r\n  this._pending = 0;\r\n  this._pointer = 0;\r\n\r\n  this._entriesCount = 0;\r\n  this._entriesProcessedCount = 0;\r\n  this._fsEntriesTotalBytes = 0;\r\n  this._fsEntriesProcessedBytes = 0;\r\n\r\n  this._queue = async.queue(this._onQueueTask.bind(this), 1);\r\n  this._queue.drain = this._onQueueDrain.bind(this);\r\n\r\n  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);\r\n\r\n  this._state = {\r\n    aborted: false,\r\n    finalize: false,\r\n    finalizing: false,\r\n    finalized: false,\r\n    modulePiped: false\r\n  };\r\n\r\n  this._streams = [];\r\n};\r\n\r\ninherits(Archiver, Transform);\r\n\r\n/**\r\n * Internal logic for `abort`.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._abort = function() {\r\n  this._state.aborted = true;\r\n  this._queue.kill();\r\n  this._statQueue.kill();\r\n\r\n  if (this._queue.idle()) {\r\n    this._shutdown();\r\n  }\r\n};\r\n\r\n/**\r\n * Internal helper for appending files.\r\n *\r\n * @private\r\n * @param  {String} filepath The source filepath.\r\n * @param  {EntryData} data The entry data.\r\n * @return void\r\n */\r\nArchiver.prototype._append = function(filepath, data) {\r\n  data = data || {};\r\n\r\n  var task = {\r\n    source: null,\r\n    filepath: filepath\r\n  };\r\n\r\n  if (!data.name) {\r\n    data.name = filepath;\r\n  }\r\n\r\n  data.sourcePath = filepath;\r\n  task.data = data;\r\n  this._entriesCount++;\r\n\r\n  if (data.stats && data.stats instanceof fs.Stats) {\r\n    task = this._updateQueueTaskWithStats(task, data.stats);\r\n    if (task) {\r\n      if (data.stats.size) {\r\n        this._fsEntriesTotalBytes += data.stats.size;\r\n      }\r\n\r\n      this._queue.push(task);\r\n    }\r\n  } else {\r\n    this._statQueue.push(task);\r\n  }\r\n};\r\n\r\n/**\r\n * Internal logic for `finalize`.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._finalize = function() {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    return;\r\n  }\r\n\r\n  this._state.finalizing = true;\r\n\r\n  this._moduleFinalize();\r\n\r\n  this._state.finalizing = false;\r\n  this._state.finalized = true;\r\n};\r\n\r\n/**\r\n * Checks the various state variables to determine if we can `finalize`.\r\n *\r\n * @private\r\n * @return {Boolean}\r\n */\r\nArchiver.prototype._maybeFinalize = function() {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    return false;\r\n  }\r\n\r\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\r\n    this._finalize();\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Appends an entry to the module.\r\n *\r\n * @private\r\n * @fires  Archiver#entry\r\n * @param  {(Buffer|Stream)} source\r\n * @param  {EntryData} data\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._moduleAppend = function(source, data, callback) {\r\n  if (this._state.aborted) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  this._module.append(source, data, function(err) {\r\n    this._task = null;\r\n\r\n    if (this._state.aborted) {\r\n      this._shutdown();\r\n      return;\r\n    }\r\n\r\n    if (err) {\r\n      this.emit('error', err);\r\n      setImmediate(callback);\r\n      return;\r\n    }\r\n\r\n    /**\r\n     * Fires when the entry's input has been processed and appended to the archive.\r\n     *\r\n     * @event Archiver#entry\r\n     * @type {EntryData}\r\n     */\r\n    this.emit('entry', data);\r\n    this._entriesProcessedCount++;\r\n\r\n    if (data.stats && data.stats.size) {\r\n      this._fsEntriesProcessedBytes += data.stats.size;\r\n    }\r\n\r\n    /**\r\n     * @event Archiver#progress\r\n     * @type {ProgressData}\r\n     */\r\n    this.emit('progress', {\r\n      entries: {\r\n        total: this._entriesCount,\r\n        processed: this._entriesProcessedCount\r\n      },\r\n      fs: {\r\n        totalBytes: this._fsEntriesTotalBytes,\r\n        processedBytes: this._fsEntriesProcessedBytes\r\n      }\r\n    });\r\n\r\n    setImmediate(callback);\r\n  }.bind(this));\r\n};\r\n\r\n/**\r\n * Finalizes the module.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._moduleFinalize = function() {\r\n  if (typeof this._module.finalize === 'function') {\r\n    this._module.finalize();\r\n  } else if (typeof this._module.end === 'function') {\r\n    this._module.end();\r\n  } else {\r\n    this.emit('error', new ArchiverError('NOENDMETHOD'));\r\n  }\r\n};\r\n\r\n/**\r\n * Pipes the module to our internal stream with error bubbling.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._modulePipe = function() {\r\n  this._module.on('error', this._onModuleError.bind(this));\r\n  this._module.pipe(this);\r\n  this._state.modulePiped = true;\r\n};\r\n\r\n/**\r\n * Determines if the current module supports a defined feature.\r\n *\r\n * @private\r\n * @param  {String} key\r\n * @return {Boolean}\r\n */\r\nArchiver.prototype._moduleSupports = function(key) {\r\n  if (!this._module.supports || !this._module.supports[key]) {\r\n    return false;\r\n  }\r\n\r\n  return this._module.supports[key];\r\n};\r\n\r\n/**\r\n * Unpipes the module from our internal stream.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._moduleUnpipe = function() {\r\n  this._module.unpipe(this);\r\n  this._state.modulePiped = false;\r\n};\r\n\r\n/**\r\n * Normalizes entry data with fallbacks for key properties.\r\n *\r\n * @private\r\n * @param  {Object} data\r\n * @param  {fs.Stats} stats\r\n * @return {Object}\r\n */\r\nArchiver.prototype._normalizeEntryData = function(data, stats) {\r\n  data = util.defaults(data, {\r\n    type: 'file',\r\n    name: null,\r\n    date: null,\r\n    mode: null,\r\n    prefix: null,\r\n    sourcePath: null,\r\n    stats: false\r\n  });\r\n\r\n  if (stats && data.stats === false) {\r\n    data.stats = stats;\r\n  }\r\n\r\n  var isDir = data.type === 'directory';\r\n\r\n  if (data.name) {\r\n    if (typeof data.prefix === 'string' && '' !== data.prefix) {\r\n      data.name = data.prefix + '/' + data.name;\r\n      data.prefix = null;\r\n    }\r\n\r\n    data.name = util.sanitizePath(data.name);\r\n\r\n    if (data.type !== 'symlink' && data.name.slice(-1) === '/') {\r\n      isDir = true;\r\n      data.type = 'directory';\r\n    } else if (isDir) {\r\n      data.name += '/';\r\n    }\r\n  }\r\n\r\n  // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644\r\n  if (typeof data.mode === 'number') {\r\n    if (win32) {\r\n      data.mode &= 511;\r\n    } else {\r\n      data.mode &= 4095\r\n    }\r\n  } else if (data.stats && data.mode === null) {\r\n    if (win32) {\r\n      data.mode = data.stats.mode & 511;\r\n    } else {\r\n      data.mode = data.stats.mode & 4095;\r\n    }\r\n\r\n    // stat isn't reliable on windows; force 0755 for dir\r\n    if (win32 && isDir) {\r\n      data.mode = 493;\r\n    }\r\n  } else if (data.mode === null) {\r\n    data.mode = isDir ? 493 : 420;\r\n  }\r\n\r\n  if (data.stats && data.date === null) {\r\n    data.date = data.stats.mtime;\r\n  } else {\r\n    data.date = util.dateify(data.date);\r\n  }\r\n\r\n  return data;\r\n};\r\n\r\n/**\r\n * Error listener that re-emits error on to our internal stream.\r\n *\r\n * @private\r\n * @param  {Error} err\r\n * @return void\r\n */\r\nArchiver.prototype._onModuleError = function(err) {\r\n  /**\r\n   * @event Archiver#error\r\n   * @type {ErrorData}\r\n   */\r\n  this.emit('error', err);\r\n};\r\n\r\n/**\r\n * Checks the various state variables after queue has drained to determine if\r\n * we need to `finalize`.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._onQueueDrain = function() {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    return;\r\n  }\r\n\r\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\r\n    this._finalize();\r\n  }\r\n};\r\n\r\n/**\r\n * Appends each queue task to the module.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._onQueueTask = function(task, callback) {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  this._task = task;\r\n  this._moduleAppend(task.source, task.data, callback);\r\n};\r\n\r\n/**\r\n * Performs a file stat and reinjects the task back into the queue.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._onStatQueueTask = function(task, callback) {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  fs.lstat(task.filepath, function(err, stats) {\r\n    if (this._state.aborted) {\r\n      setImmediate(callback);\r\n      return;\r\n    }\r\n\r\n    if (err) {\r\n      this._entriesCount--;\r\n\r\n      /**\r\n       * @event Archiver#warning\r\n       * @type {ErrorData}\r\n       */\r\n      this.emit('warning', err);\r\n      setImmediate(callback);\r\n      return;\r\n    }\r\n\r\n    task = this._updateQueueTaskWithStats(task, stats);\r\n\r\n    if (task) {\r\n      if (stats.size) {\r\n        this._fsEntriesTotalBytes += stats.size;\r\n      }\r\n\r\n      this._queue.push(task);\r\n    }\r\n\r\n    setImmediate(callback);\r\n  }.bind(this));\r\n};\r\n\r\n/**\r\n * Unpipes the module and ends our internal stream.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._shutdown = function() {\r\n  this._moduleUnpipe();\r\n  this.end();\r\n};\r\n\r\n/**\r\n * Tracks the bytes emitted by our internal stream.\r\n *\r\n * @private\r\n * @param  {Buffer} chunk\r\n * @param  {String} encoding\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._transform = function(chunk, encoding, callback) {\r\n  if (chunk) {\r\n    this._pointer += chunk.length;\r\n  }\r\n\r\n  callback(null, chunk);\r\n};\r\n\r\n/**\r\n * Updates and normalizes a queue task using stats data.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {fs.Stats} stats\r\n * @return {Object}\r\n */\r\nArchiver.prototype._updateQueueTaskWithStats = function(task, stats) {\r\n  if (stats.isFile()) {\r\n    task.data.type = 'file';\r\n    task.data.sourceType = 'stream';\r\n    task.source = util.lazyReadStream(task.filepath);\r\n  } else if (stats.isDirectory() && this._moduleSupports('directory')) {\r\n    task.data.name = util.trailingSlashIt(task.data.name);\r\n    task.data.type = 'directory';\r\n    task.data.sourcePath = util.trailingSlashIt(task.filepath);\r\n    task.data.sourceType = 'buffer';\r\n    task.source = Buffer.concat([]);\r\n  } else if (stats.isSymbolicLink() && this._moduleSupports('symlink')) {\r\n    var linkPath = fs.readlinkSync(task.filepath);\r\n    var dirName = path.dirname(task.filepath);\r\n    task.data.type = 'symlink';\r\n    task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));\r\n    task.data.sourceType = 'buffer';\r\n    task.source = Buffer.concat([]);\r\n  } else {\r\n    if (stats.isDirectory()) {\r\n      this.emit('warning', new ArchiverError('DIRECTORYNOTSUPPORTED', task.data));\r\n    } else if (stats.isSymbolicLink()) {\r\n      this.emit('warning', new ArchiverError('SYMLINKNOTSUPPORTED', task.data));\r\n    } else {\r\n      this.emit('warning', new ArchiverError('ENTRYNOTSUPPORTED', task.data));\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  task.data = this._normalizeEntryData(task.data, stats);\r\n\r\n  return task;\r\n};\r\n\r\n/**\r\n * Aborts the archiving process, taking a best-effort approach, by:\r\n *\r\n * - removing any pending queue tasks\r\n * - allowing any active queue workers to finish\r\n * - detaching internal module pipes\r\n * - ending both sides of the Transform stream\r\n *\r\n * It will NOT drain any remaining sources.\r\n *\r\n * @return {this}\r\n */\r\nArchiver.prototype.abort = function() {\r\n  if (this._state.aborted || this._state.finalized) {\r\n    return this;\r\n  }\r\n\r\n  this._abort();\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends an input source (text string, buffer, or stream) to the instance.\r\n *\r\n * When the instance has received, processed, and emitted the input, the `entry`\r\n * event is fired.\r\n *\r\n * @fires  Archiver#entry\r\n * @param  {(Buffer|Stream|String)} source The input source.\r\n * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.append = function(source, data) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  data = this._normalizeEntryData(data);\r\n\r\n  if (typeof data.name !== 'string' || data.name.length === 0) {\r\n    this.emit('error', new ArchiverError('ENTRYNAMEREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  if (data.type === 'directory' && !this._moduleSupports('directory')) {\r\n    this.emit('error', new ArchiverError('DIRECTORYNOTSUPPORTED', { name: data.name }));\r\n    return this;\r\n  }\r\n\r\n  source = util.normalizeInputSource(source);\r\n\r\n  if (Buffer.isBuffer(source)) {\r\n    data.sourceType = 'buffer';\r\n  } else if (util.isStream(source)) {\r\n    data.sourceType = 'stream';\r\n  } else {\r\n    this.emit('error', new ArchiverError('INPUTSTEAMBUFFERREQUIRED', { name: data.name }));\r\n    return this;\r\n  }\r\n\r\n  this._entriesCount++;\r\n  this._queue.push({\r\n    data: data,\r\n    source: source\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a directory and its files, recursively, given its dirpath.\r\n *\r\n * @param  {String} dirpath The source directory path.\r\n * @param  {String} destpath The destination path within the archive.\r\n * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.directory = function(dirpath, destpath, data) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof dirpath !== 'string' || dirpath.length === 0) {\r\n    this.emit('error', new ArchiverError('DIRECTORYDIRPATHREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  this._pending++;\r\n\r\n  if (destpath === false) {\r\n    destpath = '';\r\n  } else if (typeof destpath !== 'string'){\r\n    destpath = dirpath;\r\n  }\r\n\r\n  var dataFunction = false;\r\n  if (typeof data === 'function') {\r\n    dataFunction = data;\r\n    data = {};\r\n  } else if (typeof data !== 'object') {\r\n    data = {};\r\n  }\r\n\r\n  var globOptions = {\r\n    stat: false,\r\n    dot: true,\r\n    cwd: dirpath\r\n  };\r\n\r\n  function onGlobEnd() {\r\n    this._pending--;\r\n    this._maybeFinalize();\r\n  }\r\n\r\n  function onGlobError(err) {\r\n    this.emit('error', err);\r\n  }\r\n\r\n  function onGlobMatch(match){\r\n    var ignoreMatch = false;\r\n    var entryData = Object.assign({}, data);\r\n    entryData.name = match;\r\n    entryData.prefix = destpath;\r\n    match = globber._makeAbs(match);\r\n\r\n    try {\r\n      if (dataFunction) {\r\n        entryData = dataFunction(entryData);\r\n\r\n        if (entryData === false) {\r\n          ignoreMatch = true;\r\n        } else if (typeof entryData !== 'object') {\r\n          throw new ArchiverError('DIRECTORYFUNCTIONINVALIDDATA', { dirpath: dirpath });\r\n        }\r\n      }\r\n    } catch(e) {\r\n      this.emit('error', e);\r\n      return;\r\n    }\r\n\r\n    if (ignoreMatch) {\r\n      return;\r\n    }\r\n\r\n    this._append(match, entryData);\r\n  }\r\n\r\n  var globber = glob('**', globOptions);\r\n  globber.on('error', onGlobError.bind(this));\r\n  globber.on('match', onGlobMatch.bind(this));\r\n  globber.on('end', onGlobEnd.bind(this));\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a file given its filepath using a\r\n * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to\r\n * prevent issues with open file limits.\r\n *\r\n * When the instance has received, processed, and emitted the file, the `entry`\r\n * event is fired.\r\n *\r\n * @param  {String} filepath The source filepath.\r\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.file = function(filepath, data) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof filepath !== 'string' || filepath.length === 0) {\r\n    this.emit('error', new ArchiverError('FILEFILEPATHREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  this._append(filepath, data);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends multiple files that match a glob pattern.\r\n *\r\n * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/node-glob#glob-primer} to match.\r\n * @param  {Object} options See [node-glob]{@link https://github.com/isaacs/node-glob#options}.\r\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.glob = function(pattern, options, data) {\r\n  this._pending++;\r\n\r\n  options = util.defaults(options, {\r\n    stat: false\r\n  });\r\n\r\n  function onGlobEnd() {\r\n    this._pending--;\r\n    this._maybeFinalize();\r\n  }\r\n\r\n  function onGlobError(err) {\r\n    this.emit('error', err);\r\n  }\r\n\r\n  function onGlobMatch(match){\r\n    var entryData = Object.assign({}, data);\r\n\r\n    if (options.cwd) {\r\n      entryData.name = match;\r\n      match = globber._makeAbs(match);\r\n    }\r\n\r\n    this._append(match, entryData);\r\n  }\r\n\r\n  var globber = glob(pattern, options);\r\n  globber.on('error', onGlobError.bind(this));\r\n  globber.on('match', onGlobMatch.bind(this));\r\n  globber.on('end', onGlobEnd.bind(this));\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Finalizes the instance and prevents further appending to the archive\r\n * structure (queue will continue til drained).\r\n *\r\n * The `end`, `close` or `finish` events on the destination stream may fire\r\n * right after calling this method so you should set listeners beforehand to\r\n * properly detect stream completion.\r\n *\r\n * @return {this}\r\n */\r\nArchiver.prototype.finalize = function() {\r\n  if (this._state.aborted) {\r\n    this.emit('error', new ArchiverError('ABORTED'));\r\n    return this;\r\n  }\r\n\r\n  if (this._state.finalize) {\r\n    this.emit('error', new ArchiverError('FINALIZING'));\r\n    return this;\r\n  }\r\n\r\n  this._state.finalize = true;\r\n\r\n  if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\r\n    this._finalize();\r\n  }\r\n\r\n  var self = this;\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    var errored;\r\n\r\n    self._module.on('end', function() {\r\n      if (!errored) {\r\n        resolve();\r\n      }\r\n    })\r\n\r\n    self._module.on('error', function(err) {\r\n      errored = true;\r\n      reject(err);\r\n    })\r\n  })\r\n};\r\n\r\n/**\r\n * Sets the module format name used for archiving.\r\n *\r\n * @param {String} format The name of the format.\r\n * @return {this}\r\n */\r\nArchiver.prototype.setFormat = function(format) {\r\n  if (this._format) {\r\n    this.emit('error', new ArchiverError('FORMATSET'));\r\n    return this;\r\n  }\r\n\r\n  this._format = format;\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets the module used for archiving.\r\n *\r\n * @param {Function} module The function for archiver to interact with.\r\n * @return {this}\r\n */\r\nArchiver.prototype.setModule = function(module) {\r\n  if (this._state.aborted) {\r\n    this.emit('error', new ArchiverError('ABORTED'));\r\n    return this;\r\n  }\r\n\r\n  if (this._state.module) {\r\n    this.emit('error', new ArchiverError('MODULESET'));\r\n    return this;\r\n  }\r\n\r\n  this._module = module;\r\n  this._modulePipe();\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a symlink to the instance.\r\n *\r\n * This does NOT interact with filesystem and is used for programmatically creating symlinks.\r\n *\r\n * @param  {String} filepath The symlink path (within archive).\r\n * @param  {String} target The target path (within archive).\r\n * @return {this}\r\n */\r\nArchiver.prototype.symlink = function(filepath, target) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof filepath !== 'string' || filepath.length === 0) {\r\n    this.emit('error', new ArchiverError('SYMLINKFILEPATHREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof target !== 'string' || target.length === 0) {\r\n    this.emit('error', new ArchiverError('SYMLINKTARGETREQUIRED', { filepath: filepath }));\r\n    return this;\r\n  }\r\n\r\n  if (!this._moduleSupports('symlink')) {\r\n    this.emit('error', new ArchiverError('SYMLINKNOTSUPPORTED', { filepath: filepath }));\r\n    return this;\r\n  }\r\n\r\n  var data = {};\r\n  data.type = 'symlink';\r\n  data.name = filepath.replace(/\\\\/g, '/');\r\n  data.linkname = target.replace(/\\\\/g, '/');\r\n  data.sourceType = 'buffer';\r\n\r\n  this._entriesCount++;\r\n  this._queue.push({\r\n    data: data,\r\n    source: Buffer.concat([])\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns the current length (in bytes) that has been emitted.\r\n *\r\n * @return {Number}\r\n */\r\nArchiver.prototype.pointer = function() {\r\n  return this._pointer;\r\n};\r\n\r\n/**\r\n * Middleware-like helper that has yet to be fully implemented.\r\n *\r\n * @private\r\n * @param  {Function} plugin\r\n * @return {this}\r\n */\r\nArchiver.prototype.use = function(plugin) {\r\n  this._streams.push(plugin);\r\n  return this;\r\n};\r\n\r\nmodule.exports = Archiver;\r\n\r\n/**\r\n * @typedef {Object} CoreOptions\r\n * @global\r\n * @property {Number} [statConcurrency=4] Sets the number of workers used to\r\n * process the internal fs stat queue.\r\n */\r\n\r\n/**\r\n * @typedef {Object} TransformOptions\r\n * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream\r\n * will automatically end the readable side when the writable side ends and vice\r\n * versa.\r\n * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable\r\n * side of the stream. Has no effect if objectMode is true.\r\n * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable\r\n * side of the stream. Has no effect if objectMode is true.\r\n * @property {Boolean} [decodeStrings=true] Whether or not to decode strings\r\n * into Buffers before passing them to _write(). `Writable`\r\n * @property {String} [encoding=NULL] If specified, then buffers will be decoded\r\n * to strings using the specified encoding. `Readable`\r\n * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store\r\n * in the internal buffer before ceasing to read from the underlying resource.\r\n * `Readable` `Writable`\r\n * @property {Boolean} [objectMode=false] Whether this stream should behave as a\r\n * stream of objects. Meaning that stream.read(n) returns a single value instead\r\n * of a Buffer of size n. `Readable` `Writable`\r\n */\r\n\r\n/**\r\n * @typedef {Object} EntryData\r\n * @property {String} name Sets the entry name including internal path.\r\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\r\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\r\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\r\n * when working with methods like `directory` or `glob`.\r\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\r\n * for reduction of fs stat calls when stat data is already known.\r\n */\r\n\r\n/**\r\n * @typedef {Object} ErrorData\r\n * @property {String} message The message of the error.\r\n * @property {String} code The error code assigned to this error.\r\n * @property {String} data Additional data provided for reporting or debugging (where available).\r\n */\r\n\r\n/**\r\n * @typedef {Object} ProgressData\r\n * @property {Object} entries\r\n * @property {Number} entries.total Number of entries that have been appended.\r\n * @property {Number} entries.processed Number of entries that have been processed.\r\n * @property {Object} fs\r\n * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)\r\n * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)\r\n */\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}